===== bin\axes.rs =====
//! # `axes` Main Entry Point
//!
//! This binary file serves as the main entry point for the `axes` application.
//! Its primary responsibilities are minimal and well-defined:
//!
//! 1.  **Initialization**: It initializes logging (in debug builds) and parses command-line
//!     arguments using `clap`.
//! 2.  **Execution**: It orchestrates the core application logic by calling `run_app`, which
//!     in turn delegates to the command dispatcher.
//! 3.  **Error Handling**: It provides a centralized, user-friendly error reporting mechanism
//!     for the entire application, handling specific cases like `clap`'s help/version exits
//!     and Ctrl+C interruptions.
//! 4.  **State Persistence**: After the application logic has completed, it efficiently checks
//!     if the global state has been modified (using the journaling state manager) and, if so,
//!     saves the updated state back to disk.
//!
//! This lean structure ensures that the application's entry point is simple and focused on
//! orchestration, while the complex logic is delegated to other modules.

use anyhow::Result;
use axes::{
    cli::{dispatcher, Cli}, core::index_manager, dev_utils, state::get_app_state, system::executor
};
use clap::Parser;
use colored::*;

/// The main entry point of the `axes` application.
fn main() {
    let _timer_total = dev_utils::BlockTimer::new("Total Execution");
    let cli = Cli::parse();

    #[cfg(debug_assertions)]
    {
        env_logger::init();
    }

    // --- Application Logic Execution ---
    // The core logic is now encapsulated and called here.
    let _timer_logic = dev_utils::BlockTimer::new("Core App Logic");
    if let Err(e) = run_app(cli) {
        // --- Graceful Error Handling (Unchanged) ---
        if let Some(clap_err) = e.downcast_ref::<clap::Error>()
            && !clap_err.use_stderr()
        {
            clap_err.print().expect("Failed to print clap help/version");
            std::process::exit(0);
        }

        if let Some(exec_err) = e.downcast_ref::<executor::ExecutionError>()
            && matches!(exec_err, executor::ExecutionError::Interrupted { .. })
        {
            eprintln!();
            std::process::exit(130); // Standard exit code for Ctrl+C
        }

        eprintln!("\n{}: {}", "Error".red().bold(), e);
        let mut causes = e.chain().skip(1);
        if let Some(cause) = causes.next() {
            eprintln!("\nCaused by:");
            eprintln!("   0: {}", cause);
            for (i, cause) in causes.enumerate() {
                eprintln!("   {}: {}", i + 1, cause);
            }
        }
        std::process::exit(1);
    }

    // --- State Saving Logic (Now highly efficient) ---
    // We only acquire the lock once at the very end.
    let state_arc = get_app_state();
    let state_guard = state_arc
        .lock()
        .expect("The main AppState mutex is poisoned, indicating a catastrophic failure.");

    // The MutexGuard allows us to access the methods of the inner AppState directly.
    // We call AppState::needs_saving() via the guard.
    if state_guard.needs_saving() {
        let _timer_save = dev_utils::BlockTimer::new("State Saving");
        // We call AppState::index() via the guard to get a reference to the GlobalIndex
        // that index_manager::save_global_index expects.
        if let Err(e) = index_manager::save_global_index(state_guard.index()) {
            eprintln!(
                "\n{}: Failed to save updated global index: {}",
                "Critical Error".red().bold(),
                e
            );
            std::process::exit(1);
        }
        log::debug!("Global index was modified and has been saved.");
    }
}

/// A wrapper function that contains the core application logic.
///
/// It acquires a lock on the global application state and passes it to the
/// command dispatcher. This cleanly separates the application's "business logic"
/// from the state persistence and error handling concerns in `main`.
///
/// # Arguments
/// * `cli` - The parsed command-line arguments.
fn run_app(cli: Cli) -> Result<()> {
    // Get a mutable guard to the global index.
    // This guard will automatically set the dirty flag if any handler mutates the index.
    let mut index_guard = axes::state::lock_app_state();

    // Delegate entirely to the new dispatcher.
    dispatcher::dispatch(cli.args, &mut index_guard)
}

===== cli\dispatcher.rs =====
//! # Command Dispatcher
//!
//! This module contains the core logic for parsing the application's "universal grammar"
//! and routing execution to the appropriate command handler. It acts as a central switchboard,
//! decoupling the `main` function from the specific implementation of each command.
//!
//! ## Universal Grammar
//!
//! The dispatcher interprets arguments based on a set of prioritized rules, rather than a
//! strict subcommand structure. This allows for more ergonomic and context-aware command
//! invocation. The rules are, in order of precedence:
//!
//! 1.  **Escape Hatch**: `axes <script_path> -- [params...]` -> `run` command.
//! 2.  **Explicit Action**: `axes <context> <action> [args...]` -> specific command in context.
//! 3.  **Global Action**: `axes <action> [args...]` -> specific command in global context.
//! 4.  **Implicit Script**: `axes <script_path> [params...]` -> `run` command by default.
//!
//! ## Components
//!
//! - **`CommandDefinition`**: A struct that associates a command name and its aliases with a
//!   handler function.
//! - **`COMMAND_REGISTRY`**: A static array that serves as the single source of truth for all
//!   registered commands in the system.
//! - **`dispatch()`**: The main public function that takes the raw command-line arguments and
//!   the application state, performs the grammatical analysis, and calls the corresponding handler.

use anyhow::Result;

use crate::{
    cli::handlers::{self, run::parse_script_path}, dev_utils, state::AppStateGuard
};

// --- Command Definition and Registry ---

/// Defines a system command, its aliases, and its handler function signature.
struct CommandDefinition {
    /// The primary, non-aliased name of the command.
    name: &'static str,
    /// A list of alternative names for the command.
    aliases: &'static [&'static str],
    /// A function pointer to the command's handler logic.
    handler: fn(Option<String>, Vec<String>, &mut AppStateGuard<'_>) -> Result<()>,
}

/// The single source of truth for all system commands.
static COMMAND_REGISTRY: &[CommandDefinition] = &[
    CommandDefinition {
        name: "alias",
        aliases: &[],
        handler: handlers::alias::handle,
    },
    CommandDefinition {
        name: "cache",
        aliases: &[],
        handler: handlers::debug_cache::handle,
    },
    CommandDefinition {
        name: "delete",
        aliases: &["del"],
        handler: handlers::delete::handle,
    },
    CommandDefinition {
        name: "info",
        aliases: &[],
        handler: handlers::info::handle,
    },
    CommandDefinition {
        name: "init",
        aliases: &["new"],
        handler: handlers::init::handle,
    },
    CommandDefinition {
        name: "link",
        aliases: &[],
        handler: handlers::link::handle,
    },
    CommandDefinition {
        name: "open",
        aliases: &[],
        handler: handlers::open::handle,
    },
    CommandDefinition {
        name: "register",
        aliases: &["reg"],
        handler: handlers::register::handle,
    },
    CommandDefinition {
        name: "rename",
        aliases: &[],
        handler: handlers::rename::handle,
    },
    CommandDefinition {
        name: "run",
        aliases: &[],
        handler: handlers::run::handle,
    },
    CommandDefinition {
        name: "start",
        aliases: &[],
        handler: handlers::start::handle,
    },
    CommandDefinition {
        name: "tree",
        aliases: &["ls"],
        handler: handlers::tree::handle,
    },
    CommandDefinition {
        name: "unregister",
        aliases: &["unreg"],
        handler: handlers::unregister::handle,
    },
    CommandDefinition {
        name: "repair",
        aliases: &["rep"],
        handler: handlers::repair::handle,
    },
];

/// Finds a command definition in the registry by its name or alias.
fn find_command(name: &str) -> Option<&'static CommandDefinition> {
    COMMAND_REGISTRY
        .iter()
        .find(|cmd| cmd.name == name || cmd.aliases.contains(&name))
}

/// The main application dispatcher implementing the new universal grammar.
pub fn dispatch(all_args: Vec<String>, index: &mut AppStateGuard<'_>) -> Result<()> {
    let _timer_dispatch = dev_utils::BlockTimer::new("Command Dispatch");
    log::debug!("Dispatching args: {:?}", all_args);

    if all_args.is_empty() {
        println!("Welcome to axes! (TUI placeholder)");
        return Ok(());
    }

    let arg1 = all_args
        .first()
        .expect("Argument list should not be empty here");
    let arg2 = all_args.get(1);

    // --- Dispatch Logic Cascade (Moved from main.rs) ---
    let (command_def, context, handler_args) = if let Some(arg2_val) = arg2 {
        let _timer_grammar = dev_utils::BlockTimer::new("Grammar Resolution");
        if arg2_val == "--" {
            // Rule 1 (Escape Hatch): `axes <script_path> -- [params...]`
            let (ctx_part, script_part) = parse_script_path(arg1);
            let mut params = vec![script_part.to_string()];
            params.extend(all_args.iter().skip(2).cloned());
            (
                find_command("run").expect("The 'run' command should always be registered"),
                ctx_part.map(|s| s.to_string()),
                params,
            )
        } else if let Some(command) = find_command(arg2_val) {
            // Rule 2 (Explicit Action): `axes <context> <action> [args...]`
            let params = all_args.iter().skip(2).cloned().collect();
            (command, Some(arg1.to_string()), params)
        } else if let Some(command) = find_command(arg1) {
            // Rule 3 (Global Action): `axes <action> [args...]`
            let params = all_args.iter().skip(1).cloned().collect();
            (command, None, params)
        } else {
            // Rule 4 (Default, Implicit Script): `axes <script_path> [params...]`
            let (ctx_part, script_part) = parse_script_path(arg1);
            let mut params = vec![script_part.to_string()];
            params.extend(all_args.iter().skip(1).cloned());
            (
                find_command("run").expect("The 'run' command should always be registered"),
                ctx_part.map(|s| s.to_string()),
                params,
            )
        }
    } else if let Some(command) = find_command(arg1) {
        // Rule 3 with a single argument
        (command, None, vec![])
    } else {
        // Rule 4 with a single argument
        let (ctx_part, script_part) = parse_script_path(arg1);
        (
            find_command("run").expect("The 'run' command should always be registered"),
            ctx_part.map(|s| s.to_string()),
            vec![script_part.to_string()],
        )
    };

    // --- Dispatch to Handler ---
    let _timer_handler = dev_utils::BlockTimer::new(format!("Handler: {}", command_def.name));
    (command_def.handler)(context, handler_args, index)
}

===== cli\handlers\alias.rs =====
//! # Handler for the `alias` command
//!
//! This module provides the logic for managing project shortcuts (aliases), allowing users
//! to create, list, remove, and check aliases that point to specific project contexts.
//!
//! ## Core Logic
//!
//! - **Subcommand Dispatch**: The main `handle` function parses the arguments into subcommands
//!   (`set`, `list`, `remove`, `check`) and calls the appropriate function.
//! - **State Management**: It correctly distinguishes between read operations (`list`, `check`)
//!   which use `.index()`, and write operations (`set`, `remove`) which use `.index_mut()`
//!   to ensure the application state is marked as dirty only when necessary.
//! - **Context Resolution**: The `set` command utilizes the `context_resolver` to find the
//!   target project's UUID, ensuring that aliases always point to valid, registered projects.
//! - **User Experience**: Includes user-friendly features like confirmation prompts for potentially
//!   sensitive operations (overwriting an alias, modifying the special 'g' alias) and formatted,
//!   sorted output for lists.

use anyhow::{Context, Result, anyhow};
use clap::{Parser, Subcommand};
use colored::*;
use dialoguer::{Confirm, console::measure_text_width, theme::ColorfulTheme};
use std::env;

use crate::{
    core::{context_resolver, index_manager},
    models::GlobalIndex,
    state::AppStateGuard,
};

// --- Command Argument Parsing ---

#[derive(Parser, Debug)]
#[command(no_binary_name = true, about = "Manage project shortcuts (aliases).")]
struct AliasArgs {
    #[command(subcommand)]
    command: Option<AliasCommand>,
}

#[derive(Subcommand, Debug)]
enum AliasCommand {
    /// Sets a new alias or updates an existing one.
    Set {
        /// The name for the alias (e.g., 'backend').
        name: String,
        /// The project context the alias should point to (e.g., 'my-app/api', 'g!', '.').
        context: String,
    },
    /// Lists all defined aliases.
    #[command(name = "list", aliases = ["ls"])]
    List,
    /// Removes an alias.
    #[command(name = "remove", aliases = ["rm"])]
    Remove {
        /// The name of the alias to remove.
        name: String,
    },
    /// Verifies all aliases, reporting any broken links.
    Check,
}

// --- Main Handler ---

/// The main handler for the `alias` command.
///
/// It dispatches to sub-handlers for set, list, remove, and check operations. It also
/// ensures that alias commands cannot be run from within an active project session.
///
/// # Arguments
/// * `_context` - The context from the dispatcher, which is ignored by this global command.
/// * `args` - The command-specific arguments (e.g., `set my-alias .`).
/// * `state_guard` - A mutable guard to the application state.
pub fn handle(
    _context: Option<String>,
    args: Vec<String>,
    state_guard: &mut AppStateGuard<'_>,
) -> Result<()> {
    // Aliases are a global concept and cannot be managed from within a project session.
    if env::var("AXES_PROJECT_UUID").is_ok() {
        return Err(anyhow!(t!("alias.error.not_in_session")));
    }
    // The `alias` command itself is global and does not depend on a context argument.
    // The `_context` parameter is ignored.

    let alias_args = AliasArgs::try_parse_from(&args)?;

    match alias_args.command.unwrap_or(AliasCommand::List) {
        AliasCommand::Set { name, context } => set_alias(&name, &context, state_guard),
        AliasCommand::List => {
            list_aliases(state_guard.index());
            Ok(())
        }
        AliasCommand::Remove { name } => remove_alias(&name, state_guard.index_mut()),
        AliasCommand::Check => {
            check_aliases(state_guard.index());
            Ok(())
        }
    }
}

// --- Subcommand Logic ---

/// Handles the logic for creating or updating an alias.
///
/// This is a write operation. It resolves the target context to a UUID and then
/// inserts or updates the alias in the `GlobalIndex`. It needs the full `AppStateGuard`
/// because it calls `context_resolver`, which may need to update `last_used` metadata.
///
/// # Arguments
/// * `name` - The name for the new alias.
/// * `context` - The context string the alias should point to.
/// * `state_guard` - A mutable guard to the application state.
fn set_alias(name: &str, context: &str, state_guard: &mut AppStateGuard<'_>) -> Result<()> {
    let clean_name = validate_alias_name(name)?;

    // Proceed only if user confirms modifying the special 'g' alias.
    if !confirm_g_alias_modification(&clean_name)? {
        return Ok(());
    }

    // Check if the alias already exists to provide better user feedback.
    let is_update = state_guard.index().aliases.contains_key(&clean_name);
    if is_update {
        let old_uuid = state_guard
            .index()
            .aliases
            .get(&clean_name)
            .expect("Alias key should exist as we are in the `is_update` block");
        let old_target = index_manager::build_qualified_name(*old_uuid, state_guard.index())
            .unwrap_or_else(|| t!("alias.info.broken_link").red().to_string());
        println!(
            "{}",
            format!(
                t!("alias.warning.overwriting"),
                name = clean_name,
                old_target = old_target
            )
            .yellow()
        );
    }

    let (target_uuid, target_name) = context_resolver::resolve_context(context, state_guard)
        .with_context(|| {
            format!(
                "The provided context '{}' for the alias could not be resolved.",
                context
            )
        })?;
    index_manager::set_alias(state_guard.index_mut(), clean_name.clone(), target_uuid);

    println!(
        "{} {} '{}!' -> '{}'",
        t!("common.success"),
        if is_update {
            t!("alias.success.updated")
        } else {
            t!("alias.success.set")
        },
        clean_name,
        target_name.cyan()
    );
    Ok(())
}

/// Handles the logic for listing all aliases in a formatted table.
///
/// This is a read-only operation. It iterates over the aliases in the `GlobalIndex`
/// and prints them in a sorted, aligned format.
///
/// # Arguments
/// * `index` - An immutable reference to the `GlobalIndex`.
fn list_aliases(index: &GlobalIndex) {
    if index.aliases.is_empty() {
        println!("\n{}", t!("alias.info.no_aliases"));
        return;
    }

    println!("\n{}:", t!("alias.info.header"));

    // Collect references, not owned values. Avoids cloning Strings and Uuids.
    let mut sorted_aliases: Vec<_> = index.aliases.iter().collect();
    sorted_aliases.sort_by_key(|(name, _)| *name);

    let max_len = sorted_aliases
        .iter()
        .map(|(name, _)| measure_text_width(&format!("{}!", name)))
        .max()
        .unwrap_or(0);

    for (name, uuid) in sorted_aliases {
        let target_name = index_manager::build_qualified_name(*uuid, index)
            .unwrap_or_else(|| t!("alias.info.broken_link").red().to_string());

        let alias_display_raw = format!("{}!", name);
        let alias_display_colored = format!("{}!", name.cyan());

        let visible_len = measure_text_width(&alias_display_raw);
        let padding = " ".repeat(max_len.saturating_sub(visible_len));

        println!("  {}{} ->  {}", alias_display_colored, padding, target_name);
    }
}

/// Handles the logic for removing an alias.
///
/// This is a write operation that removes an entry from the aliases map in the `GlobalIndex`.
///
/// # Arguments
/// * `name` - The name of the alias to remove.
/// * `index` - A mutable reference to the `GlobalIndex`.
fn remove_alias(name: &str, index: &mut GlobalIndex) -> Result<()> {
    let clean_name = validate_alias_name(name)?;

    if !confirm_g_alias_modification(&clean_name)? {
        return Ok(());
    }

    if index_manager::remove_alias(index, &clean_name) {
        // CRITICAL: Do NOT save the index here.
        println!(
            "{} {}",
            t!("common.success"),
            format_args!(t!("alias.success.removed"), name = clean_name)
        );
    } else {
        return Err(anyhow!(t!("alias.error.not_found"), name = clean_name));
    }
    Ok(())
}

/// Handles the logic for checking the health of all aliases.
///
/// This is a read-only operation. It iterates through all defined aliases and verifies
/// that their target UUIDs still correspond to existing projects in the index, reporting
/// any broken links.
///
/// # Arguments
/// * `index` - An immutable reference to the `GlobalIndex`.
fn check_aliases(index: &GlobalIndex) {
    if index.aliases.is_empty() {
        println!("\n{}", t!("alias.info.no_aliases"));
        return;
    }

    println!("\n{}", t!("alias.info.checking_header"));
    let mut broken_count = 0;

    let mut sorted_aliases: Vec<_> = index.aliases.iter().collect();
    sorted_aliases.sort_by_key(|(name, _)| *name);

    for (name, uuid) in sorted_aliases {
        match index_manager::build_qualified_name(*uuid, index) {
            Some(target_name) => {
                println!("  {} {}! -> {}", "✔".green(), name.cyan(), target_name);
            }
            None => {
                broken_count += 1;
                println!(
                    "  {} {}! -> {}",
                    "✖".red(),
                    name.cyan(),
                    t!("alias.info.broken_link").red()
                );
            }
        }
    }

    println!("---");
    if broken_count == 0 {
        println!("{} {}", t!("common.success"), t!("alias.success.all_ok"));
    } else {
        println!(
            "{}",
            format!(t!("alias.warning.found_broken"), count = broken_count).yellow()
        );
    }
}

// --- Helper Functions ---

/// A helper function to validate an alias name against reserved keywords and syntax rules.
/// It also conveniently strips the optional `!` suffix from user input.
fn validate_alias_name(raw_name: &str) -> Result<String> {
    // Allow user to conveniently type the alias with or without the '!' suffix.
    let name = raw_name.trim().strip_suffix('!').unwrap_or(raw_name.trim());

    if name.is_empty() {
        return Err(anyhow!(t!("alias.error.empty_name")));
    }
    if name.contains(char::is_whitespace) || name.contains('/') || name.contains('\\') {
        return Err(anyhow!(t!("alias.error.invalid_chars"), name = name));
    }

    // These are reserved for context resolution and cannot be used for aliases.
    let reserved_nav_names = [".", "..", "*", "**", "_"];
    if reserved_nav_names.contains(&name.to_lowercase().as_str()) {
        return Err(anyhow!(t!("alias.error.reserved_name"), name = name));
    }

    Ok(name.to_string())
}

/// A shared helper to ask for user confirmation if they are attempting to modify the
/// special 'g' alias, which is conventionally used for the global project.
fn confirm_g_alias_modification(name: &str) -> Result<bool> {
    if name.to_lowercase() == "g" {
        println!("{}", t!("alias.warning.modifying_g").yellow().bold());
        if !Confirm::with_theme(&ColorfulTheme::default())
            .with_prompt(t!("common.prompt.are_you_sure"))
            .default(false)
            .interact()?
        {
            println!("\n{}", t!("common.info.operation_cancelled"));
            return Ok(false); // User cancelled the operation.
        }
    }
    Ok(true)
}

===== cli\handlers\commons.rs =====
//! # Common Handler Utilities
//!
//! This module provides a collection of shared functions and data structures that are used
//! across multiple command handlers. Centralizing this logic promotes code reuse (DRY) and
//! ensures consistent behavior for common operations like configuration resolution,
//! operational planning, and interactive user prompts.
//!
//! ## Key Components
//!
//! - **`resolve_config_for_context`**: The main entry point for handlers to obtain a fully
//!   resolved, lazy-loaded `ResolvedConfig` for a given project context.
//! - **`OperationPlan`**: A unified struct for "dry-running" destructive or state-changing
//!   operations like `delete` and `unregister`, allowing the plan to be presented to the
//!   user for confirmation before execution.
//! - **Interactive Helpers**: Functions like `choose_parent_interactive` provide consistent,
//!   multi-modal UI for common tasks like selecting a project from the index.
//! - **Validation**: Utilities such as `validate_project_name` enforce consistent naming
//!   rules throughout the application.
//! - **Parameter Parsing**: Helpers like `build_resolver_for_task` abstract the logic
//!   of preparing command-line arguments for script execution.

use anyhow::{Context, Result, anyhow};
use std::{
    collections::{HashMap, HashSet},
    path::PathBuf,
    sync::Arc,
};
use uuid::Uuid;

use crate::{
    core::{
        context_resolver,
        index_manager::{self},
        parameters::ArgResolver,
    },
    models::{
        CommandAction, GlobalIndex, IndexEntry, ParameterDef, ResolvedConfig, Task,
        TemplateComponent,
    },
    state::AppStateGuard,
};

use dialoguer::{Confirm, Input, Select, theme::ColorfulTheme};

use colored::Colorize;

/// Lazily loads and resolves the full, inherited configuration for a given context string.
///
/// This is the primary entry point for most handlers to get project configuration. It handles
/// special contexts like `.` (current directory) and `_` (ephemeral project), and delegates
/// to the `ConfigLoader` for the heavy lifting of parallel loading, caching, and merging.
///
/// # Arguments
/// * `context_str` - An optional string representing the project context (e.g., "my-app/api", ".").
///   Defaults to "." if `None`.
/// * `state_guard` - A mutable guard to the application state, required by the `ConfigLoader`
///   to update cache metadata if necessary.
pub fn resolve_config_for_context(
    context_str: Option<String>,
    state_guard: &mut AppStateGuard<'_>,
) -> Result<ResolvedConfig> {
    let final_context_str = context_str.unwrap_or_else(|| ".".to_string());

    if final_context_str == "_" {
        // Ephemeral context: load from current directory without relying on the index for the project itself.
        let mut loader = crate::core::config_loader::ConfigLoader::new(state_guard.index_mut());
        let cwd = std::env::current_dir()?;
        return loader
            .resolve_ephemeral(&cwd)
            .with_context(|| "Failed to resolve ephemeral project in the current directory");
    }

    // Original logic for registered projects
    let (uuid, _qualified_name) =
        context_resolver::resolve_context(&final_context_str, state_guard)?;
    let mut loader = crate::core::config_loader::ConfigLoader::new(state_guard.index_mut());
    loader.resolve(uuid)
}

/// Represents a calculated plan for a state-changing operation like `delete` or `unregister`.
///
/// This struct is the result of a "dry run" and contains all the information needed to
/// both inform the user of the impending changes and to execute them after confirmation.
#[derive(Debug, Default)]
pub struct OperationPlan {
    /// The list of project UUIDs that will be removed from the index.
    pub uuids_to_remove: Vec<Uuid>,
    /// For destructive operations (`delete`), the list of project root paths whose `.axes`
    /// directory will be purged. This is empty for non-destructive operations.
    pub paths_to_purge: Vec<PathBuf>,
    /// A list of informational warnings about actions that will be taken automatically,
    /// such as renaming a child project to avoid a name collision during reparenting.
    pub reparent_warnings: Vec<String>,
    /// A list of human-readable strings summarizing the operation, to be presented to the user.
    pub summary_lines: Vec<String>,
}

/// Prepares a comprehensive plan for a `delete` or `unregister` operation.
///
/// This function performs a "dry run," calculating all the effects of the operation
/// without modifying the application state. It handles recursive logic, reparenting,
/// and collision detection, producing a detailed `OperationPlan`.
///
/// # Arguments
/// * `state_guard` - A mutable guard to the application state, used for context resolution.
/// * `config` - The `ResolvedConfig` of the target project for the operation.
/// * `recursive` - If `true`, the plan will include all descendants of the target project.
/// * `reparent_to` - An optional context string for a new parent for the target's children.
/// * `is_destructive` - If `true`, the plan will include filesystem paths to purge (for `delete`).
pub fn prepare_operation_plan(
    state_guard: &mut AppStateGuard<'_>,
    config: &ResolvedConfig,
    recursive: bool,
    reparent_to: Option<String>,
    is_destructive: bool, // `true` for delete, `false` for unregister
) -> Result<OperationPlan> {
    let mut plan = OperationPlan::default();

    let new_parent_uuid = reparent_to
        .as_ref()
        .map(|ctx| context_resolver::resolve_context(ctx, state_guard))
        .transpose()?
        .map(|(uuid, _)| uuid);

    if recursive {
        if reparent_to.is_some() {
            return Err(anyhow!(t!("plan.error.recursive_and_reparent")));
        }
        plan.uuids_to_remove.push(config.uuid);
        plan.uuids_to_remove
            .extend(index_manager::get_all_descendants(
                state_guard.index(),
                config.uuid,
            ));

        let summary_line = if is_destructive {
            format!(
                t!("plan.summary.delete_recursive"),
                name = config.qualified_name
            )
        } else {
            format!(
                t!("plan.summary.unregister_recursive"),
                name = config.qualified_name
            )
        };
        plan.summary_lines.push(summary_line);
    } else {
        plan.uuids_to_remove.push(config.uuid);
        plan.summary_lines.push(format!(
            t!("plan.summary.unregister_single"),
            name = config.qualified_name
        ));

        let final_parent_uuid = new_parent_uuid.unwrap_or(index_manager::GLOBAL_PROJECT_UUID);
        let final_parent_entry = state_guard.index().projects.get(&final_parent_uuid).expect(
            "Parent UUID is guaranteed to exist as it's either resolved or the global UUID",
        );

        plan.summary_lines.push(format!(
            t!("plan.summary.reparent_to"),
            name = final_parent_entry.name
        ));

        let (warnings, conflicts) =
            check_reparent_collisions(state_guard.index(), config.uuid, final_parent_uuid);
        if !conflicts.is_empty() {
            return Err(anyhow!(
                t!("plan.error.reparent_collision"),
                conflicts = conflicts.join("', '")
            ));
        }
        plan.reparent_warnings = warnings;
    }

    // This is the only part that differs between delete and unregister.
    if is_destructive {
        plan.paths_to_purge = plan
            .uuids_to_remove
            .iter()
            .filter_map(|uuid| {
                state_guard
                    .index()
                    .projects
                    .get(uuid)
                    .map(|e| e.path.clone())
            })
            .collect();
    }

    Ok(plan)
}

/// Checks for potential name collisions when reparenting children.
/// Returns a tuple of (`warnings_for_automatic_renames`, `hard_conflicts`).
fn check_reparent_collisions(
    index: &GlobalIndex,
    old_parent_uuid: Uuid,
    new_parent_uuid: Uuid,
) -> (Vec<String>, Vec<String>) {
    let mut warnings = Vec::new();
    let mut conflicts = Vec::new();

    let old_parent_name = &index
        .projects
        .get(&old_parent_uuid)
        .expect("Old parent UUID must exist in the index for this function to be called")
        .name;
    let children_to_move: Vec<_> = index
        .projects
        .values()
        .filter(|e| e.parent == Some(old_parent_uuid))
        .collect();

    if children_to_move.is_empty() {
        return (warnings, conflicts);
    }

    let new_sibling_names: HashSet<_> = index
        .projects
        .values()
        .filter(|e| e.parent == Some(new_parent_uuid))
        .map(|e| e.name.clone())
        .collect();

    for child in children_to_move {
        if new_sibling_names.contains(&child.name) {
            // Initial collision detected
            let suggested_name = format!("{}_{}", old_parent_name, child.name);
            if new_sibling_names.contains(&suggested_name) {
                // Automatic rename also conflicts. This is a hard conflict.
                conflicts.push(format!(
                    "'{}' (also conflicts as '{}')",
                    child.name, suggested_name
                ));
            } else {
                // Automatic rename is possible. This is a warning.
                warnings.push(format!(
                    "Child '{}' will be renamed to '{}' to avoid collision.",
                    child.name, suggested_name
                ));
            }
        }
    }

    (warnings, conflicts)
}

/// Presents an interactive, multi-modal UI for selecting a parent project.
///
/// This function offers the user multiple ways to choose a project:
/// 1.  Entering a context path directly.
/// 2.  Visually browsing the project tree.
/// 3.  Choosing the "global" project as the parent.
///     It ensures a consistent and user-friendly experience for any command that needs to
///     ask the user for a project context (e.g., `init`, `register`).
///
/// # Arguments
/// * `state_guard` - A mutable guard to the application state, needed for context resolution
///   and browsing.
pub fn choose_parent_interactive(state_guard: &mut AppStateGuard<'_>) -> Result<Uuid> {
    loop {
        let items = &[
            "Enter a context path (e.g., 'my-app/api', 'g!', '*')",
            "Browse projects visually",
            "Use 'global' as the parent (default)",
        ];

        let selection = Select::with_theme(&ColorfulTheme::default())
            .with_prompt("How would you like to select the parent project?")
            .items(items)
            .default(2) // Default to 'global'
            .interact()?;

        match selection {
            0 => {
                // Enter a context path
                if let Some(uuid) = select_parent_by_context(state_guard)? {
                    return Ok(uuid);
                }
                // If it returns None, the user cancelled, so we loop again.
            }
            1 => {
                // Browse projects visually
                return select_parent_by_browsing(state_guard.index());
            }
            2 => {
                // Use 'global'
                return Ok(index_manager::GLOBAL_PROJECT_UUID);
            }
            _ => unreachable!(),
        }
    }
}

/// Handles the "Enter context" workflow. Returns `Ok(Some(Uuid))` on success,
/// `Ok(None)` if the user cancels, and `Err` on I/O failure.
fn select_parent_by_context(state_guard: &mut AppStateGuard<'_>) -> Result<Option<Uuid>> {
    loop {
        let input: String = Input::with_theme(&ColorfulTheme::default())
            .with_prompt("Enter context path (leave empty to go back)")
            .interact_text()?;

        if input.is_empty() {
            return Ok(None); // User wants to go back to the main menu
        }

        match context_resolver::resolve_context(&input, state_guard) {
            Ok((uuid, qualified_name)) => {
                let prompt = format!("Resolved to '{}'. Use this as the parent?", qualified_name);
                if Confirm::with_theme(&ColorfulTheme::default())
                    .with_prompt(prompt)
                    .default(true)
                    .interact()?
                {
                    return Ok(Some(uuid));
                };

                // If user says no, the loop continues to ask for another context.
            }
            Err(e) => {
                // Inform the user of the error and let them try again.
                println!("Error: {}", e);
            }
        }
    }
}

/// Handles the visual browsing workflow.
fn select_parent_by_browsing(index: &GlobalIndex) -> Result<Uuid> {
    // Pre-build a map of parent -> children to avoid iterating the whole projects map in every loop.
    let mut children_map: HashMap<Option<Uuid>, Vec<(Uuid, &IndexEntry)>> = HashMap::new();
    for (uuid, entry) in &index.projects {
        children_map
            .entry(entry.parent)
            .or_default()
            .push((*uuid, entry));
    }
    // Sort all child lists once for a consistent UI.
    for children in children_map.values_mut() {
        children.sort_by_key(|(_, entry)| &entry.name);
    }

    let mut current_uuid = index_manager::GLOBAL_PROJECT_UUID;

    loop {
        let current_entry = index.projects.get(&current_uuid).ok_or_else(|| {
            anyhow!(
                "Browser state invalid: project with UUID {} not found.",
                current_uuid
            )
        })?;

        let children = children_map
            .get(&Some(current_uuid))
            .map_or(&[][..], |v| &v[..]);

        let mut items = Vec::new();
        items.push(format!("✅ [ Select '{}' as parent ]", current_entry.name));
        if current_uuid != index_manager::GLOBAL_PROJECT_UUID {
            items.push("⬆️  [ Go up to parent project ]".to_string());
        }

        enum BrowserAction {
            Select,
            GoUp,
            GoToChild(Uuid),
        }
        let mut action_map = vec![BrowserAction::Select];
        if current_uuid != index_manager::GLOBAL_PROJECT_UUID {
            action_map.push(BrowserAction::GoUp);
        }

        for (child_uuid, child_entry) in children {
            items.push(format!("  └─ {}", child_entry.name));
            action_map.push(BrowserAction::GoToChild(*child_uuid));
        }

        let prompt = format!("Browsing children of '{}'", current_entry.name);
        let selection_idx = Select::with_theme(&ColorfulTheme::default())
            .with_prompt(&prompt)
            .items(&items)
            .default(0)
            .interact()?;

        match action_map.get(selection_idx) {
            Some(BrowserAction::Select) => return Ok(current_uuid),
            Some(BrowserAction::GoUp) => {
                current_uuid = current_entry
                    .parent
                    .unwrap_or(index_manager::GLOBAL_PROJECT_UUID);
            }
            Some(BrowserAction::GoToChild(child_uuid)) => {
                current_uuid = *child_uuid;
            }
            None => { /* Should not happen */ }
        }
    }
}

/// Validates a project name against axes' naming rules.
/// Returns a sanitized `String` on success.
/// Prints non-blocking warnings for stylistic issues.
/// Returns a blocking `Err` for critical issues.
pub fn validate_project_name(raw_name: &str) -> Result<String> {
    let name = raw_name.trim();

    // --- Strict, Blocking Errors ---
    if name.is_empty() {
        return Err(anyhow!(t!("validation.error.empty_name")));
    }
    if name.contains(char::is_whitespace) {
        return Err(anyhow!(t!("validation.error.contains_whitespace")));
    }
    if name.contains('/') || name.contains('\\') {
        return Err(anyhow!(t!("validation.error.invalid_chars")));
    }
    let reserved_nav_names = ["..", "*", "**", "_"];
    if reserved_nav_names.contains(&name.to_lowercase().as_str()) {
        return Err(anyhow!(t!("validation.error.reserved_name"), name = name));
    }

    // --- Soft, Non-Blocking Warnings ---
    let first_char = name
        .chars()
        .next()
        .expect("String is guaranteed not to be empty here");
    let last_char = name
        .chars()
        .last()
        .expect("String is guaranteed not to be empty here");

    if !first_char.is_alphanumeric() {
        println!(
            "{}",
            format!(
                "Warning: The name '{}' starts with a non-alphanumeric character. This is allowed but may cause confusion.",
                name
            )
            .yellow()
        );
    }
    if !last_char.is_alphanumeric() && last_char != '_' {
        println!(
            "{}",
            format!(
                "Warning: The name '{}' ends with a special character. This is allowed but not recommended.",
                name
            )
            .yellow()
        );
    }

    Ok(name.to_string())
}

/// Collects all unique `ParameterDef`s from every platform-specific command in a `Task`.
///
/// This utility traverses the entire AST of a task to build a complete contract of all
/// possible parameters it accepts, which is essential for the `ArgResolver`.
///
/// # Arguments
/// * `task` - An `Arc<Task>` from which to collect parameter definitions.
pub fn collect_parameter_defs_from_task(task: &Arc<Task>) -> Vec<ParameterDef> {
    task.commands
        .iter()
        // Iterate over each PlatformExecution block
        .flat_map(|plat_exec| {
            // Create an array of the Option<T>s themselves, then call iter().flatten().
            // This turns an iterator of Option<T> into an iterator of T.
            [
                plat_exec.default.as_ref(),
                plat_exec.windows.as_ref(),
                plat_exec.linux.as_ref(),
                plat_exec.macos.as_ref(),
            ]
            .into_iter()
            .flatten()
        })
        .flat_map(|cmd_exec| match &cmd_exec.action {
            CommandAction::Execute(t) | CommandAction::Print(t) => t.clone(),
        })
        .filter_map(|component| match component {
            TemplateComponent::Parameter(def) => Some(def),
            _ => None,
        })
        // Use a fold with a HashSet to collect only unique definitions.
        .fold(
            (Vec::new(), std::collections::HashSet::new()),
            |(mut acc_vec, mut acc_set), def| {
                if acc_set.insert(def.clone()) {
                    acc_vec.push(def);
                }
                (acc_vec, acc_set)
            },
        )
        .0 // Return only the vector of unique definitions.
}

/// Builds an argument resolver for a given task and CLI parameters.
/// This encapsulates the logic for collecting definitions and checking for the generic `<params>` token.
pub fn build_resolver_for_task<'a>(
    task: &Arc<Task>,
    params: &'a [String],
) -> Result<ArgResolver<'a>> {
    let all_definitions = collect_parameter_defs_from_task(task);

    let has_generic_params = task.commands.iter().any(|plat_exec| {
        [
            plat_exec.default.as_ref(),
            plat_exec.windows.as_ref(),
            plat_exec.linux.as_ref(),
            plat_exec.macos.as_ref(),
        ]
        .into_iter()
        .flatten()
        .any(|cmd_exec| {
            let template = match &cmd_exec.action {
                CommandAction::Execute(t) | CommandAction::Print(t) => t,
            };
            template
                .iter()
                .any(|c| matches!(c, TemplateComponent::GenericParams { .. }))
        })
    });

    ArgResolver::new(&all_definitions, params, has_generic_params)
}

===== cli\handlers\debug_cache.rs =====
//! # Handler for the `cache` command
//!
//! This module provides the logic for the internal `axes cache` command. It is primarily
//! a debugging tool intended for developers of `axes` to inspect and manage the binary
//! configuration cache for projects.
//!
//! ## Features
//!
//! - **Inspect**: Deserializes a project's cached configuration (`.bin` file) and prints
//!   it to the console as human-readable JSON. This is useful for verifying the output
//!   of the configuration compiler.
//! - **Clear**: Deletes a project's cached configuration file from the filesystem and also
//!   removes the `config_hash` and `cache_dir` metadata from the project's entry in the
//!   global index. This forces a full recompilation of the project's configuration on the
//!   next run.

use crate::{
    models::{CachedProjectConfig, GlobalIndex},
    state::AppStateGuard,
};
use anyhow::{Context, Result, anyhow};
use clap::{Parser, Subcommand};
use colored::*;
use std::fs;

// --- Command Argument Parsing ---

/// (Internal) Inspect or clear the configuration cache for a project.
#[derive(Parser, Debug)]
#[command(no_binary_name = true, hide = true)]
struct CacheArgs {
    /// The project context to inspect the cache for.
    context: Option<String>,
    #[command(subcommand)]
    command: CacheSubcommand,
}

#[derive(Subcommand, Debug)]
enum CacheSubcommand {
    /// Deserializes and prints the content of a project's config cache.
    Inspect,
    /// Deletes the cache file for a project and clears its hash from the index,
    /// forcing a full regeneration on the next run.
    Clear,
}

// --- Main Handler ---

/// The main handler for the `cache` command.
///
/// It parses the subcommand (`inspect` or `clear`) and the target project context,
/// then dispatches to the appropriate logic function.
///
/// # Arguments
/// * `context` - The project context, if provided by the dispatcher's universal grammar.
/// * `args` - The command-specific arguments (e.g., `<context> inspect`).
/// * `state_guard` - A mutable guard to the application state.
pub fn handle(
    context: Option<String>,
    args: Vec<String>,
    state_guard: &mut AppStateGuard<'_>,
) -> Result<()> {
    let cache_args = CacheArgs::try_parse_from(&args)?;

    let final_context = cache_args
        .context
        .or(context)
        .ok_or_else(|| anyhow!("The '_cache' command requires an explicit project context."))?;
    let (uuid, qualified_name) =
        crate::core::context_resolver::resolve_context(&final_context, state_guard)?;
    match cache_args.command {
        CacheSubcommand::Inspect => inspect_cache(uuid, &qualified_name, state_guard.index()),
        CacheSubcommand::Clear => clear_cache(uuid, &qualified_name, state_guard.index_mut()),
    }
}

// --- Subcommand Logic ---

/// Handles the logic for inspecting a project's cache file.
///
/// It resolves the path to the cache file using the metadata from the `GlobalIndex`,
/// reads the binary data, decompresses it, deserializes it using `bincode`, and then
/// pretty-prints it as JSON.
///
/// # Arguments
/// * `uuid` - The UUID of the project whose cache is to be inspected.
/// * `name` - The qualified name of the project, for display purposes.
/// * `index` - An immutable reference to the `GlobalIndex`.
fn inspect_cache(uuid: uuid::Uuid, name: &str, index: &GlobalIndex) -> Result<()> {
    println!(
        "\nInspecting cache for project '{}' ({})",
        name.cyan(),
        uuid
    );

    let project = index
        .projects
        .get(&uuid)
        .expect("UUID should exist as it was just resolved by the context resolver");

    // Use a single `if let` to check for both required fields.
    if let (Some(cache_dir), Some(cache_hash)) = (&project.cache_dir, &project.config_hash) {
        let cache_path = cache_dir.join(cache_hash);
        println!(
            "  {:<15} {}",
            "Index Cache Dir:".blue(),
            cache_dir.display()
        );
        println!("  {:<15} {}", "Index Hash:".blue(), cache_hash);
        println!("  {:<15} {}", "Resolved Path:".blue(), cache_path.display());

        match fs::read(&cache_path) {
            Ok(bytes) => {
                if bytes.is_empty() {
                    println!("{}", "\nStatus: Cache file is empty.".yellow());
                    return Ok(());
                }

                // CLARITY: Wrap deserialization in a context block.
                let cache_data: CachedProjectConfig = bincode::serde::decode_from_slice(&bytes, bincode::config::standard())
                    .map(|(data, _)| data) // Discard the size
                    .context("Failed to deserialize cache file. It might be corrupt or from an incompatible version.")?;

                let json_output = serde_json::to_string_pretty(&cache_data)
                    .context("Failed to serialize cache data to JSON for display.")?;

                println!("\n--- {} ---", "Cache Content (as JSON)".green());
                println!("{}", json_output);
            }
            Err(e) if e.kind() == std::io::ErrorKind::NotFound => {
                println!(
                    "{}",
                    "\nStatus: Cache file does not exist at the resolved path.".red()
                );
            }
            Err(e) => {
                // Handle other potential I/O errors (e.g., permissions).
                return Err(e).with_context(|| {
                    format!("Failed to read cache file at {}", cache_path.display())
                });
            }
        }
    } else {
        // ROBUSTNESS: Provide more detailed information about what's missing.
        println!(
            "{}",
            "\nStatus: Project has incomplete cache information in the index.".yellow()
        );
        if project.cache_dir.is_none() {
            println!("  - Missing: `cache_dir`");
        }
        if project.config_hash.is_none() {
            println!("  - Missing: `config_hash` (project has likely never been cached)");
        }
    }

    Ok(())
}

/// Handles the logic for clearing a project's cache.
///
/// This is a mutable operation that performs two actions:
/// 1.  It attempts to delete the binary cache file from the filesystem.
/// 2.  It removes the `config_hash` and `cache_dir` fields from the project's
///     `IndexEntry` in the `GlobalIndex`.
///
/// # Arguments
/// * `uuid` - The UUID of the project whose cache is to be cleared.
/// * `name` - The qualified name of the project, for display purposes.
/// * `index` - A mutable reference to the `GlobalIndex`.
fn clear_cache(uuid: uuid::Uuid, name: &str, index: &mut GlobalIndex) -> Result<()> {
    println!("\nClearing cache for project '{}' ({})", name.cyan(), uuid);

    let project = index
        .projects
        .get_mut(&uuid)
        .expect("UUID should exist as it was just resolved by the context resolver");

    let mut actions_performed = false;

    // --- File System Cleanup ---
    if let (Some(cache_dir), Some(cache_hash)) = (&project.cache_dir, &project.config_hash) {
        let cache_path = cache_dir.join(cache_hash);
        log::debug!(
            "Attempting to delete cache file at: {}",
            cache_path.display()
        );

        match fs::remove_file(&cache_path) {
            Ok(()) => {
                println!(
                    "  {:<15} {}",
                    "File System:".blue(),
                    "Cache file deleted.".green()
                );
                actions_performed = true;
            }
            Err(e) if e.kind() == std::io::ErrorKind::NotFound => {
                println!(
                    "  {:<15} {}",
                    "File System:".blue(),
                    "Cache file not found, nothing to delete.".yellow()
                );
            }
            Err(e) => {
                return Err(e).with_context(|| {
                    format!("Failed to delete cache file at {}", cache_path.display())
                });
            }
        }
    } else {
        println!(
            "  {:<15} {}",
            "File System:".blue(),
            "No cache path in index, skipping file deletion.".yellow()
        );
    }

    // --- Index State Cleanup ---
    // Use `take()` for a more idiomatic way to consume and clear Option fields.
    if project.config_hash.take().is_some() | project.cache_dir.take().is_some() {
        println!(
            "  {:<15} {}",
            "Index State:".blue(),
            "Cache hash and directory cleared.".green()
        );
        actions_performed = true;
    }

    if !actions_performed {
        println!(
            "\n{}",
            "No cache information was found for this project. Nothing to do.".yellow()
        );
    } else {
        println!(
            "\n{}",
            "Successfully cleared cache. It will be regenerated on the next run.".bold()
        );
    }

    Ok(())
}

===== cli\handlers\delete.rs =====
//! # Handler for the `delete` command
//!
//! This module provides the logic for the `axes delete` command, which is a destructive
//! operation that removes a project from the global index and also deletes its associated
//! `.axes` directory from the filesystem.
//!
//! ## Core Logic
//!
//! 1.  **Argument Parsing**: It parses command-specific arguments like `--recursive` and
//!     `--reparent-to` using a `clap` struct.
//! 2.  **Planning**: It uses the shared `commons::prepare_operation_plan` utility to perform
//!     a "dry run" of the deletion. This plan calculates which projects to unregister, which
//!     directories to purge, and what the consequences of reparenting will be.
//! 3.  **Confirmation**: The detailed, destructive plan is presented to the user. A stringent
//!     confirmation step (requiring the user to type the project's name for recursive deletes)
//!     ensures that the operation is intentional.
//! 4.  **Execution**: If confirmed, the plan is executed in two phases:
//!     a. **Filesystem Purge**: The `.axes` directories of all targeted projects are deleted.
//!     This is done first to ensure that if this part fails, the index remains consistent.
//!     b. **Index Mutation**: The projects are removed from the `GlobalIndex`, and any
//!     necessary reparenting is performed.

use anyhow::{Context, Result, anyhow};
use clap::Parser;
use colored::*;
use dialoguer::{Confirm, Input, theme::ColorfulTheme};
use std::fs;

use crate::{
    cli::handlers::commons,
    core::{context_resolver, index_manager},
    state::AppStateGuard,
};

#[derive(Parser, Debug, Default)]
#[command(
    no_binary_name = true,
    about = "Deletes a project from the index and removes its '.axes' directory."
)]
struct DeleteArgs {
    /// Deletes the project and ALL its descendants recursively. This is highly destructive.
    #[arg(long)]
    recursive: bool,

    /// Instead of deleting direct children, reparents them to a new project.
    #[arg(long, conflicts_with = "recursive")]
    reparent_to: Option<String>,
}

/// The main handler for the `delete` command.
///
/// Orchestrates the planning, confirmation, and execution of a project deletion,
/// handling both single-project and recursive deletions.
///
/// # Arguments
/// * `context` - The context string for the project to be deleted, provided by the dispatcher.
/// * `args` - The command-specific arguments (e.g., `--recursive`).
/// * `state_guard` - A mutable guard to the application state.
pub fn handle(
    context: Option<String>,
    args: Vec<String>,
    state_guard: &mut AppStateGuard<'_>,
) -> Result<()> {
    // 1. Parse arguments and resolve target project.
    let delete_args = DeleteArgs::try_parse_from(&args)?;
    let context_str =
        context.ok_or_else(|| anyhow!(t!("error.context_required"), command = "delete"))?;
    let config = commons::resolve_config_for_context(Some(context_str), state_guard)?;

    if config.uuid == index_manager::GLOBAL_PROJECT_UUID {
        return Err(anyhow!(t!("delete.error.cannot_delete_global")));
    }

    // 2. [REFACTORED] Prepare the operational plan using the unified function.
    let plan = commons::prepare_operation_plan(
        state_guard,
        &config,
        delete_args.recursive,
        delete_args.reparent_to.clone(),
        true, // is_destructive = true
    )?;

    // 3. Present the destructive plan to the user for confirmation.
    println!("\n{}", t!("delete.warning.destructive_header").red().bold());
    for line in &plan.summary_lines {
        println!("  - {}", line);
    }

    if !plan.paths_to_purge.is_empty() {
        println!("\n{}", t!("delete.info.files_to_be_deleted").yellow());
        for path in &plan.paths_to_purge {
            // We only delete the .axes directory for safety, not the whole project.
            println!("    • {}", path.join(crate::constants::AXES_DIR).display());
        }
    }

    // 4. Get confirmation.
    if !confirm_delete_operation(&config, delete_args.recursive)? {
        return Ok(());
    }

    // 5. EXECUTE PLAN - DESTRUCTIVE PART FIRST (FILE SYSTEM)
    log::info!(
        "Executing deletion plan for project '{}' ({})",
        config.qualified_name,
        config.uuid
    );
    let mut purged_count = 0;
    for project_root in &plan.paths_to_purge {
        let axes_dir = project_root.join(crate::constants::AXES_DIR);
        if axes_dir.exists() {
            log::debug!("Purging directory: {}", axes_dir.display());
            fs::remove_dir_all(&axes_dir)
                .with_context(|| format!("Failed to delete directory: {}", axes_dir.display()))?;
            purged_count += 1;
        } else {
            log::trace!("Skipping non-existent directory: {}", axes_dir.display());
        }
    }

    // 6. EXECUTE PLAN - INDEX MUTATION (IN-MEMORY)
    if !delete_args.recursive {
        let new_parent_uuid = match delete_args.reparent_to {
            Some(ctx) => context_resolver::resolve_context(&ctx, state_guard)?.0,
            None => index_manager::GLOBAL_PROJECT_UUID,
        };
        // This function now returns warnings which we will display at the end.
        let reparent_op_warnings = index_manager::reparent_children(
            state_guard.index_mut(),
            config.uuid,
            new_parent_uuid,
        )?;

        // Combine warnings from planning and execution.
        let all_warnings = [&plan.reparent_warnings[..], &reparent_op_warnings[..]].concat();

        let removed_count =
            index_manager::remove_from_index(state_guard.index_mut(), &plan.uuids_to_remove);

        // 7. Final feedback for non-recursive delete.
        println!(
            "\n{} {}",
            t!("common.success"),
            format_args!(
                t!("delete.success.header"),
                purged = purged_count,
                unregistered = removed_count
            )
        );
        for warning in all_warnings {
            println!("  - {}", warning.yellow());
        }
    } else {
        // Feedback for recursive delete
        let removed_count =
            index_manager::remove_from_index(state_guard.index_mut(), &plan.uuids_to_remove);
        println!(
            "\n{} {}",
            t!("common.success"),
            format_args!(
                t!("delete.success.header_recursive"),
                purged = purged_count,
                unregistered = removed_count
            )
        );
    }

    Ok(())
}

/// Encapsulates the user confirmation logic for the delete operation.
///
/// For a standard deletion, it presents a simple "Are you sure?" prompt.
/// For a highly destructive `--recursive` deletion, it requires the user to manually
/// type the name of the project being deleted as an extra safety measure.
///
/// # Arguments
/// * `config` - The resolved configuration of the project being deleted.
/// * `is_recursive` - A boolean indicating if the operation is recursive.
///
/// # Returns
/// `Ok(true)` if the user confirms the operation, `Ok(false)` if they cancel.
fn confirm_delete_operation(
    config: &crate::models::ResolvedConfig,
    is_recursive: bool,
) -> Result<bool> {
    if is_recursive {
        // Extra safety for recursive delete: user must type the project's simple name.
        let project_name = config.qualified_name.split('/').next_back().unwrap_or("");
        if project_name.is_empty() {
            // This is a safeguard against a panic if qualified_name is weird.
            return Err(anyhow!(
                "Could not determine project name for recursive delete confirmation."
            ));
        }
        let prompt = format!(t!("delete.prompt.recursive_confirm"), name = project_name);

        let confirmation: String = Input::with_theme(&ColorfulTheme::default())
            .with_prompt(prompt)
            .interact_text()?;

        if confirmation.trim() != project_name {
            println!("\n{}", t!("common.info.operation_cancelled"));
            return Ok(false);
        }
    } else {
        // Standard confirmation for non-recursive delete.
        if !Confirm::with_theme(&ColorfulTheme::default())
            .with_prompt(t!("delete.prompt.are_you_sure"))
            .default(false)
            .interact()?
        {
            println!("\n{}", t!("common.info.operation_cancelled"));
            return Ok(false);
        }
    }
    Ok(true)
}

===== cli\handlers\info.rs =====
//! # Handler for the `info` command
//!
//! This module provides the logic for the `axes info` command, which displays a comprehensive,
//! human-readable summary of a project's fully resolved configuration.
//!
//! ## Core Logic
//!
//! 1.  **Configuration Resolution**: It uses `commons::resolve_config_for_context` to obtain
//!     the `ResolvedConfig` for the target project. This is a potentially mutable operation,
//!     as it can trigger cache updates in the `GlobalIndex`.
//! 2.  **Sectioned Display**: The output is broken down into logical sections (Metadata, Options,
//!     Scripts, Variables, Environment), each handled by a dedicated `print_*` function.
//! 3.  **Inheritance Indication**: For inherited items like scripts and variables, it uses the
//!     `find_task_source` helper to determine which project in the hierarchy originally defined
//!     the item, adding a `[inherited from ...]` label to the output for clarity.
//! 4.  **Data Rendering**: It includes logic to render complex data structures, like variable
//!     values, into a representative string format for display, respecting platform-specific
//!     definitions.

use crate::{
    cli::handlers::commons,
    constants::{AXES_DIR, PROJECT_CONFIG_FILENAME},
    core::index_manager,
    models::{
        CachedVar, CommandAction, GlobalIndex, PlatformExecution, ResolvedConfig, RunSpec,
        TemplateComponent,
    },
    state::AppStateGuard,
};
use anyhow::Result;
use clap::Parser;
use colored::*;
use std::sync::Arc;

// --- Command Argument Parsing ---

#[derive(Parser, Debug, Default)]
#[command(
    no_binary_name = true,
    about = "Displays detailed information about a project's configuration."
)]
struct InfoArgs {
    /// The project context to display information about. Defaults to the current project.
    context: Option<String>,
}

// --- Main Handler ---

/// The main handler for the `info` command.
///
/// It resolves the full configuration for a project and then calls a series of
/// helper functions to print each section of the resolved data in a formatted way.
///
/// # Arguments
/// * `dispatcher_context` - The context from the dispatcher (e.g., the project part of `axes my-app info`).
/// * `args` - Command-specific arguments, which may include an overriding context.
/// * `state_guard` - A mutable guard to the application state, needed for configuration resolution.
pub fn handle(
    dispatcher_context: Option<String>,
    args: Vec<String>,
    state_guard: &mut AppStateGuard<'_>,
) -> Result<()> {
    // 1. Parse all handler-specific arguments.
    let info_args = InfoArgs::try_parse_from(&args)?;

    // 2. Determine the definitive context with clear priority: cli arg > dispatcher context > cwd.
    let final_context = info_args
        .context
        .or(dispatcher_context)
        .unwrap_or_else(|| ".".to_string());

    // 3. Lazily resolve the full configuration for the context.
    let config = commons::resolve_config_for_context(Some(final_context), state_guard)?;
    let index = state_guard.index();

    // 4. Print each section of the configuration.
    print_metadata(&config, index)?;
    print_options(&config)?;
    print_scripts_map(&config, index)?;
    print_vars_map(&config, index)?;
    print_env(&config)?;

    println!("\n---------------------------------");
    Ok(())
}

// --- Display Functions for Each Section ---

/// Prints the core metadata of the project, including its inheritance chain.
fn print_metadata(config: &ResolvedConfig, index: &GlobalIndex) -> Result<()> {
    let config_file_path = config
        .project_root
        .join(AXES_DIR)
        .join(PROJECT_CONFIG_FILENAME);

    println!(
        "\n--- {} '{}' ---",
        t!("info.header"),
        config.qualified_name.yellow()
    );

    println!("  {:<15} {}", t!("info.label.uuid").blue(), config.uuid);
    println!(
        "  {:<15} {}",
        t!("info.label.root_path").blue(),
        config.project_root.display()
    );
    println!(
        "  {:<15} {}",
        t!("info.label.config_file").blue(),
        config_file_path.display()
    );

    // Display the full inheritance hierarchy for clarity.
    let hierarchy_names: Vec<String> = config
        .hierarchy
        .iter()
        .map(|uuid| {
            index_manager::build_qualified_name(*uuid, index)
                .unwrap_or_else(|| format!("<unknown: {}>", uuid))
        })
        .collect();
    println!(
        "  {:<15} {}",
        t!("info.label.inheritance").blue(),
        hierarchy_names.join(" -> ").dimmed()
    );

    if let Some(v) = config.get_version()? {
        println!("  {:<15} {}", t!("info.label.version").blue(), v);
    }
    if let Some(d) = config.get_description()? {
        println!("  {:<15} {}", t!("info.label.description").blue(), d);
    }
    Ok(())
}

/// Prints the resolved `[options]` section.
fn print_options(config: &ResolvedConfig) -> Result<()> {
    let options = config.get_options()?;
    let mut entries = Vec::new();

    if let Some(shell) = &options.shell {
        entries.push(format!("{}: '{}'", "shell".cyan(), shell));
    }
    if let Some(prompt) = &options.prompt {
        entries.push(format!("{}: '{}'", "prompt".cyan(), prompt));
    }
    if let Some(cache_dir) = &options.cache_dir {
        entries.push(format!("{}: '{}'", "cache_dir".cyan(), cache_dir));
    }
    if let Some(default_open) = &options.open_with.default {
        entries.push(format!(
            "{}: '{}'",
            "open_with.default".cyan(),
            default_open
        ));
    }

    if entries.is_empty() {
        return Ok(());
    }

    println!("\n  {}:", t!("info.label.options").blue());
    for entry in entries {
        println!("    - {}", entry);
    }
    Ok(())
}

/// Prints a map of available scripts, indicating their source.
fn print_scripts_map(config: &ResolvedConfig, index: &GlobalIndex) -> Result<()> {
    let scripts = config.get_all_scripts()?;
    if scripts.is_empty() {
        println!("\n  {}", t!("info.label.no_scripts").dimmed());
        return Ok(());
    }

    println!("\n  {}:", t!("info.label.available_scripts").blue());
    let mut sorted_keys: Vec<_> = scripts.keys().collect();
    sorted_keys.sort();

    for script_name in sorted_keys {
        let task = scripts
            .get(script_name)
            .expect("Script name should exist as we are iterating over map keys");
        print!("    - {}", script_name.cyan());

        let source_project_name = find_task_source("scripts", script_name, config, index)?;
        if source_project_name != config.qualified_name {
            print!(
                " {}",
                format!(
                    "[{}]",
                    format_args!(t!("common.label.inherited"), from = source_project_name)
                )
                .dimmed()
            );
        }

        if let Some(d) = &task.desc
            && !d.trim().is_empty()
        {
            print!(": {}", d.dimmed());
        }
        println!();
    }
    Ok(())
}

/// Prints a map of available variables, indicating their source and description or value.
fn print_vars_map(config: &ResolvedConfig, index: &GlobalIndex) -> Result<()> {
    let vars = config.get_all_vars()?;
    if vars.is_empty() {
        return Ok(());
    }

    println!("\n  {}:", t!("info.label.vars").blue());
    let mut sorted_keys: Vec<_> = vars.keys().collect();
    sorted_keys.sort();

    for var_name in sorted_keys {
        let var = vars
            .get(var_name)
            .expect("Variable name should exist as we are iterating over map keys");
        print!("    - {}", var_name.cyan());

        let source_project_name = find_task_source("vars", var_name, config, index)?;
        if source_project_name != config.qualified_name {
            print!(
                " {}",
                format!(
                    "[{}]",
                    format_args!(t!("common.label.inherited"), from = source_project_name)
                )
                .dimmed()
            );
        }

        // --- CORRECTED LOGIC ---
        // Priority: 1. Description, 2. Rendered value.
        if let Some(d) = &var.desc {
            if !d.trim().is_empty() {
                print!(": {}", d.dimmed());
            } else {
                // Description is present but empty, show the value instead.
                let display_val = render_var_to_string(var, config);
                print!(" = {}", format_args!("\"{}\"", display_val));
            }
        } else {
            // No description, show the value.
            let display_val = render_var_to_string(var, config);
            print!(" = {}", format_args!("\"{}\"", display_val));
        }

        println!();
    }
    Ok(())
}

/// Prints all merged environment variables.
fn print_env(config: &ResolvedConfig) -> Result<()> {
    let env = config.get_env()?;
    if env.is_empty() {
        return Ok(());
    }

    println!("\n  {}:", t!("info.label.env").blue());
    let mut sorted_keys: Vec<_> = env.keys().collect();
    sorted_keys.sort();

    for k in sorted_keys {
        if let Some(val) = env.get(k) {
            println!("    - {} = {}", k.cyan(), format_args!("\"{}\"", val));
        }
    }
    Ok(())
}

// --- Helper Functions ---

/// Traverses the project's inheritance hierarchy to find which ancestor project
/// a specific script or variable was originally defined in.
///
/// # Arguments
/// * `key` - The type of item to look for ("scripts" or "vars").
/// * `task_name` - The name of the script or variable.
/// * `config` - The resolved configuration of the starting project.
/// * `index` - An immutable reference to the global index.
///
/// # Returns
/// The qualified name of the project where the item was found.
pub(crate) fn find_task_source(
    key: &str,
    task_name: &str,
    config: &ResolvedConfig,
    index: &GlobalIndex,
) -> Result<String> {
    for uuid in config.hierarchy.iter() {
        let layer = config.get_layer(*uuid)?;
        let task_exists = if key == "scripts" {
            layer.scripts.contains_key(task_name)
        } else {
            layer.vars.contains_key(task_name)
        };

        if task_exists {
            return Ok(index_manager::build_qualified_name(*uuid, index)
                .unwrap_or_else(|| format!("<unknown: {}>", uuid)));
        }
    }
    Ok(config.qualified_name.clone()) // Fallback to current project name
}

/// Selects the appropriate command template for the current platform from a `PlatformExecution` block.
fn get_template_for_platform<'a>(
    plat_exec: &'a PlatformExecution,
    config: &'a ResolvedConfig,
) -> Option<&'a [TemplateComponent]> {
    config
        .select_platform_exec(plat_exec)
        .map(|cmd_exec| match &cmd_exec.action {
            CommandAction::Execute(t) | CommandAction::Print(t) => t.as_slice(),
        })
}

/// Renders a template AST back into a representative string for display.
fn render_template_to_string(template: &[TemplateComponent]) -> String {
    template.iter().map(render_component_to_string).collect()
}

/// A helper that renders an abstract `TemplateComponent` into its original string representation
/// (e.g., `<params::0>`, `<#red>`). This is used for display purposes in `info` and `start --dry-run`.
fn render_component_to_string(component: &TemplateComponent) -> String {
    match component {
        TemplateComponent::Literal(s) => s.clone(),
        TemplateComponent::Parameter(p) => p.original_token.clone(),
        TemplateComponent::GenericParams { literal } => {
            if *literal {
                "<params(literal)>".to_string()
            } else {
                "<params>".to_string()
            }
        }
        TemplateComponent::Color(color) => format!("<#{:?}>", color).to_lowercase(),
        TemplateComponent::Run(spec) => match spec {
            RunSpec::Literal(cmd) => format!("<run('{}')>", cmd),
        },
        TemplateComponent::Path => "<path>".to_string(),
        TemplateComponent::Name => "<name>".to_string(),
        TemplateComponent::Uuid => "<uuid>".to_string(),
        TemplateComponent::Version => "<version>".to_string(),
        TemplateComponent::Script(s) => format!("<scripts::{}>", s),
        TemplateComponent::Var(v) => format!("<vars::{}>", v),
    }
}

/// A helper that renders the value of a `CachedVar` to a string for display.
/// It correctly selects the value for the current platform before rendering.
fn render_var_to_string(var: &Arc<CachedVar>, config: &ResolvedConfig) -> String {
    get_template_for_platform(&var.value, config)
        .map(render_template_to_string)
        .unwrap_or_else(|| "<no value for this platform>".dimmed().to_string())
}

===== cli\handlers\init.rs =====
//! # Handler for the `init` command
//!
//! This module provides the logic for the `axes init` (or `axes new`) command, which creates
//! a new `axes` project in the current directory. It handles both interactive setup and
//! non-interactive (automated) project creation via command-line flags.
//!
//! ## Core Logic
//!
//! 1.  **Argument Parsing**: Parses a rich set of arguments (`--parent`, `--version`, `--env`, etc.)
//!     to allow for detailed project configuration directly from the command line.
//! 2.  **Pre-flight Checks**: Before creating any files, it verifies that the target directory
//!     is not already an `axes` project.
//! 3.  **Detail Gathering**: The `gather_project_details` orchestrator collects all necessary
//!     information, either from the parsed arguments (in `--autosolve` mode) or by prompting
//!     the user interactively for things like the project name and parent.
//! 4.  **Collision Detection**: It performs a crucial check to ensure the chosen project name
//!     does not conflict with an existing sibling under the chosen parent.
//! 5.  **File & Index Creation**: If all checks pass, it performs the necessary mutations:
//!     a. Adds the new project to the `GlobalIndex`.
//!     b. Creates the `.axes` directory.
//!     c. Generates and writes a default `axes.toml` file.
//!     d. Generates and writes the local `project_ref.bin` identity file.
//! 6.  **User Feedback**: It concludes by printing a clear summary of the newly created project.

use anyhow::{Context, Result, anyhow};
use clap::Parser;
use colored::*;
use dialoguer::{Error as DialoguerError, Input, theme::ColorfulTheme};
use std::{collections::HashMap, env, fs, io, path::Path};
use uuid::Uuid;

use super::commons;
use crate::{
    constants::{AXES_DIR, PROJECT_CONFIG_FILENAME, PROJECT_REF_FILENAME},
    core::{context_resolver, index_manager},
    models::{ProjectConfig, ProjectRef},
    state::AppStateGuard,
};

// --- Command Argument Parsing ---

#[derive(Parser, Debug, Default)]
#[command(
    no_binary_name = true,
    about = "Initializes a new axes project in the current directory."
)]
struct InitArgs {
    /// The name for the new project. If not provided, will be asked interactively.
    pub name: Option<String>,
    /// The context of the parent project. Defaults to 'global'.
    #[arg(long)]
    pub parent: Option<String>,
    /// The version of the project.
    #[arg(long, short)]
    pub version: Option<String>,
    /// A short description of the project.
    #[arg(long, short)]
    pub description: Option<String>,
    /// Do not ask for user input, use defaults for unspecified values.
    #[arg(long)]
    pub autosolve: bool,
    /// Set environment variables (e.g., --env KEY1=VAL1,KEY2=VAL2).
    #[arg(long, value_delimiter = ',', num_args = 1..)]
    pub env: Vec<String>,
    /// Set interpolation variables (e.g., --var KEY1=VAL1,KEY2=VAL2).
    #[arg(long, value_delimiter = ',', num_args = 1..)]
    pub var: Vec<String>,
}

/// A container for all details needed to create a new project, gathered from arguments
/// or interactive prompts.
struct ProjectDetails {
    /// The validated name of the new project.
    name: String,
    /// The UUID of the chosen parent project.
    parent_uuid: Uuid,
    /// The project's version string.
    version: String,
    /// A short description of the project.
    description: String,
    /// A map of environment variables to include in `axes.toml`.
    env: HashMap<String, String>,
    /// A map of interpolation variables to include in `axes.toml`.
    vars: HashMap<String, String>,
}

// --- Main Handler ---

/// The main handler for the `init` command.
///
/// It orchestrates the entire project creation workflow, from gathering details to
/// modifying the filesystem and updating the global index.
///
/// # Arguments
/// * `_context` - The context from the dispatcher, which is ignored by this command.
/// * `args` - The command-specific arguments provided by the user.
/// * `state_guard` - A mutable guard to the application state.
pub fn handle(
    _context: Option<String>,
    args: Vec<String>,
    state_guard: &mut AppStateGuard<'_>,
) -> Result<()> {
    let init_args = InitArgs::try_parse_from(&args)?;
    let target_dir = env::current_dir()?;

    println!(
        "\n{}",
        format!("Initializing axes project in {}", target_dir.display()).bold()
    );

    // 1. Pre-flight check: ensure the directory is not already an axes project.
    let axes_dir = target_dir.join(AXES_DIR);
    if axes_dir.exists() {
        return Err(anyhow!(t!("init.error.already_exists"), dir = AXES_DIR));
    }

    // 2. Gather all project details, interactively or from args.
    let details = gather_project_details(init_args, &target_dir, state_guard)?;

    // 3. Create the configuration object.
    let mut project_config =
        ProjectConfig::new_for_init(&details.name, &details.version, &details.description);
    project_config.env.extend(details.env);
    for (key, value) in details.vars {
        project_config
            .vars
            .insert(key, crate::models::TomlVar::Simple(value));
    }

    // 4. Perform filesystem and index operations.
    let (new_uuid, _) = index_manager::add_project_to_index(
        state_guard.index_mut(),
        details.name.clone(),
        target_dir.clone(),
        Some(details.parent_uuid),
    )
    .with_context(|| t!("init.error.add_to_index"))?;

    fs::create_dir_all(&axes_dir)?;

    let config_path = axes_dir.join(PROJECT_CONFIG_FILENAME);
    let toml_string = toml::to_string_pretty(&project_config)?;
    fs::write(&config_path, toml_string)?;

    let project_ref = ProjectRef {
        self_uuid: new_uuid,
        parent_uuid: Some(details.parent_uuid),
        name: details.name.clone(),
    };
    index_manager::write_project_ref(&target_dir, &project_ref)
        .with_context(|| format!(t!("init.error.write_ref"), file = PROJECT_REF_FILENAME))?;

    // `main` will handle saving the updated index.

    // 5. Final summary feedback.
    println!("\n{}", t!("common.success").green().bold());
    println!("  {:<15} {}", "Project Name:".blue(), details.name);
    println!("  {:<15} {}", "UUID:".blue(), new_uuid);
    println!(
        "  {:<15} {}",
        "Parent:".blue(),
        index_manager::build_qualified_name(details.parent_uuid, state_guard.index())
            .unwrap_or_default()
    );
    println!("  {:<15} {}", "Config file:".blue(), config_path.display());
    println!("\n{}", t!("init.success.next_steps").dimmed());

    Ok(())
}

// --- Helper Functions ---

/// Orchestrates the collection of all project details, handling interactive and non-interactive modes.
fn gather_project_details(
    args: InitArgs,
    target_dir: &Path,
    state_guard: &mut AppStateGuard<'_>,
) -> Result<ProjectDetails> {
    let is_interactive = !args.autosolve;

    // --- Resolve name and parent first for early validation ---
    let name = resolve_project_name(&args.name, target_dir, is_interactive)?;
    let parent_uuid = resolve_parent_project(&args.parent, is_interactive, state_guard)?;

    // --- Early collision check ---
    if index_manager::is_sibling_name_taken(state_guard.index(), parent_uuid, &name, None) {
        return Err(anyhow!(t!("init.error.name_collision"), name = name));
    }

    // --- Proceed with other details only after validation passes ---
    let version = resolve_string_value(
        &args.version,
        t!("init.prompt.version"),
        "0.1.0".to_string(),
        is_interactive,
    )?;
    let description = resolve_string_value(
        &args.description,
        t!("init.prompt.description"),
        format!("A new project named '{}', managed by `axes`.", name),
        is_interactive,
    )?;
    let env = parse_key_value_pairs(&args.env)?;
    let vars = parse_key_value_pairs(&args.var)?;

    Ok(ProjectDetails {
        name,
        parent_uuid,
        version,
        description,
        env,
        vars,
    })
}

fn resolve_project_name(
    name_arg: &Option<String>,
    target_dir: &Path,
    is_interactive: bool,
) -> Result<String> {
    if let Some(name) = name_arg {
        println!("  {} {}", "Project Name:".dimmed(), name);
        return commons::validate_project_name(name);
    }

    let default_name = target_dir
        .file_name()
        .unwrap_or_default()
        .to_string_lossy()
        .to_string();

    if is_interactive {
        loop {
            let prompt = t!("init.prompt.name");
            let input = match Input::with_theme(&ColorfulTheme::default())
                .with_prompt(prompt)
                .default(default_name.clone())
                .interact_text()
            {
                Ok(value) => value,
                Err(DialoguerError::IO(e)) if e.kind() == io::ErrorKind::Interrupted => {
                    return Err(anyhow!(t!("common.error.operation_cancelled")));
                }
                Err(e) => return Err(e.into()),
            };
            match commons::validate_project_name(&input) {
                Ok(name) => return Ok(name),
                Err(e) => println!("{}", format!("  Error: {}", e).red()),
            }
        }
    } else {
        println!(
            "  {} {} {}",
            "Project Name:".dimmed(),
            default_name,
            t!("common.label.default").dimmed()
        );
        commons::validate_project_name(&default_name)
    }
}

fn resolve_parent_project(
    parent_arg: &Option<String>,
    is_interactive: bool,
    state_guard: &mut AppStateGuard<'_>,
) -> Result<Uuid> {
    if let Some(parent_context) = parent_arg {
        let (uuid, qualified_name) =
            context_resolver::resolve_context(parent_context, state_guard)?;
        println!("  {} {}", "Parent Project:".dimmed(), qualified_name);
        return Ok(uuid);
    }

    if is_interactive {
        return commons::choose_parent_interactive(state_guard);
    }

    println!(
        "  {} global {}",
        "Parent Project:".dimmed(),
        t!("common.label.default").dimmed()
    );
    Ok(index_manager::GLOBAL_PROJECT_UUID)
}

/// A helper function to parse key-value pairs from the command line (e.g., "KEY=VALUE").
/// Used for parsing `--env` and `--var` arguments.
fn parse_key_value_pairs(pairs: &[String]) -> Result<HashMap<String, String>> {
    let mut map = HashMap::with_capacity(pairs.len());
    for pair in pairs {
        let (key, value) = pair
            .split_once('=')
            .ok_or_else(|| anyhow!(t!("init.error.invalid_kv_pair"), pair = pair))?;

        // OPTIMIZATION: Use `to_owned()` which can be cheaper than `to_string()` for `&str`.
        // Also makes the ownership explicit.
        map.insert(key.trim().to_owned(), value.trim().to_owned());
    }
    Ok(map)
}

/// A generic helper to resolve a string value, either from a command-line argument
/// or by interactively prompting the user.
///
/// # Arguments
/// * `arg_val` - The value from the parsed `clap` arguments.
/// * `prompt` - The text to display to the user if interactive input is needed.
/// * `default_val` - The default value to use in both interactive and non-interactive modes.
/// * `is_interactive` - A boolean indicating whether to prompt the user.
fn resolve_string_value(
    arg_val: &Option<String>,
    prompt: &str,
    default_val: String,
    is_interactive: bool,
) -> Result<String> {
    if let Some(val) = arg_val {
        // We can make the output cleaner by specifying what we are setting.
        // Let's assume the prompt contains the "name" of the value.
        println!("  {} {}", format!("{}:", prompt).dimmed(), val);
        return Ok(val.clone());
    }

    if is_interactive {
        Input::with_theme(&ColorfulTheme::default())
            .with_prompt(prompt)
            .default(default_val)
            .interact_text()
            .map_err(|e| anyhow!(e))
    } else {
        println!(
            "  {} {} {}",
            format!("{}:", prompt).dimmed(),
            default_val,
            t!("common.label.default").dimmed()
        );
        Ok(default_val)
    }
}

===== cli\handlers\link.rs =====
//! # Handler for the `link` command
//!
//! This module provides the logic for the `axes link` command, which changes the parent
//! of a registered project, effectively moving it to a new location within the project
//! hierarchy.
//!
//! ## Core Logic
//!
//! 1.  **Context Resolution**: It resolves two contexts: the project to be moved and the
//!     new parent project. This requires mutable access to the application state as it
//!     updates `last_used` metadata.
//! 2.  **Pre-flight Validation**: Before performing any mutation, the `validate_link_operation`
//!     function runs a series of critical safety checks:
//!     - Prevents linking the "global" project.
//!     - Prevents a project from being linked to itself.
//!     - Checks if the link is a no-op (i.e., the project is already a child of the
//!       target parent).
//!       The underlying `index_manager::link_project` performs further checks for circular
//!       dependencies and name collisions.
//! 3.  **Index Mutation**: If validation passes, it calls `index_manager::link_project`, which
//!     atomically updates both the in-memory `GlobalIndex` and the on-disk `project_ref.bin`
//!     file of the moved project.
//! 4.  **User Feedback**: It provides a clear summary of the operation, showing the project's
//!     old and new fully qualified names.

use anyhow::{Context, Result, anyhow};
use clap::Parser;
use colored::*;
use uuid::Uuid;

use crate::{
    cli::handlers::commons,
    core::{context_resolver, index_manager},
    models::GlobalIndex,
    state::AppStateGuard,
};

// --- Command Argument Parsing ---

#[derive(Parser, Debug, Default)]
#[command(
    no_binary_name = true,
    about = "Moves a project to be a child of another project."
)]
struct LinkArgs {
    /// The context of the new parent project.
    new_parent: String,
}

// --- Main Handler ---

/// The main handler for the `link` command.
///
/// It orchestrates the process of resolving the target project and the new parent,
/// validating the operation, performing the link, and providing feedback to the user.
///
/// # Arguments
/// * `context` - The context of the project to be moved, provided by the dispatcher.
/// * `args` - Command-specific arguments, containing the context of the new parent.
/// * `state_guard` - A mutable guard to the application state.
pub fn handle(
    context: Option<String>,
    args: Vec<String>,
    state_guard: &mut AppStateGuard<'_>,
) -> Result<()> {
    // 1. Parse arguments and resolve the project to be moved.
    let link_args = LinkArgs::try_parse_from(&args)?;
    let context_str =
        context.ok_or_else(|| anyhow!(t!("error.context_required"), command = "link"))?;

    let config = commons::resolve_config_for_context(Some(context_str), state_guard)?;
    let project_to_move_uuid = config.uuid;
    let old_qualified_name = config.qualified_name.clone();

    // 2. Resolve the new parent project.
    let (new_parent_uuid, new_parent_qualified_name) =
        context_resolver::resolve_context(&link_args.new_parent, state_guard).with_context(
            || {
                anyhow!(
                    t!("link.error.cannot_resolve_parent"),
                    parent = link_args.new_parent
                )
            },
        )?;

    // 3. Perform critical pre-flight safety checks.
    if validate_link_operation(
        state_guard.index(),
        project_to_move_uuid,
        new_parent_uuid,
        &old_qualified_name,
        &new_parent_qualified_name,
    )?
    .is_none()
    {
        // A `None` result from validation indicates a no-op (already a child), so we exit.
        return Ok(());
    }

    println!(
        "\n{}",
        format_args!(
            t!("link.info.attempting"),
            name = old_qualified_name.cyan(),
            new_parent = new_parent_qualified_name.cyan()
        )
    );

    // 4. Perform the link operation. The index manager now handles the `project_ref.bin` update internally.
    index_manager::link_project(
        state_guard.index_mut(),
        project_to_move_uuid,
        new_parent_uuid,
    )
    .with_context(|| anyhow!(t!("link.error.link_failed"), name = old_qualified_name))?;

    // 5. Provide clear, detailed feedback to the user.
    let new_qualified_name =
        index_manager::build_qualified_name(project_to_move_uuid, state_guard.index())
            .unwrap_or_else(|| t!("common.label.unknown").to_string());

    println!("\n{}", t!("common.success").green().bold());
    println!("  {:<15} {}", "Project Moved:".blue(), old_qualified_name);
    println!(
        "  {:<15} {}",
        "New Parent:".blue(),
        new_parent_qualified_name
    );
    println!(
        "  {:<15} {}",
        "New Full Path:".blue(),
        new_qualified_name.cyan()
    );
    println!("\n  {}", t!("common.info.caches_will_regenerate").dimmed());

    Ok(())
}

/// Centralizes all pre-flight safety checks for the link operation.
///
/// This function performs initial, high-level validation before the more intensive
/// checks (like cycle detection) in `index_manager::link_project`.
///
/// # Arguments
/// * `index` - An immutable reference to the `GlobalIndex`.
/// * `project_to_move_uuid` - The UUID of the project being moved.
/// * `new_parent_uuid` - The UUID of the target parent.
/// * `old_qualified_name` - The current qualified name of the project being moved.
/// * `new_parent_qualified_name` - The qualified name of the target parent.
///
/// # Returns
/// - `Ok(Some(()))` if the operation is valid and should proceed.
/// - `Ok(None)` if the operation is a no-op (already a child) and should be silently aborted.
/// - `Err` for critical validation failures (e.g., linking to self).
fn validate_link_operation(
    index: &GlobalIndex,
    project_to_move_uuid: Uuid,
    new_parent_uuid: Uuid,
    old_qualified_name: &str,
    new_parent_qualified_name: &str,
) -> Result<Option<()>> {
    if project_to_move_uuid == index_manager::GLOBAL_PROJECT_UUID {
        return Err(anyhow!(t!("link.error.cannot_link_global")));
    }
    if project_to_move_uuid == new_parent_uuid {
        return Err(anyhow!(t!("link.error.link_to_self")));
    }

    let project_to_move_entry = index
        .projects
        .get(&project_to_move_uuid)
        .expect("UUID to move should exist as it was just resolved");
    if project_to_move_entry.parent == Some(new_parent_uuid) {
        println!(
            "{}",
            format!(
                t!("link.info.already_child"),
                name = old_qualified_name,
                parent = new_parent_qualified_name
            )
            .yellow()
        );
        return Ok(None); // Signal a no-op.
    }

    Ok(Some(())) // Signal success.
}

===== cli\handlers\mod.rs =====
//! # Command Handlers Module
//!
//! This module acts as a central directory for all the sub-modules that implement the
//! logic for `axes` commands. Each file within this module corresponds to a specific
//! command (e.g., `run.rs` handles `axes run`, `init.rs` handles `axes init`).
//!
//! ## Module Structure
//!
//! - **`mod.rs`**: This file, which simply declares all other handler modules to make them
//!   accessible to the rest of the application.
//! - **`<command>.rs`**: Each file contains the primary `handle` function, which serves as the
//!   entry point for that command's logic, along with any necessary helper functions, `clap`
//!   argument structs, and other implementation details specific to that command.
//! - **`commons.rs`**: A special module that contains shared utility functions and data
//!   structures used by multiple handlers to promote code reuse (DRY) and ensure consistent
//!   behavior across the application.

pub mod alias;
pub mod commons;
pub mod debug_cache;
pub mod delete;
pub mod info;
pub mod init;
pub mod link;
pub mod open;
pub mod register;
pub mod rename;
pub mod repair;
pub mod run;
pub mod start;
pub mod tree;
pub mod unregister;

===== cli\handlers\open.rs =====
//! # Handler for the `open` command
//!
//! This module provides the logic for the `axes open` command, which allows users to
//! launch a project in a configured application, such as a code editor, file explorer,
//! or a new terminal session.
//!
//! ## Core Logic
//!
//! 1.  **Argument Parsing**: It parses an optional `app_key` to specify which application to use,
//!     a `--list` flag to show available options, and trailing arguments to be passed to the
//!     underlying script.
//! 2.  **Configuration Resolution**: It resolves the project's configuration to access the
//!     `[options.open_with]` table, which contains the scripts for each `app_key`.
//! 3.  **Command Dispatching**:
//!     - If `--list` is used, it prints a formatted list of all available `open` commands.
//!     - Otherwise, it determines which `app_key` to use (the one provided, or the configured
//!       default) and proceeds to execution.
//! 4.  **Task Execution**: It retrieves the corresponding `Task` (AST) for the chosen `app_key`,
//!     flattens it to resolve any compositions, specializes it for the current platform, builds
//!     an argument resolver, and finally passes it to the `task_executor` to be run.

use crate::{
    cli::handlers::commons,
    core::task_executor,
    models::{ResolvedConfig, ResolvedOpenWithConfig},
    state::AppStateGuard,
};
use anyhow::{Result, anyhow};
use clap::Parser;
use colored::*;
use dialoguer::console::measure_text_width;

// --- Command Argument Parsing ---

#[derive(Parser, Debug, Default)]
#[command(
    no_binary_name = true,
    about = "Opens the project using a configured application or script."
)]
struct OpenArgs {
    /// The application key to use (e.g., 'editor', 'shell'). If omitted, uses the configured default.
    app_key: Option<String>,
    /// List all available 'open with' commands for this project.
    #[arg(long, short)]
    list: bool,
    /// Parameters to pass to the open command.
    #[arg(trailing_var_arg = true, allow_hyphen_values = true)]
    params: Vec<String>,
}

// --- Main Handler ---

/// The main handler for the `open` command.
///
/// It determines whether to list available `open` commands or to execute one based
/// on the parsed arguments.
///
/// # Arguments
/// * `context` - The project context in which to operate, provided by the dispatcher.
/// * `args` - Command-specific arguments (e.g., `editor -- -p 1234`).
/// * `state_guard` - A mutable guard to the application state, needed for config resolution.
pub fn handle(
    context: Option<String>,
    args: Vec<String>,
    state_guard: &mut AppStateGuard<'_>,
) -> Result<()> {
    let open_args = OpenArgs::try_parse_from(&args)?;
    let config = commons::resolve_config_for_context(context, state_guard)?;
    let options = config.get_options()?;

    if open_args.list {
        list_open_commands(&config.qualified_name, &options.open_with);
        return Ok(());
    }

    execute_open_command(open_args, config, options.open_with)
}

// --- Subcommand Logic ---

/// Prints a formatted list of all available `open_with` commands for a project.
///
/// # Arguments
/// * `project_name` - The qualified name of the project.
/// * `open_with` - The resolved `[options.open_with]` configuration.
fn list_open_commands(project_name: &str, open_with: &ResolvedOpenWithConfig) {
    println!("\nAvailable `open` commands for '{}':", project_name.cyan());
    if open_with.commands.is_empty() {
        println!("  {}", "No commands defined.".dimmed());
        return;
    }

    let mut sorted_keys: Vec<_> = open_with.commands.keys().collect();
    sorted_keys.sort();
    let max_len = sorted_keys
        .iter()
        .map(|k| measure_text_width(k))
        .max()
        .unwrap_or(0);

    for key in sorted_keys {
        let task = open_with
            .commands
            .get(key)
            .expect("Key should exist as we are iterating over map keys");
        let padding = " ".repeat(max_len - measure_text_width(key));
        print!("  - {}{} ", key.green(), padding);
        if Some(key.as_str()) == open_with.default.as_deref() {
            print!("{} ", t!("common.label.default").yellow());
        }
        if let Some(desc) = &task.desc
            && !desc.trim().is_empty()
        {
            print!("{}", desc.dimmed());
        }

        println!();
    }
}

/// Handles the logic for executing a specific `open_with` command.
///
/// This function performs the multi-step process of preparing and running a task:
/// it finds the correct task, flattens it, builds an argument resolver, specializes it
/// for the current OS, and finally executes it.
///
/// # Arguments
/// * `open_args` - The parsed arguments for the `open` command.
/// * `config` - The fully resolved configuration for the project.
/// * `open_with` - The resolved `[options.open_with]` section of the configuration.
fn execute_open_command(
    open_args: OpenArgs,
    config: ResolvedConfig,
    open_with: ResolvedOpenWithConfig,
) -> Result<()> {
    // 1. Determine which application key to use.
    let app_key_to_use = open_args
        .app_key
        .as_deref()
        .or(open_with.default.as_deref())
        .ok_or_else(|| anyhow!(t!("open.error.no_default")))?;

    // 2. Get the universal Task AST.
    let task_universal = open_with.commands.get(app_key_to_use).ok_or_else(|| {
        if Some(app_key_to_use) == open_with.default.as_deref() {
            anyhow!(
                t!("open.error.default_not_found"),
                key = app_key_to_use.cyan()
            )
        } else {
            anyhow!(t!("open.error.key_not_found"), key = app_key_to_use.cyan())
        }
    })?;

    // 3. Flatten the task to resolve compositions.
    let task_flattened = config.flatten_task(task_universal)?;

    // 4. Build the argument resolver from the *universal* flattened task.
    let resolver = commons::build_resolver_for_task(&task_flattened, &open_args.params)?;

    // 5. [OPTIMIZATION] Specialize the task for the current platform.
    let task_specialized = config.specialize_task_for_platform(&task_flattened);

    // 6. Execute the final, specialized task.
    println!(
        "\n🚀 Opening '{}' with '{}'...",
        config.qualified_name.cyan(),
        app_key_to_use.cyan()
    );
    task_executor::execute_task(&task_specialized, &config, &resolver)?;

    Ok(())
}

===== cli\handlers\register.rs =====
//! # Handler for the `register` command
//!
//! This module provides the logic for the `axes register` command, which discovers existing
//! `axes` projects on the filesystem (those with an `axes.toml` file) and adds them to the
//! global index.
//!
//! ## Core Logic
//!
//! This handler acts as a high-level orchestrator for the more complex logic contained
//! within the `onboarding_manager` module. Its primary responsibilities are:
//!
//! 1.  **Argument Parsing**: It parses arguments like the target `path`, a suggested `--parent`,
//!     and the `--autosolve` flag for non-interactive mode.
//! 2.  **Path Resolution**: It determines the absolute, canonical path to begin the discovery scan,
//!     defaulting to the current working directory if no path is provided.
//! 3.  **Options Assembly**: It constructs an `OnboardingOptions` struct based on the parsed
//!     arguments to configure the behavior of the onboarding process.
//! 4.  **Delegation**: It delegates the entire complex workflow of discovery, conflict resolution,
//!     user interaction, and final registration to the `onboarding_manager::register_project` function.

use anyhow::{Context, Result, anyhow};
use clap::Parser;
use colored::*;
use std::{env, path::PathBuf};

use crate::{
    core::onboarding_manager::{self, OnboardingOptions},
    state::AppStateGuard,
};

// --- Command Argument Parsing ---
#[derive(Parser, Debug, Default)]
#[command(
    no_binary_name = true,
    about = "Registers an existing axes project (and its children) into the global index."
)]
struct RegisterArgs {
    /// The path to the project to register. Defaults to the current directory.
    pub path: Option<String>,
    /// The context of the project that should become the parent of the new project.
    #[arg(long)]
    pub parent: Option<String>,
    /// Do not ask for user input; fail on any conflict.
    #[arg(long)]
    pub autosolve: bool,
}

// --- Main Handler ---

/// The main handler for the `register` command.
///
/// It sets up the necessary options and initial path, then delegates the complex
/// registration logic to the `onboarding_manager`.
///
/// # Arguments
/// * `context` - The project context, which can be used as the path to register.
/// * `args` - Command-specific arguments (e.g., `--parent <parent_context>`).
/// * `state_guard` - A mutable guard to the application state, which will be modified
///   by the registration process.
pub fn handle(
    context: Option<String>,
    args: Vec<String>,
    state_guard: &mut AppStateGuard<'_>,
) -> Result<()> {
    if env::var("AXES_PROJECT_UUID").is_ok() {
        return Err(anyhow!(t!("register.error.in_session")));
    }

    let register_args = RegisterArgs::try_parse_from(&args)?;

    // Determine the initial path to scan from.
    let path_arg = register_args.path.or(context);
    let initial_path_unresolved = match path_arg {
        Some(p) => PathBuf::from(p),
        None => env::current_dir()?,
    };

    // This prevents ambiguity with relative paths like `.` or `../`.
    let initial_path = dunce::canonicalize(&initial_path_unresolved).with_context(|| {
        format!(
            "Failed to resolve path: {}",
            initial_path_unresolved.display()
        )
    })?;

    let suggested_parent_uuid = if let Some(parent_context) = &register_args.parent {
        let (uuid, name) =
            crate::core::context_resolver::resolve_context(parent_context, state_guard)?;
        println!("Using '{}' as the suggested parent.", name.cyan());
        Some(uuid)
    } else {
        None
    };

    let options = OnboardingOptions {
        autosolve: register_args.autosolve,
        suggested_parent_uuid,
    };

    onboarding_manager::register_project(&initial_path, state_guard, &options)
        .with_context(|| format!(t!("register.error.failed"), path = initial_path.display()))?;

    Ok(())
}

===== cli\handlers\rename.rs =====
//! # Handler for the `rename` command
//!
//! This module provides the logic for the `axes rename` command, which changes the simple
//! name of a registered project. This affects the project's qualified name and how it is
//! addressed in context paths.
//!
//! ## Core Logic
//!
//! 1.  **Argument Parsing**: It parses the target project context and the desired new name.
//! 2.  **Validation**:
//!     - It uses `commons::validate_project_name` to ensure the new name is syntactically valid.
//!     - `pre_rename_validation` performs critical pre-flight checks, aborting if the rename
//!       is a no-op (old name is the same as the new name) and providing a special confirmation
//!       prompt if the user attempts to rename the sensitive "global" project.
//! 3.  **Index Mutation**: If validation passes, it calls `index_manager::rename_project`. This
//!     core function atomically updates the project's name in both the in-memory `GlobalIndex`
//!     and the project's local on-disk `project_ref.bin` file, ensuring consistency.
//! 4.  **User Feedback**: It prints a clear summary showing the old and new qualified names
//!     to confirm the change to the user.

use anyhow::{Context, Result, anyhow};
use clap::Parser;
use colored::*;
use dialoguer::{Confirm, theme::ColorfulTheme};

use crate::{
    core::{context_resolver, index_manager},
    state::AppStateGuard,
};

// --- Command Argument Parsing ---
#[derive(Parser, Debug, Default)]
#[command(no_binary_name = true, about = "Renames a registered project.")]
struct RenameArgs {
    /// The new name for the project.
    new_name: String,
}

// --- Main Handler ---

/// The main handler for the `rename` command.
///
/// It orchestrates the process of validating the new name, resolving the target project,
/// performing safety checks, executing the rename operation, and providing feedback.
///
/// # Arguments
/// * `context` - The context of the project to rename, provided by the dispatcher.
/// * `args` - Command-specific arguments, containing the new name for the project.
/// * `state_guard` - A mutable guard to the application state.
pub fn handle(
    context: Option<String>,
    args: Vec<String>,
    state_guard: &mut AppStateGuard<'_>,
) -> Result<()> {
    // 1. Parse and validate arguments.
    let rename_args = RenameArgs::try_parse_from(&args)?;
    let new_name = crate::cli::handlers::commons::validate_project_name(&rename_args.new_name)?;
    let context_str =
        context.ok_or_else(|| anyhow!(t!("error.context_required"), command = "rename"))?;

    // 2. Resolve target and perform pre-flight checks.
    let (uuid_to_rename, old_qualified_name) =
        context_resolver::resolve_context(&context_str, state_guard)?;
    let old_simple_name = &state_guard
        .index()
        .projects
        .get(&uuid_to_rename)
        .expect("UUID to rename should exist as it was just resolved")
        .name;

    // This function now handles no-op and global project confirmation.
    if !pre_rename_validation(uuid_to_rename, old_simple_name, &new_name)? {
        return Ok(()); // Validation failed or user cancelled, exit gracefully.
    }

    println!(
        "\n{}",
        format_args!(
            t!("rename.info.renaming"),
            old_name = old_simple_name.yellow(),
            new_name = new_name.cyan()
        )
    );

    // 3. Perform the rename operation.
    log::info!(
        "Renaming project {} ('{}') to '{}'",
        uuid_to_rename,
        old_qualified_name,
        new_name
    );
    index_manager::rename_project(state_guard.index_mut(), uuid_to_rename, &new_name)
        .with_context(|| anyhow!(t!("rename.error.rename_failed"), name = old_qualified_name))?;

    // 4. Provide clear feedback.
    let new_qualified_name =
        index_manager::build_qualified_name(uuid_to_rename, state_guard.index())
            .unwrap_or_default();

    println!("\n{}", t!("common.success").green().bold());
    println!("  {:<18} {}", "Old Full Path:".blue(), old_qualified_name);
    println!(
        "  {:<18} {}",
        "New Full Path:".blue(),
        new_qualified_name.cyan()
    );
    println!("\n  {}", t!("rename.info.caches_remain_valid").dimmed());

    Ok(())
}

/// A helper function that performs pre-flight safety checks before a rename operation.
///
/// It checks for no-op renames (new name is the same as the old) and handles the special
/// confirmation flow required for renaming the global project.
///
/// # Returns
/// `Ok(true)` if the rename should proceed, `Ok(false)` if it's a no-op or the user cancelled.
fn pre_rename_validation(uuid: uuid::Uuid, old_name: &str, new_name: &str) -> Result<bool> {
    // Check for no-op renames.
    if old_name == new_name {
        println!(
            "\n{}",
            format!(t!("rename.info.no_change"), name = new_name).yellow()
        );
        return Ok(false);
    }

    // Handle special case for 'global' project.
    if uuid == index_manager::GLOBAL_PROJECT_UUID {
        return confirm_global_rename();
    }

    Ok(true)
}

/// A helper function that displays a stern warning and requires explicit confirmation
/// from the user before allowing the "global" project to be renamed.
fn confirm_global_rename() -> Result<bool> {
    println!(
        "{}",
        t!("rename.warning.renaming_global_header").yellow().bold()
    );
    println!("  - {}", t!("rename.warning.renaming_global_docs"));
    println!("  - {}", t!("rename.warning.renaming_global_community"));

    if !Confirm::with_theme(&ColorfulTheme::default())
        .with_prompt(t!("common.prompt.are_you_sure"))
        .default(false)
        .interact()?
    {
        println!("\n{}", t!("common.info.operation_cancelled"));
        return Ok(false);
    }
    Ok(true)
}

===== cli\handlers\repair.rs =====
//! # Handler for the `repair` command
//!
//! This module provides the logic for the `axes repair` command, a diagnostic and fixing tool
//! designed to resolve inconsistencies between the central `GlobalIndex` and the state of
//! projects on the filesystem.
//!
//! ## Core Logic
//!
//! The command operates in distinct phases:
//!
//! 1.  **Scan & Detect**: The `scan_for_path_mismatches` function traverses a specified
//!     directory structure (recursively or not) looking for `.axes/project_ref.bin` files.
//!     For each one found, it compares the project's UUID and path with the information
//!     stored in the `GlobalIndex`. Currently, it detects:
//!     -   **Path Mismatches**: A project registered in the index with `path A`, but its
//!         `project_ref.bin` is found at `path B` (indicating the project directory was moved).
//!
//! 2.  **Report**: If any inconsistencies are found, they are presented to the user in a
//!     clear, color-coded format, showing the "registered" state vs. the "found" state.
//!
//! 3.  **Fix (Optional)**: If the user runs the command with the `--fix` flag and confirms
//!     the interactive prompt, the handler mutates the `GlobalIndex` to correct the detected
//!     discrepancies. For example, it will update the `path` field of an `IndexEntry` to
//!     point to the project's new location.

use anyhow::{Result, anyhow};
use clap::Parser;
use colored::*;
use dialoguer::{Confirm, theme::ColorfulTheme};
use std::{env, path::PathBuf};
use walkdir::WalkDir;

use crate::{core::index_manager, models::GlobalIndex, state::AppStateGuard};

// --- Command Argument Parsing ---

#[derive(Parser, Debug, Default)]
#[command(
    no_binary_name = true,
    about = "Scans the filesystem to find and fix inconsistencies in the axes index."
)]
struct RepairArgs {
    /// The starting path for the scan. Defaults to the current directory.
    path: Option<String>,

    /// Recursively scan subdirectories.
    #[arg(long, short)]
    recursive: bool,

    /// Maximum depth for recursive scanning. Requires --recursive.
    #[arg(long, short, requires = "recursive")]
    depth: Option<usize>,

    /// Apply the found fixes to the global index after confirmation.
    #[arg(long)]
    fix: bool,
}

// --- Data Structures for Reporting ---

/// A local struct used to report a discrepancy between the index and the filesystem.
struct PathMismatch {
    /// The UUID of the project.
    uuid: uuid::Uuid,
    /// The name of the project.
    name: String,
    /// The path currently registered in the `GlobalIndex`.
    old_path: PathBuf,
    /// The new path where the project was found on the filesystem.
    new_path: PathBuf,
}

// --- Main Handler ---

/// The main handler for the `repair` command.
///
/// It orchestrates the scan, report, and optional fix phases of the repair process.
///
/// # Arguments
/// * `_context` - The context from the dispatcher, which is ignored by this global command.
/// * `args` - Command-specific arguments (e.g., `--recursive`, `--fix`).
/// * `state_guard` - A mutable guard to the application state.
pub fn handle(
    _context: Option<String>,
    args: Vec<String>,
    state_guard: &mut AppStateGuard<'_>,
) -> Result<()> {
    if env::var("AXES_PROJECT_UUID").is_ok() {
        return Err(anyhow!(t!("repair.error.in_session")));
    }

    let repair_args = RepairArgs::try_parse_from(&args)?;
    let start_path = match repair_args.path {
        Some(ref p) => PathBuf::from(p),
        None => env::current_dir()?,
    };

    println!(
        "\n{}",
        format!(t!("repair.info.starting_scan"), path = start_path.display()).bold()
    );

    // --- Phase 1: Scan and Detect ---
    let mismatches = scan_for_path_mismatches(&start_path, &repair_args, state_guard.index());

    // --- Phase 2: Report and (Optionally) Fix ---
    if mismatches.is_empty() {
        println!("{}", t!("repair.success.no_issues").green());
        // TODO: Add other repair checks here in the future (e.g., TOML validation).
        return Ok(());
    }

    println!(
        "\n{}",
        format!(t!("repair.warning.found_issues"), count = mismatches.len()).yellow()
    );
    for mismatch in &mismatches {
        println!(
            t!("repair.info.mismatch_header"),
            name = mismatch.name.cyan(),
            uuid = mismatch.uuid
        );
        println!(
            "  - {}: {}",
            t!("repair.label.registered_path"),
            mismatch.old_path.display().to_string().red()
        );
        println!(
            "  - {}: {}",
            t!("repair.label.found_at"),
            mismatch.new_path.display().to_string().green()
        );
    }

    if repair_args.fix {
        if !Confirm::with_theme(&ColorfulTheme::default())
            .with_prompt(t!("repair.prompt.apply_fixes"))
            .default(true)
            .interact()?
        {
            println!("\n{}", t!("common.info.operation_cancelled"));
            return Ok(());
        }

        // --- Phase 3: Apply Fixes ---
        let mut fixed_count = 0;
        for mismatch in mismatches {
            if let Some(entry) = state_guard.index_mut().projects.get_mut(&mismatch.uuid) {
                entry.path = mismatch.new_path;
                fixed_count += 1;
            }
        }
        println!(
            "\n{}",
            format!(t!("repair.success.fixed"), count = fixed_count).green()
        );
    } else {
        println!("\n{}", t!("repair.info.how_to_fix").dimmed());
    }

    Ok(())
}

// --- Helper Functions ---

/// Scans the filesystem starting from a given path to find projects and identify
/// path mismatches against the global index.
///
/// It uses `walkdir` to efficiently traverse the directory tree, reading `project_ref.bin`
/// files to identify projects.
///
/// # Arguments
/// * `start_path` - The root directory for the scan.
/// * `args` - The parsed command arguments, used to control recursion and depth.
/// * `index` - An immutable reference to the `GlobalIndex` to compare against.
fn scan_for_path_mismatches(
    start_path: &PathBuf,
    args: &RepairArgs,
    index: &GlobalIndex,
) -> Vec<PathMismatch> {
    let mut mismatches = Vec::new();
    let mut walker = WalkDir::new(start_path);

    if args.recursive {
        if let Some(d) = args.depth {
            walker = walker.max_depth(d);
        }
    } else {
        // If not recursive, only scan the start_path itself.
        walker = walker.max_depth(1);
    }

    for entry in walker.into_iter().filter_map(Result::ok) {
        let path = entry.path();
        let ref_path = path.join(".axes").join("project_ref.bin");

        if ref_path.is_file() {
            match index_manager::read_project_ref(path) {
                Ok(proj_ref) => {
                    if let Some(index_entry) = index.projects.get(&proj_ref.self_uuid) {
                        // Project found in index, check if the path is correct.
                        if index_entry.path != path {
                            mismatches.push(PathMismatch {
                                uuid: proj_ref.self_uuid,
                                name: proj_ref.name,
                                old_path: index_entry.path.clone(),
                                new_path: path.to_path_buf(),
                            });
                        }
                    }
                    // TODO: Handle case where project ref exists but UUID is NOT in index (orphaned project).
                }
                Err(e) => {
                    // Log or report corrupted project_ref.bin files.
                    println!(
                        "{}",
                        format!(
                            t!("repair.warning.corrupt_ref"),
                            path = ref_path.display(),
                            error = e
                        )
                        .yellow()
                    );
                }
            }
            // TODO: Add TOML validation logic here.
        }
    }
    mismatches
}

===== cli\handlers\run.rs =====
//! # Handler for the `run` command
//!
//! This module provides the logic for the `axes run` command, which is the primary mechanism
//! for executing user-defined scripts within a project's context. It also handles the default
//! behavior of listing available scripts when no specific script name is provided.
//!
//! ## Core Logic
//!
//! 1.  **Argument Parsing**: The handler's arguments are parsed in a non-standard way due to the
//!     universal grammar. It manually separates the `script_name` from the rest of the parameters
//!     (`script_params`) that will be passed to the script itself. It also includes manual parsing
//!     for a `--dry-run` flag.
//! 2.  **Configuration Resolution**: It resolves the project's configuration to gain access to the
//!     scripts map and other inherited settings.
//! 3.  **Command Dispatching**:
//!     - If a `script_name` is provided, it proceeds to the execution phase.
//!     - If no `script_name` is provided, it calls `list_available_scripts` to display a
//!       helpful list of runnable scripts in the current context.
//! 4.  **Task Preparation**: For execution, it follows a multi-step process:
//!     a. Retrieves the script's `Task` (AST) from the resolved configuration.
//!     b. Flattens the task to resolve any compositions (`<scripts::...>`).
//!     c. Builds an `ArgResolver` to handle parameter substitution.
//!     d. Specializes the flattened task for the current OS for optimal performance.
//! 5.  **Execution or Dry Run**:
//!     - If `--dry-run` is present, it calls `dry_run_script` to print a fully resolved
//!       execution plan without running any commands.
//!     - Otherwise, it calls `execute_script` which delegates to the `task_executor` to
//!       run the prepared task.

use crate::{
    cli::handlers::commons, core::{parameters::ArgResolver, task_executor}, dev_utils, models::{CommandAction, GlobalIndex, PlatformSpecializedTask, ResolvedConfig}, state::AppStateGuard
};
use anyhow::{Result, anyhow};
use clap::Parser;
use colored::*;

// --- Helper for the main dispatcher ---

/// Parses a script path string like "my-app/api/build" into its context and script name.
/// This is a helper function used internally by the main dispatcher (`bin/axes.rs`).
pub fn parse_script_path(full_path: &str) -> (Option<&str>, &str) {
    if let Some((context, script_name)) = full_path.rsplit_once('/') {
        (Some(context), script_name)
    } else {
        (None, full_path)
    }
}

// --- Command Argument Parsing ---

#[derive(Parser, Debug)]
#[command(
    no_binary_name = true,
    about = "Runs a script in the project's context. If no script is provided, lists available scripts."
)]
struct RunArgs {
    /// The name of the script to run.
    script_name: Option<String>,

    /// Display the execution plan without running any commands.
    #[arg(long, name = "dry-run")]
    dry_run: bool,

    /// Parameters and flags to pass to the script.
    #[arg(trailing_var_arg = true, allow_hyphen_values = true)]
    params: Vec<String>,
}

// --- Main Handler ---

/// The main entry point for the `run` command.
///
/// It determines whether to list scripts, perform a dry run, or execute a script based
/// on the provided arguments.
///
/// # Arguments
/// * `context` - The project context in which to run the script.
/// * `args` - The command-specific arguments, typically `[script_name, param1, param2, ...]`.
/// * `state_guard` - A mutable guard to the application state, needed for config resolution.
pub fn handle(
    context: Option<String>,
    mut args: Vec<String>,
    state_guard: &mut AppStateGuard<'_>,
) -> Result<()> {
    let script_name_opt = if args.is_empty() {
        None
    } else {
        Some(args.remove(0))
    };
    let script_params = args;
    let _timer = dev_utils::BlockTimer::new("  -> resolve_config_for_context");
    let config = commons::resolve_config_for_context(context, state_guard)?;

    match script_name_opt {
        Some(script_name) => {
            let (is_dry_run, final_params) = parse_dry_run_flag(&script_params);

            let task_universal = config.get_script(&script_name)?.ok_or_else(|| {
                anyhow!(
                    t!("run.error.not_found"),
                    script = script_name.cyan(),
                    project = config.qualified_name.yellow()
                )
            })?;

            let _timer = dev_utils::BlockTimer::new("  -> flatten_task");
            let task_flattened = config.flatten_task(&task_universal)?;

            let _timer = dev_utils::BlockTimer::new("  -> build_resolver_for_task");
            let resolver = commons::build_resolver_for_task(&task_flattened, &final_params)?;
            
            let task_specialized = config.specialize_task_for_platform(&task_flattened);

            let _timer_exec = dev_utils::BlockTimer::new("  -> task_executor::execute_task");
            if is_dry_run {
                dry_run_script(&script_name, &task_specialized, &config, &resolver)
            } else {
                execute_script(&script_name, &task_specialized, &config, &resolver)
            }
        }
        None => {
            // --- No script name provided: list available scripts ---
            // Any arguments passed (like `--dry-run`) are ignored in this mode.
            if !script_params.is_empty() {
                log::warn!("Arguments provided to 'axes run' without a script name are ignored.");
            }
            list_available_scripts(&config, state_guard.index())
        }
    }
}

// --- Subcommand Logic ---

/// A helper function that prints a formatted, sorted list of all scripts available
/// in the current project context, including inherited ones.
fn list_available_scripts(config: &ResolvedConfig, index: &GlobalIndex) -> Result<()> {
    let scripts = config.get_all_scripts()?;
    println!(
        "\nAvailable scripts for '{}':",
        config.qualified_name.cyan()
    );

    if scripts.is_empty() {
        println!("  {}", t!("info.label.no_scripts").dimmed());
        return Ok(());
    }

    let mut sorted_keys: Vec<_> = scripts.keys().collect();
    sorted_keys.sort();

    for script_name in sorted_keys {
        let task = scripts
            .get(script_name)
            .expect("Script name should exist as we are iterating over map keys");
        print!("  - {}", script_name.green());

        let source_project_name =
            crate::cli::handlers::info::find_task_source("scripts", script_name, config, index)?;
        if source_project_name != config.qualified_name {
            print!(
                " {}",
                format!(
                    "[{}]",
                    format_args!(t!("common.label.inherited"), from = source_project_name)
                )
                .dimmed()
            );
        }

        if let Some(d) = &task.desc
            && !d.trim().is_empty()
        {
            print!(": {}", d.dimmed());
        }
        println!();
    }

    println!("\n{}", t!("run.info.how_to_run").dimmed());
    Ok(())
}

/// Prepares and executes a script.
///
/// It prints a contextual header (unless the script is globally silent) and then
/// passes the prepared, platform-specialized task to the `task_executor`.
fn execute_script(
    script_name: &str,
    task: &PlatformSpecializedTask,
    config: &ResolvedConfig,
    resolver: &ArgResolver<'_>,
) -> Result<()> {
    if task.commands.is_empty() {
        println!("{}", t!("run.info.empty_script").yellow());
        return Ok(());
    }

    // Resolver is now passed in.

    let is_globally_silent = task.commands.iter().all(|cmd| cmd.silent_mode);
    log::debug!(
        "Script '{}' is_globally_silent = {}",
        script_name,
        is_globally_silent
    );

    if !is_globally_silent {
        let prefix_path = format_prefix_path(&config.qualified_name);
        println!("\n[{}:{}]", prefix_path.dimmed(), script_name.cyan());
    }

    task_executor::execute_task(task, config, resolver)?;
    Ok(())
}

/// Manually parses and removes the `--dry-run` flag from a list of parameters.
/// Clap is not suitable here as we need to separate the handler's flags from the script's parameters.
fn parse_dry_run_flag(params: &[String]) -> (bool, Vec<String>) {
    let mut is_dry_run = false;
    let mut final_params = Vec::with_capacity(params.len());

    for param in params {
        if param == "--dry-run" {
            is_dry_run = true;
        } else {
            final_params.push(param.clone());
        }
    }
    (is_dry_run, final_params)
}

/// Displays the fully-resolved execution plan for a script.
fn dry_run_script(
    script_name: &str,
    task: &PlatformSpecializedTask,
    config: &ResolvedConfig,
    resolver: &ArgResolver<'_>,
) -> Result<()> {
    let prefix_path = format_prefix_path(&config.qualified_name);
    println!(
        "\n📋 Dry-run for [{}:{}]",
        prefix_path.dimmed(),
        script_name.cyan()
    );

    if task.commands.is_empty() {
        println!("\n{}", t!("run.info.empty_script").yellow());
        return Ok(());
    }

    println!("---");
    // Iterate over the universal AST, but only render the command for the current platform
    for command_exec in &task.commands {
        let mut prefixes = String::new();
        if command_exec.silent_mode {
            prefixes.push('@');
        }
        if command_exec.ignore_errors {
            prefixes.push('-');
        }
        if command_exec.run_in_parallel {
            prefixes.push('>');
        }

        let (action_prefix, template) = match &command_exec.action {
            CommandAction::Print(t) => ("# ".dimmed(), t),
            CommandAction::Execute(t) => ("".normal(), t),
        };

        // assemble_final_command now uses the pre-built resolver
        let rendered_string = task_executor::assemble_final_command(template, config, resolver, 0)?;

        if prefixes.is_empty() {
            println!("{}{}", action_prefix, rendered_string.green());
        } else {
            println!(
                "{} {}{}",
                prefixes.dimmed(),
                action_prefix,
                rendered_string.green()
            );
        }
    }
    println!("---");
    Ok(())
}

/// A helper function to format the project's qualified name for display in the execution header.
/// It truncates long paths for better readability (e.g., `.../parent/child`).
fn format_prefix_path(qualified_name: &str) -> String {
    let mut parts = qualified_name.split('/');
    // Use `nth` to efficiently get the part at a specific index from the end.
    // `rev()` reverses the iterator, `nth(1)` gets the second-to-last element.
    if let Some(second_to_last) = parts.clone().rev().nth(1) {
        // More than 2 parts exist.
        // `parts.last()` is now efficient as `split` is a DoubleEndedIterator.
        let last = parts.next_back().unwrap_or("");
        format!(".../{}/{}", second_to_last, last)
    } else {
        // 1 or 2 parts, return the whole name.
        qualified_name.to_string()
    }
}

===== cli\handlers\start.rs =====
//! # Handler for the `start` command
//!
//! This module provides the logic for the `axes start` command, which initiates an
//! interactive shell session within a project's context. It is responsible for setting up
//! the session, running lifecycle hooks (`at_start`, `at_exit`), and managing parameters.
//!
//! ## Core Logic
//!
//! 1.  **Argument Parsing & Pre-flight Checks**: It parses arguments like the target `context`,
//!     the `--dry-run` flag, and any trailing parameters for the hooks. It also prevents
//!     the creation of nested sessions.
//! 2.  **Configuration & Hook Resolution**: It resolves the project's full configuration to
//!     obtain the `at_start` and `at_exit` tasks defined in the `[options]` table.
//! 3.  **Task Flattening**: Crucially, it flattens both the `at_start` and `at_exit` tasks.
//!     This resolves any script compositions (`<scripts::...>`) within the hooks before
//!     parameters are processed.
//! 4.  **Unified Parameter Resolution**: It collects all parameter definitions (`<params::...>`)
//!     from *both* the start and exit hooks. This allows a single set of parameters passed to
//!     `axes start` to be used in both hooks, creating a consistent session context. An
//!     `ArgResolver` is then built from this unified contract.
//! 5.  **Dispatch**:
//!     - If `--dry-run` is used, it calls `dry_run_session` to print the resolved execution
//!       plan for both hooks without running them.
//!     - Otherwise, it delegates the entire session lifecycle management (init script
//!       generation, shell spawning, cleanup) to the `system::shell::launch_session` function.

use crate::{
    cli::handlers::commons,
    core::{parameters::ArgResolver, task_executor},
    models::{CommandAction, ResolvedConfig, Task, TemplateComponent},
    state::AppStateGuard,
    system::shell,
};
use anyhow::{Result, anyhow};
use clap::Parser;
use colored::*;
use std::sync::Arc;

// --- Command Argument Parsing ---

#[derive(Parser, Debug, Default)]
#[command(
    no_binary_name = true,
    about = "Starts an interactive project session, running `at_start` and `at_exit` hooks."
)]
struct StartArgs {
    /// The context of the project to start a session in. Defaults to the current project.
    context: Option<String>,
    /// Display the `at_start` and `at_exit` hooks without executing them.
    #[arg(long, name = "dry-run")]
    dry_run: bool,
    /// Parameters to pass to the `at_start` and `at_exit` hooks.
    #[arg(trailing_var_arg = true, allow_hyphen_values = true)]
    params: Vec<String>,
}

// --- Main Handler ---

/// The main handler for the `start` command.
///
/// It orchestrates the entire process of setting up a project session, from resolving
/// configuration and hooks to building a unified argument resolver and dispatching to
//  either a dry run or a live session.
///
/// # Arguments
/// * `context` - The project context for the session, provided by the dispatcher.
/// * `args` - Command-specific arguments (e.g., `--dry-run`, and parameters for the hooks).
/// * `index` - A mutable guard to the application state. **Note**: `index` is the parameter name
///   due to a macro limitation and should be treated as `state_guard`.
pub fn handle(
    context: Option<String>,
    args: Vec<String>,
    index: &mut AppStateGuard<'_>,
) -> Result<()> {
    // 1. Parse args and perform pre-flight checks.
    let start_args = StartArgs::try_parse_from(&args)?;

    let final_context = start_args
        .context
        .or(context)
        .unwrap_or_else(|| ".".to_string());

    if std::env::var("AXES_PROJECT_UUID").is_ok() {
        return Err(anyhow!(t!("start.error.nested_session")));
    }

    // 2. Lazily resolve project configuration and get the merged options.
    let config = commons::resolve_config_for_context(Some(final_context), index)?;
    let options = config.get_options()?;
    let task_start = options.at_start;
    let task_exit = options.at_exit;

    // 3. Collect parameter definitions from BOTH hooks for a unified resolver.
    let mut all_definitions = Vec::new();

    // The tasks must be flattened *before* collecting parameters to resolve compositions.
    let flattened_start = if let Some(task) = &task_start {
        Some(config.flatten_task(task)?)
    } else {
        None
    };
    let flattened_exit = if let Some(task) = &task_exit {
        Some(config.flatten_task(task)?)
    } else {
        None
    };

    if let Some(task) = &flattened_start {
        all_definitions.extend(commons::collect_parameter_defs_from_task(task));
    }
    if let Some(task) = &flattened_exit {
        all_definitions.extend(commons::collect_parameter_defs_from_task(task));
    }

    let has_generic_params = flattened_start
        .iter()
        .chain(flattened_exit.iter())
        .flat_map(|task| &task.commands)
        .any(|plat_exec| {
            [
                plat_exec.default.as_ref(),
                plat_exec.windows.as_ref(),
                plat_exec.linux.as_ref(),
                plat_exec.macos.as_ref(),
            ]
            .into_iter()
            .flatten()
            .any(|cmd_exec| {
                let template = match &cmd_exec.action {
                    CommandAction::Execute(t) | CommandAction::Print(t) => t,
                };
                template
                    .iter()
                    .any(|c| matches!(c, TemplateComponent::GenericParams { .. }))
            })
        });

    let resolver = ArgResolver::new(&all_definitions, &start_args.params, has_generic_params)?;

    // 4. Dispatch to either dry-run or actual session launch.
    if start_args.dry_run {
        dry_run_session(&config, flattened_start, flattened_exit, &resolver)
    } else {
        shell::launch_session(&config, flattened_start, flattened_exit, &resolver)
            .map_err(Into::into)
    }
}

// --- Subcommand Logic ---

/// Displays the fully-resolved execution plan for the `at_start` and `at_exit` hooks
/// without actually executing them.
///
/// # Arguments
/// * `config` - The resolved configuration of the project.
/// * `task_start` - The flattened `at_start` task.
/// * `task_exit` - The flattened `at_exit` task.
/// * `resolver` - The unified argument resolver for the session.
fn dry_run_session(
    config: &ResolvedConfig,
    task_start: Option<Arc<Task>>,
    task_exit: Option<Arc<Task>>,
    resolver: &ArgResolver<'_>,
) -> Result<()> {
    println!(
        "\n📋 Dry-run for session in '{}'",
        config.qualified_name.cyan()
    );

    display_hook_plan("at_start", task_start, config, resolver)?;
    display_hook_plan("at_exit", task_exit, config, resolver)?;

    Ok(())
}

/// A helper for `dry_run_session` that displays the execution plan for a single hook.
///
/// # Arguments
/// * `hook_name` - The name of the hook being displayed (e.g., "`at_start`").
/// * `task` - The flattened `Task` for the hook.
/// * `config` - The resolved configuration of the project.
/// * `resolver` - The unified argument resolver.
fn display_hook_plan(
    hook_name: &str,
    task: Option<Arc<Task>>,
    config: &ResolvedConfig,
    resolver: &ArgResolver<'_>,
) -> Result<()> {
    println!("\n--- Hook: [{}] ---", hook_name.yellow());

    let task = match task {
        Some(t) => t,
        None => {
            println!("{}", "Not defined.".dimmed());
            return Ok(());
        }
    };

    if task.commands.is_empty() {
        println!("{}", "Defined but empty.".dimmed());
        return Ok(());
    }

    // Iterate over the universal AST and render the command for the current platform.
    for plat_exec in &task.commands {
        if let Some(command_exec) = config.select_platform_exec(plat_exec) {
            let (action_prefix, template) = match &command_exec.action {
                CommandAction::Print(t) => ("# ".dimmed(), t),
                CommandAction::Execute(t) => ("".normal(), t),
            };
            let rendered_string =
                task_executor::assemble_final_command(template, config, resolver, 0)?;
            println!("{}{}", action_prefix, rendered_string.green());
        }
    }
    Ok(())
}

===== cli\handlers\tree.rs =====
//! # Handler for the `tree` command
//!
//! This module provides the logic for the `axes tree` command (aliased as `ls`), which
//! renders a visual representation of the project hierarchy.
//!
//! ## Core Logic
//!
//! 1.  **Argument Parsing**: It parses a variety of display-modifying flags, such as `--paths`,
//!     `--uuids`, `--depth`, and `--check`, which control the level of detail in the output.
//!     It also accepts an optional `context` to root the tree display at a specific project.
//! 2.  **Context Resolution**: If a `context` is provided, it uses the `context_resolver` to
//!     find the starting project's UUID. This is a potentially mutable operation as it
//!     updates `last_used` metadata in the index. If no context is given, it defaults to
//!     displaying the entire project tree from the "global" project root.
//! 3.  **Options Assembly**: It constructs a `DisplayOptions` struct from the parsed arguments
//!     to configure the tree renderer.
//! 4.  **Delegation**: It delegates the entire rendering process to the `graph_display` module,
//!     passing the index, the starting node, and the display options.

use anyhow::Result;
use clap::Parser;

use crate::{
    core::{
        context_resolver,
        graph_display::{self, DisplayOptions},
    },
    state::AppStateGuard,
};
use colored::Colorize;

#[derive(Parser, Debug, Default)]
#[command(
    no_binary_name = true,
    about = "Displays the project hierarchy as a tree."
)]
struct TreeArgs {
    /// The project context to use as the root of the tree. Defaults to the full tree.
    context: Option<String>,

    /// Show the full absolute paths for each project.
    #[arg(long, short)]
    paths: bool,

    /// Show the UUID for each project.
    #[arg(long, short)]
    uuids: bool,

    /// Show all available information (paths and UUIDs).
    #[arg(long)]
    all: bool,

    /// Limit the depth of the tree display.
    #[arg(long, short)]
    depth: Option<usize>,

    /// Check if the project paths exist on the filesystem.
    #[arg(long)]
    check: bool,
}

/// The main handler for the `tree` command.
///
/// It parses display options, resolves the starting context (if any), and then
/// delegates the actual rendering logic to the `graph_display` module.
///
/// # Arguments
/// * `context` - An optional context from the dispatcher to root the tree.
/// * `args` - Command-specific arguments for display options.
/// * `state_guard` - A mutable guard to the application state, needed for context resolution.
pub fn handle(
    context: Option<String>,
    args: Vec<String>,
    state_guard: &mut AppStateGuard<'_>,
) -> Result<()> {
    // 1. Parse this handler's specific arguments.
    let tree_args = TreeArgs::try_parse_from(&args)?;

    // 2. Determine the definitive context with clear priority: cli arg > dispatcher context.
    let final_context = tree_args.context.or(context);

    // 3. Resolve the start node and prepare the UI header based on the context.
    let (start_node_uuid, header) = match final_context {
        Some(context_str) => {
            let (uuid, qualified_name) =
                context_resolver::resolve_context(&context_str, state_guard)?;
            let header_text = format!(t!("tree.header.from_project"), name = qualified_name.cyan());
            (Some(uuid), header_text)
        }
        None => {
            // No context provided, display the full tree from the global project.
            (None, t!("tree.header.full_tree").to_string())
        }
    };

    // 4. Set display options based on flags.
    let display_options = DisplayOptions {
        show_paths: tree_args.paths || tree_args.all,
        show_uuids: tree_args.uuids || tree_args.all,
        max_depth: tree_args.depth,
        show_health: tree_args.check,
    };

    // 5. Delegate to the graph display module for rendering.
    println!("\n{}", header);
    graph_display::display_project_tree(state_guard.index(), start_node_uuid, &display_options);

    Ok(())
}

===== cli\handlers\unregister.rs =====
//! # Handler for the `unregister` command
//!
//! This module provides the logic for the `axes unregister` command. This is a non-destructive
//! operation that removes one or more projects from the `GlobalIndex` but leaves all their
//! files on the filesystem untouched. It's the inverse of `axes register`.
//!
//! ## Core Logic
//!
//! 1.  **Argument Parsing & Resolution**: It parses arguments like `--recursive` and `--reparent-to`
//!     and resolves the target project context.
//! 2.  **Planning**: It uses the shared `commons::prepare_operation_plan` utility to perform a
//!     "dry run" of the unregister operation. Crucially, it passes `is_destructive: false` to
//!     ensure the plan does not include any filesystem paths to be purged.
//! 3.  **Confirmation**: The `confirm_unregister_operation` function presents the detailed plan to the
//!     user, listing exactly which projects will be removed from the index, and requires explicit
//!     confirmation to proceed.
//! 4.  **Execution**: The `execute_unregister_plan` function performs the necessary mutations on the
//!     `GlobalIndex`:
//!     - If the operation is not recursive, it first reparents the direct children of the
//!       target project to a new parent (or to the "global" project by default).
//!     - It then removes all targeted project UUIDs from the index.

use anyhow::{Result, anyhow};
use clap::Parser;
use colored::*;
use dialoguer::{Confirm, theme::ColorfulTheme};

use crate::{
    cli::handlers::commons,
    core::{context_resolver, index_manager},
    models::{GlobalIndex, ResolvedConfig},
    state::AppStateGuard,
};

// --- Command Argument Parsing ---

#[derive(Parser, Debug, Default)]
#[command(
    no_binary_name = true,
    about = "Removes a project and its descendants from the axes index without deleting files."
)]
struct UnregisterArgs {
    /// The context of the project to unregister.
    context: Option<String>,

    /// Unregisters the project and ALL its descendants recursively.
    #[arg(long)]
    recursive: bool,

    /// Instead of unregistering direct children, reparents them to a new project.
    #[arg(long, conflicts_with = "recursive")]
    reparent_to: Option<String>,
}

// --- Main Handler ---

/// The main handler for the `unregister` command.
///
/// It orchestrates the four main phases: parsing arguments, planning the operation,
/// confirming with the user, and executing the changes in the index.
///
/// # Arguments
/// * `context` - The context of the project to unregister, provided by the dispatcher.
/// * `args` - Command-specific arguments (e.g., `--recursive`).
/// * `state_guard` - A mutable guard to the application state.
pub fn handle(
    context: Option<String>,
    args: Vec<String>,
    state_guard: &mut AppStateGuard<'_>,
) -> Result<()> {
    // 1. Parse & Resolve
    let unregister_args = UnregisterArgs::try_parse_from(&args)?;
    let final_context = unregister_args
        .context
        .or(context)
        .ok_or_else(|| anyhow!(t!("error.context_required"), command = "unregister"))?;
    let config = commons::resolve_config_for_context(Some(final_context), state_guard)?;

    if config.uuid == index_manager::GLOBAL_PROJECT_UUID {
        return Err(anyhow!(t!("unregister.error.cannot_unregister_global")));
    }

    // 2. Plan
    let plan = commons::prepare_operation_plan(
        state_guard,
        &config,
        unregister_args.recursive,
        unregister_args.reparent_to.clone(),
        false, // is_destructive
    )?;

    // 3. Confirm
    if !confirm_unregister_operation(state_guard.index(), &plan)? {
        return Ok(());
    }

    // 4. Execute
    execute_unregister_plan(
        state_guard,
        &config,
        &plan,
        unregister_args.recursive,
        &unregister_args.reparent_to,
    )?;

    Ok(())
}

/// Displays the operational plan to the user and asks for explicit confirmation before proceeding.
///
/// # Arguments
/// * `index` - An immutable reference to the `GlobalIndex` for reading project details.
/// * `plan` - The `OperationPlan` generated by `prepare_operation_plan`.
///
/// # Returns
/// `Ok(true)` if the user confirms, `Ok(false)` if they cancel.
fn confirm_unregister_operation(
    index: &GlobalIndex,
    plan: &commons::OperationPlan,
) -> Result<bool> {
    println!("\n{}", t!("unregister.info.header").yellow().bold());
    for line in &plan.summary_lines {
        println!("  - {}", line);
    }

    println!("\n{}", t!("unregister.info.projects_to_remove").dimmed());
    for uuid in &plan.uuids_to_remove {
        if let Some(entry) = index.projects.get(uuid) {
            let qualified_name = index_manager::build_qualified_name(*uuid, index)
                .unwrap_or_else(|| entry.name.clone());
            println!("    • {} ({})", qualified_name.cyan(), entry.path.display());
        }
    }

    if !Confirm::with_theme(&ColorfulTheme::default())
        .with_prompt(t!("common.prompt.continue"))
        .default(false)
        .interact()?
    {
        println!("\n{}", t!("common.info.operation_cancelled"));
        return Ok(false);
    }
    Ok(true)
}

/// Encapsulates the state-mutating logic that is executed after the user has confirmed the plan.
///
/// It handles the reparenting of children (if applicable) and the final removal of project
/// entries from the `GlobalIndex`.
///
/// # Arguments
/// * `state_guard` - A mutable guard to the application state.
/// * `config` - The resolved configuration of the primary target project.
/// * `plan` - The confirmed `OperationPlan` to be executed.
/// * `is_recursive` - A boolean indicating if the operation is recursive.
/// * `reparent_to` - An optional context string for the new parent.
fn execute_unregister_plan(
    state_guard: &mut AppStateGuard<'_>,
    config: &ResolvedConfig,
    plan: &commons::OperationPlan,
    is_recursive: bool,
    reparent_to: &Option<String>,
) -> Result<()> {
    log::info!(
        "Executing unregister plan for project '{}' ({})",
        config.qualified_name,
        config.uuid
    );

    let mut all_warnings = plan.reparent_warnings.clone();

    if !is_recursive {
        let new_parent_uuid = reparent_to
            .as_ref()
            .map(|ctx| context_resolver::resolve_context(ctx, state_guard).map(|(uuid, _)| uuid))
            .transpose()?
            .unwrap_or(index_manager::GLOBAL_PROJECT_UUID);

        log::debug!(
            "Reparenting children of '{}' to '{}'",
            config.uuid,
            new_parent_uuid
        );
        let reparent_op_warnings = index_manager::reparent_children(
            state_guard.index_mut(),
            config.uuid,
            new_parent_uuid,
        )?;
        all_warnings.extend(reparent_op_warnings);
    }

    log::debug!(
        "Removing {} UUID(s) from the index.",
        plan.uuids_to_remove.len()
    );
    let removed_count =
        index_manager::remove_from_index(state_guard.index_mut(), &plan.uuids_to_remove);

    println!(
        "\n{} {}",
        t!("common.success").green().bold(),
        format_args!(t!("unregister.success.header"), count = removed_count)
    );
    for warning in all_warnings {
        println!("  - {}", warning.yellow());
    }
    Ok(())
}

===== cli\mod.rs =====
//! # Command-Line Interface (CLI) Module
//!
//! This module serves as the main entry point for parsing and defining the application's
//! command-line interface. It uses the `clap` crate to define the top-level `Cli` struct
//! and orchestrates the custom help message generation.
//!
//! ## Modules
//!
//! - **`dispatcher`**: Contains the core logic for parsing the application's "universal grammar"
//!   and routing commands to the appropriate handlers.
//! - **`handlers`**: A collection of sub-modules, each responsible for the logic of a specific
//!   `axes` command (e.g., `run`, `init`, `tree`).
//!
//! ## Custom Help Message
//!
//! This module is responsible for building a dynamic, color-aware, and richly formatted
//! help message. The `build_help_string()` function replaces simple placeholders in a
//! template with ANSI color codes, providing a more user-friendly and readable output than
//! the default `clap` help screen.

use clap::Parser;

pub mod dispatcher;
pub mod handlers;

/// Builds the dynamic, color-aware full help string at runtime.
///
/// This function acts as a mini-renderer for our semantic help template, which is defined
/// in the localization files (e.g., `locales/en.toml`). It replaces placeholders like
/// `<title>` and `<cmd>` with the appropriate ANSI escape codes for color and style, but
/// only if color output is enabled for the terminal. This ensures a beautiful help
/// message on supported terminals and a clean, readable one on others.
fn build_help_string() -> &'static str {
    // This function acts as a mini-renderer for our semantic help template.
    // It replaces placeholders like `<title>` with colored/styled text.

    let use_colors = colored::control::SHOULD_COLORIZE.should_colorize();

    let template = t!("cli.help.template");

    // Define styles. If colors are disabled, they are empty strings.
    let title = if use_colors { "\x1b[1;33m" } else { "" }; // Bold Yellow
    let hl = if use_colors { "\x1b[1;36m" } else { "" }; // Bold Cyan (for highlights)
    let hi = if use_colors { "\x1b[1;20m" } else { "" }; // Bold Cyan (for highlights)
    let cmd = if use_colors { "\x1b[36m" } else { "" }; // Cyan (for commands)
    let group = if use_colors { "\x1b[1;32m" } else { "" }; // Bold Green
    let err = if use_colors { "\x1b[91m" } else { "" }; // Bright Red (for destructive)
    let dim = if use_colors { "\x1b[2m" } else { "" }; // Dim
    let reset = if use_colors { "\x1b[0m" } else { "" };

    // Perform replacements in a single, chained expression.
    let formatted_string = template
        .replace("<title>", title)
        .replace("</title>", reset)
        .replace("<hl>", hl)
        .replace("</hl>", reset)
        .replace("<hi>", hi)
        .replace("</hi>", reset)
        .replace("<cmd>", cmd)
        .replace("</cmd>", reset)
        .replace("<group>", group)
        .replace("</group>", reset)
        .replace("<err>", err)
        .replace("</err>", reset)
        .replace("<dim>", dim)
        .replace("</dim>", reset);

    Box::leak(formatted_string.into_boxed_str())
}

/// The root of the command-line interface, defined using `clap`.
///
/// This struct captures all arguments passed to `axes` into a single `Vec<String>`.
/// It intentionally avoids defining subcommands at this top level. Instead, the raw
/// arguments are passed to the `dispatcher` module, which implements a more flexible,
/// universal grammar for command parsing. This approach allows for context-sensitive
/// commands and implicit actions (like `axes my-script` being a shortcut for `axes . run my-script`).
#[derive(Parser, Debug)]
#[command(
    //author,
    version,
    about,
    // Use `help_template` to take full control of the output.
    help_template = { build_help_string() },
    // Custom styles for auto-generated parts (not used now, but good to keep for future)
    styles = clap::builder::Styles::styled()
        .header(clap::builder::styling::AnsiColor::Yellow.on_default().bold())
        .usage(clap::builder::styling::AnsiColor::Yellow.on_default().bold())
        .literal(clap::builder::styling::AnsiColor::Cyan.on_default().bold())
        .placeholder(clap::builder::styling::AnsiColor::Green.on_default()),
)]
#[command(disable_help_subcommand = true)]
#[command(trailing_var_arg = true)]
pub struct Cli {
    /// A catch-all for the entire sequence of arguments passed to `axes`.
    /// This vector is passed directly to the dispatcher for parsing according to the
    /// application's universal grammar.
    #[arg()]
    pub args: Vec<String>,
}

===== constants.rs =====
//! # Constants
//!
//! This module defines various constants used throughout the application, such as file names,
//! directory names, and limits.

/// The name of the directory containing axes configuration for a project.
pub const AXES_DIR: &str = ".axes";

/// The name of the main configuration file for a project (inside .axes/).
pub const PROJECT_CONFIG_FILENAME: &str = "axes.toml";

/// The name of the global index file (in ~/.config/axes/).
pub const GLOBAL_INDEX_FILENAME: &str = "index.bin";

/// The name of the file containing a project's identity and references.
pub const PROJECT_REF_FILENAME: &str = "project_ref.bin";

/// The maximum depth for recursion when resolving configurations or executing scripts.
pub const MAX_RECURSION_DEPTH: u32 = 32;

===== core\cache.rs =====
//! # Cache
//!
//! This module provides utilities for caching data, including calculating validation data for cache
//! entries.

use anyhow::{Context, Result};
use std::io::Read;
use std::{fs, path::Path, time::SystemTime};

/// The length to truncate the hash to, in bytes. 16 bytes = 32 hex characters.
const HASH_TRUNCATE_LENGTH: usize = 16;
/// The buffer size for streaming I/O when hashing files, in bytes. 8KB.
const HASH_BUFFER_SIZE: usize = 8192;

// In src/core/cache.rs

/// Represents the validation metadata for a cache entry.
/// This layered approach allows for fast checks before resorting to hashing.
#[derive(Debug, PartialEq, Eq)]
pub struct CacheValidationData {
    /// The last modification timestamp of the source file (`axes.toml`).
    pub timestamp: SystemTime,
    /// The size of the source file in bytes.
    pub file_size: u64,
    /// The BLAKE3 content hash of the source file, truncated for brevity.
    pub content_hash: String,
}

/// Calculates the validation metadata for a given file path.
///
/// This function implements a multi-layered validation strategy for performance:
/// 1. Timestamp (modified time)
/// 2. File size
/// 3. Content Hash (blake3)
///
/// # Returns
///
/// A `Result` containing the `CacheValidationData` on success, or an error if the file
/// cannot be read or its metadata cannot be accessed.
///
/// # Errors
///
/// Returns an I/O error if the file cannot be read or its metadata cannot be accessed.
pub fn calculate_validation_data(path: &Path) -> Result<CacheValidationData> {
    // ROBUSTNESS: Add a log at the function entry with a clear name.
    log::trace!("Calculating validation data for '{}'", path.display());

    // Layer 1: Filesystem metadata (fast check).
    let metadata = fs::metadata(path)
        .with_context(|| format!("Failed to read metadata for file '{}'", path.display()))?;

    let timestamp = metadata
        .modified()
        .context("Filesystem does not support modification timestamps.")?;
    let file_size = metadata.len();

    // Layer 2: Content Hash (definitive check).
    // Use streaming hashing to handle large files efficiently without
    // loading them entirely into memory.
    let mut file = fs::File::open(path)
        .with_context(|| format!("Failed to open file for hashing '{}'", path.display()))?;

    let mut hasher = blake3::Hasher::new();

    // Use a buffer to read the file in chunks.
    // 8KB is a common and efficient buffer size for I/O.
    let mut buffer = [0; HASH_BUFFER_SIZE];
    loop {
        let bytes_read = file.read(&mut buffer)?;
        if bytes_read == 0 {
            break;
        }
        hasher.update(
            buffer
                .get(..bytes_read)
                .expect("bytes_read should be within buffer bounds"),
        );
    }

    let hash = hasher.finalize();
    let content_hash = hex::encode(&hash.as_bytes()[..HASH_TRUNCATE_LENGTH]);

    log::debug!(
        "Validation data for '{}': size={}, hash={}",
        path.display(),
        file_size,
        content_hash
    );

    Ok(CacheValidationData {
        timestamp,
        file_size,
        content_hash,
    })
}

#[cfg(test)]
mod tests {
    #![allow(clippy::panic)]
    use super::*;
    use std::io::Write;
    use tempfile::NamedTempFile;

    #[test]
    fn test_calculate_validation_data_success() {
        // --- Setup ---
        let content = b"hello world"; // Use a byte string literal
        let mut temp_file =
            NamedTempFile::new().expect("Should be able to create a temp file in tests");

        // Use `write_all` to write the exact bytes without any translation.
        temp_file
            .write_all(content)
            .expect("Should be able to write to temp file");
        temp_file
            .flush()
            .expect("Should be able to flush temp file"); // Ensure data is written to disk before reading metadata

        // --- Execute ---
        let result = calculate_validation_data(temp_file.path());

        // --- Assert ---
        assert!(result.is_ok());
        let data = result.expect("Validation data should be calculated successfully");

        assert_eq!(data.file_size, 11);

        // Pre-calculated blake3 hash of the bytes "hello world", truncated to 16 bytes.
        // This hash is now platform-independent and correct.
        let expected_hash = "d74981efa70a0c880b8d8c1985d075db";

        assert_eq!(data.content_hash, expected_hash);

        // Timestamp check (can be brittle, just check it's recent)
        let now = SystemTime::now();
        let difference = now
            .duration_since(data.timestamp)
            .expect("System time should be after file timestamp");
        assert!(difference.as_secs() < 5);
    }

    #[test]
    fn test_calculate_validation_data_file_not_found() {
        // --- Setup ---
        let non_existent_path = Path::new("non_existent_file_for_test.tmp");

        // --- Execute ---
        let result = calculate_validation_data(non_existent_path);

        // --- Assert ---
        assert!(result.is_err());
    }
}

===== core\color.rs =====
//! # Color
//!
//! This module provides utilities for parsing and converting ANSI color styles.

use crate::models::AnsiStyle;
use anyhow::{Result, anyhow};

/// Parses a style name string (e.g., "red", "bold", "bright-green") into an `AnsiStyle` enum.
/// The parsing is case-insensitive.
///
/// # Returns
///
/// A `Result` containing the `AnsiStyle` on success, or an error if the style name is unknown.
pub fn parse_style_name(name: &str) -> Result<AnsiStyle> {
    match name.to_lowercase().replace('_', "-").as_str() {
        // Attributes
        "reset" => Ok(AnsiStyle::Reset),
        "bold" => Ok(AnsiStyle::Bold),
        "dim" => Ok(AnsiStyle::Dim),
        "italic" => Ok(AnsiStyle::Italic),
        "underline" => Ok(AnsiStyle::Underline),

        // Standard Colors
        "black" => Ok(AnsiStyle::Black),
        "red" => Ok(AnsiStyle::Red),
        "green" => Ok(AnsiStyle::Green),
        "yellow" => Ok(AnsiStyle::Yellow),
        "blue" => Ok(AnsiStyle::Blue),
        "magenta" => Ok(AnsiStyle::Magenta),
        "cyan" => Ok(AnsiStyle::Cyan),
        "white" => Ok(AnsiStyle::White),

        // Bright Colors (with multiple name variants for user convenience)
        "bright-black" | "gray" | "grey" => Ok(AnsiStyle::BrightBlack),
        "bright-red" => Ok(AnsiStyle::BrightRed),
        "bright-green" => Ok(AnsiStyle::BrightGreen),
        "bright-yellow" => Ok(AnsiStyle::BrightYellow),
        "bright-blue" => Ok(AnsiStyle::BrightBlue),
        "bright-magenta" => Ok(AnsiStyle::BrightMagenta),
        "bright-cyan" => Ok(AnsiStyle::BrightCyan),
        "bright-white" => Ok(AnsiStyle::BrightWhite),

        // Handle legacy `AnsiStyle` enum name in error messages if we rename it.
        _ => Err(anyhow!("Unknown style token: '<#{}>'", name)),
    }
}

/// Converts an `AnsiStyle` enum into its raw ANSI escape code representation.
///
/// # Returns
///
/// A `&'static str` containing the ANSI escape code for the given style.
pub fn style_to_ansi_code(style: AnsiStyle) -> &'static str {
    match style {
        // Attributes
        AnsiStyle::Reset => "\x1b[0m",
        AnsiStyle::Bold => "\x1b[1m",
        AnsiStyle::Dim => "\x1b[2m",
        AnsiStyle::Italic => "\x1b[3m",
        AnsiStyle::Underline => "\x1b[4m",

        // Standard Colors
        AnsiStyle::Black => "\x1b[30m",
        AnsiStyle::Red => "\x1b[31m",
        AnsiStyle::Green => "\x1b[32m",
        AnsiStyle::Yellow => "\x1b[33m",
        AnsiStyle::Blue => "\x1b[34m",
        AnsiStyle::Magenta => "\x1b[35m",
        AnsiStyle::Cyan => "\x1b[36m",
        AnsiStyle::White => "\x1b[37m",

        // Bright (Intense) Colors
        AnsiStyle::BrightBlack => "\x1b[90m",
        AnsiStyle::BrightRed => "\x1b[91m",
        AnsiStyle::BrightGreen => "\x1b[92m",
        AnsiStyle::BrightYellow => "\x1b[93m",
        AnsiStyle::BrightBlue => "\x1b[94m",
        AnsiStyle::BrightMagenta => "\x1b[95m",
        AnsiStyle::BrightCyan => "\x1b[96m",
        AnsiStyle::BrightWhite => "\x1b[97m",
    }
}

===== core\commons.rs =====
//! # Commons
//!
//! This module contains common utility functions that are used throughout the application.

/// Wraps a string in quotes and escapes any internal quotes.
///
/// # Arguments
///
/// * `value` - The string to wrap in quotes.
///
/// # Returns
///
/// A new string that is wrapped in quotes, with any internal quotes escaped.
pub fn wrap_value(value: &str) -> String {
    // Escape any existing double quotes and then wrap the whole string in double quotes.
    format!("\"{}\"", value.replace('"', "\\\""))
}

===== core\compiler.rs =====
//! # Compiler
//!
//! This module is responsible for the Ahead-of-Time (AOT) compilation of `axes.toml` files.
//! Its primary goal is to transform the user-friendly, flexible TOML syntax into a
//! platform-agnostic, optimized Abstract Syntax Tree (AST) that can be cached and executed efficiently.

use crate::{
    core::{cache, color, parameters, paths}, dev_utils::{self, BlockTimer}, models::{
        CachedOpenWithConfig, CachedOptionsConfig, CachedProjectConfig, CachedVar, CommandAction,
        CommandExecution, GlobalIndex, IndexEntry, IndexUpdate, PlatformCommand, PlatformExecution,
        ProjectConfig, RunSpec, Task, TemplateComponent, TomlCommand, TomlScript, TomlVar,
        TomlVarValue,
    }
};
use anyhow::{Context, Result, anyhow};
use lazy_static::lazy_static;
use lz4_flex;
use regex::Regex;
use std::{collections::HashMap, fs, path::PathBuf};
use thiserror::Error;
use uuid::Uuid;

lazy_static! {
    // Regex to capture potential tokens, with an optional escape character `\`.
    static ref TOKEN_RE: Regex = Regex::new(r"\\?<([^>]+)>")
    .expect("Compiler Regex should be valid");
}

/// Represents errors that can occur during the compilation of `axes.toml` files.
#[derive(Error, Debug)]
pub enum CompilerError {
    /// An I/O error occurred while reading the configuration file.
    #[error("I/O error while processing configuration: {0}")]
    Io(#[from] std::io::Error),
    /// The TOML content of `axes.toml` is invalid and could not be parsed.
    #[error("Failed to parse TOML file at '{path}': {source}")]
    TomlParse {
        /// The path to the file that failed to parse.
        path: std::path::PathBuf,
        /// The underlying parsing error from the `toml` crate.
        #[source]
        source: toml::de::Error,
    },
}

// --- PUBLIC COMPILER API ---

/// Compiles a user-facing `TomlScript` into a platform-agnostic `Task` (AST).
/// This is the main entry point for script compilation.
///
/// # Arguments
///
/// * `toml_script` - The `TomlScript` to compile.
///
/// # Returns
///
/// A `Result` containing the compiled `Task` on success, or an error if compilation fails.
pub fn compile_script(toml_script: TomlScript) -> Result<Task> {
    match toml_script {
        TomlScript::Simple(s) => {
            let platform_exec = compile_toml_command_to_platform_execution(TomlCommand::Simple(s))
                .context("Failed to compile simple script string")?;
            Ok(Task {
                desc: None,
                commands: vec![platform_exec],
            })
        }
        TomlScript::Sequence(commands) => {
            let compiled_commands = commands
                .into_iter()
                .map(compile_toml_command_to_platform_execution)
                .collect::<Result<Vec<_>>>()?;
            Ok(Task {
                desc: None,
                commands: compiled_commands,
            })
        }
        TomlScript::Platform(pc) => {
            let platform_exec = compile_platform_command_to_platform_execution(pc, true)?;
            Ok(Task {
                desc: None,
                commands: vec![platform_exec],
            })
        }
        TomlScript::PlatformDirect(pd) => {
            // This is simple: we have a platform block and a description.
            // We compile the platform block into a single PlatformExecution.
            let platform_exec = compile_platform_command_to_platform_execution(pd.platform, true)?;
            // And create a Task with that single command.
            Ok(Task {
                desc: pd.desc,
                commands: vec![platform_exec],
            })
        }
        TomlScript::Extended(ext) => {
            // Recursively compile the `run` field, which is a TomlScript.
            let mut task = compile_script(*ext.run)
                .with_context(|| "Failed to compile 'run' field of extended script")?;
            // Then, assign the description from the outer table.
            task.desc = ext.desc;
            Ok(task)
        }
    }
}

/// Compiles a user-facing `TomlVar` into a platform-agnostic `CachedVar` (AST).
/// This is the main entry point for variable compilation.
///
/// # Arguments
///
/// * `toml_var` - The `TomlVar` to compile.
///
/// # Returns
///
/// A `Result` containing the compiled `CachedVar` on success, or an error if compilation fails.
pub fn compile_var(toml_var: TomlVar) -> Result<CachedVar> {
    match toml_var {
        TomlVar::Simple(s) => {
            // A simple string is a value for the `default` platform.
            // Action prefixes are NOT parsed for variables.
            let command_exec = compile_string_to_command_execution(&s, false)?;
            Ok(CachedVar {
                desc: None,
                value: PlatformExecution {
                    default: Some(command_exec),
                    ..Default::default()
                },
            })
        }
        TomlVar::Extended(ext) => {
            let platform_exec = match ext.value {
                TomlVarValue::Simple(s) => {
                    let command_exec = compile_string_to_command_execution(&s, false)?;
                    PlatformExecution {
                        default: Some(command_exec),
                        ..Default::default()
                    }
                }
                TomlVarValue::Platform(platform_block) => {
                    compile_platform_command_to_platform_execution(platform_block, false)?
                }
            };
            Ok(CachedVar {
                desc: ext.desc,
                value: platform_exec,
            })
        }
    }
}

// --- MAIN TASK LOGIC (called by ConfigLoader) ---

/// The main entry point for compiling a project layer from `axes.toml` to `CachedProjectConfig`.
///
/// # Arguments
///
/// * `entry` - The `IndexEntry` for the project to compile.
///
/// # Returns
///
/// A `Result` containing the compiled `CachedProjectConfig` on success, or an error if compilation fails.
pub fn load_and_compile_layer(entry: &IndexEntry) -> Result<CachedProjectConfig> {
    let config_path = entry.path.join(".axes").join("axes.toml");
    if !config_path.exists() {
        return Ok(CachedProjectConfig::default());
    }

    let content = fs::read_to_string(&config_path)?;
    let project_config: ProjectConfig =
        toml::from_str(&content).map_err(|e| CompilerError::TomlParse {
            path: config_path,
            source: e,
        })?;

    // --- Compile each section with detailed error context ---

    let scripts = project_config
        .scripts
        .into_iter()
        .map(|(name, ts)| {
            compile_script(ts)
                .with_context(|| format!("Failed to compile script '{}'", name))
                // FIX: Keep the name to form a (key, value) tuple for the HashMap
                .map(|task| (name, task))
        })
        .collect::<Result<HashMap<_, _>>>()
        .context("Error compiling [scripts] section")?;

    let vars = project_config
        .vars
        .into_iter()
        .map(|(name, tv)| {
            compile_var(tv)
                .with_context(|| format!("Failed to compile var '{}'", name))
                // FIX: Keep the name to form a (key, value) tuple for the HashMap
                .map(|cvar| (name, cvar))
        })
        .collect::<Result<HashMap<_, _>>>()
        .context("Error compiling [vars] section")?;

    let open_with_commands = project_config
        .options
        .open_with
        .commands
        .into_iter()
        .map(|(name, ts)| {
            compile_script(ts)
                .with_context(|| format!("Failed to compile open_with command '{}'", name))
                // FIX: Keep the name to form a (key, value) tuple for the HashMap
                .map(|task| (name, task))
        })
        .collect::<Result<HashMap<_, _>>>()
        .context("Error compiling [options.open_with] commands")?;

    let cached_options = CachedOptionsConfig {
        at_start: project_config
            .options
            .at_start
            .map(compile_script)
            .transpose()
            .context("Error compiling [options.at_start]")?,
        at_exit: project_config
            .options
            .at_exit
            .map(compile_script)
            .transpose()
            .context("Error compiling [options.at_exit]")?,
        shell: project_config.options.shell,
        cache_dir: project_config.options.cache_dir,
        prompt: project_config.options.prompt,
        open_with: CachedOpenWithConfig {
            default: project_config.options.open_with.default,
            commands: open_with_commands,
        },
    };

    Ok(CachedProjectConfig {
        version: project_config.version,
        description: project_config.description,
        scripts,
        vars,
        env: project_config.env,
        options: cached_options,
    })
}

/// The task executed in parallel by `ConfigLoader` for each layer in the hierarchy.
/// It handles cache validation (hit/miss) and triggers re-compilation if necessary.
///
/// # Arguments
///
/// * `uuid` - The UUID of the project to load.
/// * `index` - A reference to the `GlobalIndex`.
///
/// # Returns
///
/// A `Result` containing a tuple of the loaded `CachedProjectConfig` and an optional `IndexUpdate`
/// on success, or an error if loading fails.
pub fn load_layer_task(
    uuid: Uuid,
    index: &GlobalIndex,
) -> Result<(std::sync::Arc<CachedProjectConfig>, Option<IndexUpdate>)> {
    let _timer = dev_utils::BlockTimer::new(format!("        ----> load_layer_task (UUID: {})", uuid));
    log::debug!("Executing load task for UUID: {}", uuid);
    let entry = index
        .projects
        .get(&uuid)
        .ok_or_else(|| anyhow!("Project UUID {} not found in index.", uuid))?;

    let config_path = entry.path.join(".axes").join("axes.toml");
    let current_toml_hash = if config_path.exists() {
        let _timer_vh = dev_utils::BlockTimer::new("          -----> Cache Validation (Hashing)");
        cache::calculate_validation_data(&config_path)?.content_hash
    } else {
        // Use a consistent hash for non-existent or empty files.
        "empty".to_string()
    };

    log::trace!(
        "Layer '{}' at '{}' has content hash: {}",
        entry.name,
        entry.path.display(),
        current_toml_hash
    );

    // --- CACHE HIT ATTEMPT ---

    let cache_dir_to_check = entry.cache_dir.clone().unwrap_or_else(|| {
        paths::get_default_cache_dir_for_project(uuid)
            .expect("Default cache dir should always be resolvable")
    });

    if let Some(saved_hash) = &entry.config_hash
        && saved_hash == &current_toml_hash
    {
        let cache_file_path = cache_dir_to_check.join(saved_hash);
        let _timer_cr = dev_utils::BlockTimer::new("          -----> Cache Hit (Read & Decompress)");
        if let Ok(cached_layer) = read_cached_layer(&cache_file_path) {
            log::debug!(
                "Cache HIT for layer '{}' at '{}'.",
                entry.name,
                cache_file_path.display()
            );
            return Ok((std::sync::Arc::new(cached_layer), None));
        }
        log::warn!(
            "Cache file for '{}' missing or corrupt. Forcing re-compilation.",
            entry.name
        );
    }

    // --- CACHE MISS: RECOMPILE ---
    log::debug!("Cache MISS for layer '{}'. Recompiling.", entry.name);

    let _timer_cm = dev_utils::BlockTimer::new("          -----> Cache Miss (Compile & Write)");
    let new_layer = {let _timer_c = dev_utils::BlockTimer::new("            ------> Compile Layer");load_and_compile_layer(entry)?};

    // We just return an IndexUpdate with the new hash. The ConfigLoader will handle the rest.
    let update = IndexUpdate {
        uuid,
        new_hash: current_toml_hash,
        // We leave the final cache_dir path to be resolved by the ConfigLoader.
        new_cache_dir: PathBuf::new(),
    };

    // We still need to write the new cache file somewhere. We'll use the path we checked.
    let new_cache_file_path = cache_dir_to_check.join(&update.new_hash);
    let _timer_w = dev_utils::BlockTimer::new("            ------> Write Cache");
    write_cached_layer(&new_cache_file_path, &new_layer)?;

    Ok((std::sync::Arc::new(new_layer), Some(update)))
}

// --- HELPER IMPLEMENTATIONS ---

/// A struct to hold the parsed execution prefixes from a command string.
#[derive(Debug, Default)]
pub struct Prefixes {
    /// Ignore errors.
    pub ignore_errors: bool,
    /// Run in parallel.
    pub run_in_parallel: bool,
    /// Silent mode.
    pub silent_mode: bool,
    /// Represents the '#' prefix.
    pub is_echo: bool,
}

/// Parses `axes` execution prefixes (`@`, `-`, `>`, `#`) from the start of a line.
/// Returns the parsed prefixes and a slice of the string containing the actual command.
///
/// # Arguments
///
/// * `line` - The line to parse.
///
/// # Returns
///
/// A tuple containing the parsed `Prefixes` and a slice of the string containing the actual command.
pub fn parse_prefixes(line: &str) -> (Prefixes, &str) {
    let mut prefixes = Prefixes::default();
    if let Some(command_text) = line.strip_prefix('#') {
        prefixes.is_echo = true;
        return (
            prefixes,
            command_text.strip_prefix(' ').unwrap_or(command_text),
        );
    }
    let mut current_pos = 0;
    for (i, char) in line.char_indices() {
        match char {
            '-' => prefixes.ignore_errors = true,
            '>' => prefixes.run_in_parallel = true,
            '@' => prefixes.silent_mode = true,
            '|' => {
                // Terminator: stop parsing prefixes.
                current_pos = i + 1;
                break;
            }
            _ if !char.is_whitespace() => {
                // First non-prefix, non-whitespace character.
                current_pos = i;
                break;
            }
            _ => (), // Whitespace, continue.
        }
        if i == line.len() - 1 {
            current_pos = line.len();
        }
    }
    (prefixes, line.get(current_pos..).unwrap_or("").trim_start())
}

/// Transforms a command string into a sequence of `TemplateComponent`s,
/// merging adjacent literal components for optimization.
///
/// # Arguments
///
/// * `text` - The text to tokenize.
///
/// # Returns
///
/// A `Result` containing a vector of `TemplateComponent`s on success, or an error if tokenization fails.
pub fn tokenize_string(text: &str) -> Result<Vec<TemplateComponent>> {
    let mut components = Vec::with_capacity(text.len() / 20);

    // Helper to push literals and handle merging.
    let push_literal = |components: &mut Vec<TemplateComponent>, s: &str| {
        if s.is_empty() {
            return;
        }
        if let Some(TemplateComponent::Literal(last)) = components.last_mut() {
            last.push_str(s);
        } else {
            components.push(TemplateComponent::Literal(s.to_string()));
        }
    };

    let mut last_index = 0;
    for caps in TOKEN_RE.captures_iter(text) {
        let full_match = caps
            .get(0)
            .expect("Regex capture group 0 should always exist on a match");

        // Push the literal part before the match.
        push_literal(&mut components, &text[last_index..full_match.start()]);

        if full_match.as_str().starts_with('\\') {
            // It's an escaped token. Treat its content (without the '\') as a literal.
            push_literal(&mut components, &full_match.as_str()[1..]);
        } else {
            // It's a real token.
            let content = caps
                .get(1)
                .expect("Regex capture group 1 should always exist on a match")
                .as_str();
            let component = parse_token_content(content, full_match.as_str())
                .with_context(|| format!("Failed to parse token: '{}'", full_match.as_str()))?;
            components.push(component);
        }
        last_index = full_match.end();
    }

    // Push any remaining literal text after the last token.
    push_literal(&mut components, &text[last_index..]);

    Ok(components)
}

/// Parses the inner content of a token like `<...>`
/// This refactor makes `tokenize_string` cleaner and improves error handling.
///
/// # Arguments
///
/// * `content` - The content of the token to parse.
/// * `full_match` - The full match of the token.
///
/// # Returns
///
/// A `Result` containing the parsed `TemplateComponent` on success, or an error if parsing fails.
fn parse_token_content(content: &str, full_match: &str) -> Result<TemplateComponent> {
    let trimmed_content = content.trim();
    if let Some(param_spec) = trimmed_content.strip_prefix("params::") {
        Ok(TemplateComponent::Parameter(
            parameters::parse_parameter_token(full_match, param_spec)?,
        ))
    } else if let Some(modifiers_str) = trimmed_content
        .strip_prefix("params")
        .and_then(|s| s.strip_prefix('('))
        .and_then(|s| s.strip_suffix(')'))
    {
        let modifiers = parameters::parse_parameter_modifiers_from_str(modifiers_str)?;
        Ok(TemplateComponent::GenericParams {
            literal: modifiers.literal,
        })
    } else if trimmed_content == "params" {
        Ok(TemplateComponent::GenericParams { literal: false })
    } else if let Some(color_name) = trimmed_content.strip_prefix('#') {
        Ok(TemplateComponent::Color(color::parse_style_name(
            color_name,
        )?))
    } else if let Some(run_spec) = trimmed_content.strip_prefix("run") {
        if let Some(cmd) = run_spec
            .strip_prefix("('")
            .and_then(|s| s.strip_suffix("')"))
        {
            Ok(TemplateComponent::Run(RunSpec::Literal(cmd.to_string())))
        } else {
            Err(anyhow!("Invalid run syntax"))
        }
    } else {
        match trimmed_content {
            "path" => Ok(TemplateComponent::Path),
            "name" => Ok(TemplateComponent::Name),
            "uuid" => Ok(TemplateComponent::Uuid),
            "version" => Ok(TemplateComponent::Version),
            s if s.starts_with("scripts::") => Ok(TemplateComponent::Script(
                s.strip_prefix("scripts::")
                    .expect("Token should have 'scripts::' prefix")
                    .to_string(),
            )),
            s if s.starts_with("vars::") => Ok(TemplateComponent::Var(
                s.strip_prefix("vars::")
                    .expect("Token should have 'vars::' prefix")
                    .to_string(),
            )),
            _ => Err(anyhow!("Unknown token namespace")),
        }
    }
}

/// Compiles a single `TomlCommand` (one line of a script) into a `PlatformExecution` block.
///
/// # Arguments
///
/// * `toml_command` - The `TomlCommand` to compile.
///
/// # Returns
///
/// A `Result` containing the compiled `PlatformExecution` on success, or an error if compilation fails.
fn compile_toml_command_to_platform_execution(
    toml_command: TomlCommand,
) -> Result<PlatformExecution> {
    match toml_command {
        TomlCommand::Simple(s) => {
            let command_exec = compile_string_to_command_execution(&s, true)?;
            Ok(PlatformExecution {
                default: Some(command_exec),
                ..Default::default()
            })
        }
        TomlCommand::Platform(platform_block) => {
            compile_platform_command_to_platform_execution(platform_block, true)
        }
    }
}

/// Compiles a `PlatformCommand` struct into a `PlatformExecution` struct.
///
/// # Arguments
///
/// * `platform_command` - The `PlatformCommand` to compile.
/// * `parse_action_prefixes` - Whether to parse action prefixes.
///
/// # Returns
///
/// A `Result` containing the compiled `PlatformExecution` on success, or an error if compilation fails.
fn compile_platform_command_to_platform_execution(
    platform_command: PlatformCommand,
    parse_action_prefixes: bool,
) -> Result<PlatformExecution> {
    // DRY Principle: Helper closure to avoid repetition.
    let compile_string = |s: String| -> Result<CommandExecution> {
        compile_string_to_command_execution(&s, parse_action_prefixes)
    };

    Ok(PlatformExecution {
        default: platform_command.default.map(compile_string).transpose()?,
        windows: platform_command.windows.map(compile_string).transpose()?,
        linux: platform_command.linux.map(compile_string).transpose()?,
        macos: platform_command.macos.map(compile_string).transpose()?,
    })
}

/// The lowest-level compilation function.
/// Takes a raw string, tokenizes it, and (optionally) parses `axes` prefixes.
///
/// # Arguments
///
/// * `s` - The string to compile.
/// * `parse_action_prefixes` - Whether to parse action prefixes.
///
/// # Returns
///
/// A `Result` containing the compiled `CommandExecution` on success, or an error if compilation fails.
fn compile_string_to_command_execution(
    s: &str,
    parse_action_prefixes: bool,
) -> Result<CommandExecution> {
    let (prefixes, command_text) = if parse_action_prefixes {
        parse_prefixes(s)
    } else {
        (Prefixes::default(), s)
    };

    let action = if prefixes.is_echo {
        CommandAction::Print(tokenize_string(command_text)?)
    } else {
        CommandAction::Execute(tokenize_string(command_text)?)
    };

    Ok(CommandExecution {
        action,
        ignore_errors: prefixes.ignore_errors,
        run_in_parallel: prefixes.run_in_parallel,
        silent_mode: prefixes.silent_mode,
    })
}

// --- CACHE I/O ---

/// Reads and deserializes a `CachedProjectConfig` from a compressed binary file.
/// This function is on the hot path for "cache hit" scenarios.
///
/// # Arguments
///
/// * `path` - The path to the cache file.
///
/// # Returns
///
/// A `Result` containing the deserialized `CachedProjectConfig` on success, or an error if the file
/// cannot be read or deserialized.
fn read_cached_layer(path: &std::path::Path) -> Result<CachedProjectConfig> {
    let _timer_total = BlockTimer::new("            ------> read_cached_layer (Total)");
    // 1. Read the compressed bytes from disk.
    
    let compressed_bytes = {
        let _timer_io = BlockTimer::new("              -------> 1. Filesystem Read");
        fs::read(path)
        .with_context(|| format!("Failed to read cache file at '{}'", path.display()))?};

    // ROBUSTNESS: Handle empty file case gracefully.
    if compressed_bytes.is_empty() {
        return Err(anyhow!("Cache file is empty."));
    }

    // 2. Decompress the data using LZ4.
    // `decompress_size_prepended` is extremely fast and safe. It reads the expected
    // decompressed size from the first few bytes, preventing DoS attacks with "zip bombs".
    log::trace!(
        "Decompressing cache layer from {} bytes.",
        compressed_bytes.len()
    );
    
    let decompressed_bytes ={
        let _timer_lz4 = BlockTimer::new("              -------> 2. LZ4 Decompression");
        lz4_flex::decompress_size_prepended(&compressed_bytes).map_err(|e| {
            anyhow!(
                "Failed to decompress cache file: {}. It might be corrupt.",
                e
            )
        })?};
    log::trace!("Decompressed to {} bytes.", decompressed_bytes.len());

    // 3. Deserialize the raw bytes using bincode.
    let (cached_layer, _): (CachedProjectConfig, usize) =
        {
            let _timer_bincode = BlockTimer::new("              -------> 3. Bincode Deserialization");
            bincode::serde::decode_from_slice(&decompressed_bytes, bincode::config::standard())
            .context("Failed to deserialize cache data after decompression. The cache is likely from an incompatible version of `axes`.")?};

    Ok(cached_layer)
}

/// Serializes and writes a `CachedProjectConfig` to a compressed binary file.
/// This function is on the "cold path" (cache miss).
///
/// # Arguments
///
/// * `path` - The path to the cache file.
/// * `layer` - The `CachedProjectConfig` to serialize.
///
/// # Returns
///
/// A `Result` indicating success or failure.
fn write_cached_layer(path: &std::path::Path, layer: &CachedProjectConfig) -> Result<()> {
    // 1. Ensure the parent directory exists.
    if let Some(parent_dir) = path.parent() {
        fs::create_dir_all(parent_dir).with_context(|| {
            format!(
                "Failed to create cache directory '{}'",
                parent_dir.display()
            )
        })?;
    }

    // 2. Serialize the AST to raw bytes using bincode.
    let decompressed_bytes = bincode::serde::encode_to_vec(layer, bincode::config::standard())
        .context("Failed to serialize cache layer.")?;
    log::trace!(
        "Serialized cache layer to {} bytes.",
        decompressed_bytes.len()
    );

    // 3. Compress the raw bytes using LZ4.
    // `compress_prepend_size` is very fast and adds a small header with the original
    // size, which is used for safe decompression.
    let compressed_bytes = lz4_flex::compress_prepend_size(&decompressed_bytes);
    log::trace!(
        "Compressed cache layer to {} bytes.",
        compressed_bytes.len()
    );

    // 4. Write the final compressed bytes to disk.
    fs::write(path, &compressed_bytes).with_context(|| {
        format!(
            "Failed to write compressed cache file to '{}'",
            path.display()
        )
    })?;

    Ok(())
}

#[cfg(test)]
mod tests {
    #![allow(clippy::panic)]
    use super::*;
    use crate::models::{TemplateComponent, TomlScriptExtended, TomlVarExtended, TomlVarValue};

    // --- Script Compilation Tests ---

    #[test]
    fn test_compile_simple_script_with_prefixes() {
        let script = TomlScript::Simple("@-echo 'hello'".to_string());
        let task = compile_script(script).expect("Compiling a simple script should succeed");
        assert_eq!(task.commands.len(), 1);
        let exec = task
            .commands
            .first()
            .and_then(|c| c.default.as_ref())
            .expect("Task should have one default command");
        assert!(exec.silent_mode);
        assert!(exec.ignore_errors);
        assert!(!exec.run_in_parallel);
        assert!(matches!(exec.action, CommandAction::Execute(_)));
    }

    #[test]
    fn test_compile_sequence_script_mixed() {
        let script = TomlScript::Sequence(vec![
            TomlCommand::Simple("# Step 1".to_string()),
            TomlCommand::Platform(PlatformCommand {
                windows: Some("dir".to_string()),
                default: Some("ls -la".to_string()),
                ..Default::default()
            }),
        ]);
        let task = compile_script(script).expect("Compiling a simple script should succeed");
        assert_eq!(task.commands.len(), 2);

        let first_cmd = task
            .commands
            .first()
            .and_then(|c| c.default.as_ref())
            .expect("Task should have a first command");
        assert!(matches!(first_cmd.action, CommandAction::Print(_)));

        let second_cmd = task
            .commands
            .get(1)
            .expect("Task should have a second command");
        assert!(second_cmd.windows.is_some());
        assert!(second_cmd.default.is_some());
        assert!(second_cmd.linux.is_none());
    }

    #[test]
    fn test_compile_extended_script_with_run_sequence() {
        let script = TomlScript::Extended(TomlScriptExtended {
            desc: Some("A complex script".to_string()),
            run: Box::new(TomlScript::Sequence(vec![
                TomlCommand::Simple("cmd1".to_string()),
                TomlCommand::Simple("cmd2".to_string()),
            ])),
        });
        let task = compile_script(script).expect("Compiling a simple script should succeed");
        assert_eq!(task.desc.as_deref(), Some("A complex script"));
        assert_eq!(task.commands.len(), 2);
    }

    #[test]
    fn test_compile_platform_direct_script() {
        let script = TomlScript::PlatformDirect(crate::models::TomlScriptPlatformDirect {
            desc: Some("Platform direct".to_string()),
            platform: PlatformCommand {
                windows: Some("echo 'win'".to_string()),
                ..Default::default()
            },
        });
        let task = compile_script(script).expect("Compiling a simple script should succeed");
        assert_eq!(task.desc.as_deref(), Some("Platform direct"));
        assert_eq!(task.commands.len(), 1);
        assert!(
            task.commands
                .first()
                .expect("Task should have one command")
                .windows
                .is_some()
        );
        assert!(
            task.commands
                .first()
                .expect("Task should have one command")
                .default
                .is_none()
        );
    }

    // --- Variable Compilation Tests ---

    #[test]
    fn test_compile_simple_var_no_prefixes() {
        let var = TomlVar::Simple("@-my-value".to_string());
        let cached_var = compile_var(var).expect("Variable compilation should succeed in test");
        let exec = cached_var
            .value
            .default
            .as_ref()
            .expect("Variable should have a default value");

        assert!(!exec.silent_mode);
        assert!(!exec.ignore_errors);

        if let CommandAction::Execute(tpl) = &exec.action {
            let component = tpl.first().expect("Template should have one component");
            assert!(matches!(component, TemplateComponent::Literal(s) if s == "@-my-value"));
        } else {
            panic!("Expected Execute action");
        }
    }

    #[test]
    fn test_compile_extended_var_platform() {
        let var = TomlVar::Extended(TomlVarExtended {
            desc: Some("Path to binary".to_string()),
            value: TomlVarValue::Platform(PlatformCommand {
                windows: Some("bin\\app.exe".to_string()),
                default: Some("bin/app".to_string()),
                ..Default::default()
            }),
        });
        let cached_var = compile_var(var).expect("Test var compilation should succeed");
        assert_eq!(cached_var.desc.as_deref(), Some("Path to binary"));
        assert!(cached_var.value.windows.is_some());
        assert!(cached_var.value.default.is_some());
    }

    // --- Error Handling and Edge Case Tests ---

    #[test]
    fn test_tokenizer_handles_escaped_tokens_and_merges_literals() {
        let text = r"echo '\<hello> world <name>'";
        let components = tokenize_string(text).expect("Tokenizing static string should succeed");
        assert_eq!(components.len(), 3);
        assert!(
            matches!(components.first(), Some(TemplateComponent::Literal(s)) if s == "echo '<hello> world ")
        );
        assert!(matches!(components.get(1), Some(TemplateComponent::Name)));
        assert!(matches!(components.get(2), Some(TemplateComponent::Literal(s)) if s == "'"));
    }

    #[test]
    fn test_tokenizer_with_complex_tokens() {
        let text = r"<run('git status')> <params::0(required)> <#red>ERROR<#reset>";
        let components = tokenize_string(text).expect("Tokenizing static string should succeed");
        assert_eq!(components.len(), 7);
        assert!(matches!(
            components.first(),
            Some(TemplateComponent::Run(_))
        ));
        assert!(matches!(components.get(1), Some(TemplateComponent::Literal(s)) if s == " "));
        assert!(matches!(
            components.get(2),
            Some(TemplateComponent::Parameter(_))
        ));
        assert!(matches!(components.get(3), Some(TemplateComponent::Literal(s)) if s == " "));
        assert!(
            matches!(components.get(4), Some(TemplateComponent::Color(c)) if *c == crate::models::AnsiStyle::Red)
        );
        assert!(matches!(components.get(5), Some(TemplateComponent::Literal(s)) if s == "ERROR"));
        assert!(
            matches!(components.get(6), Some(TemplateComponent::Color(c)) if *c == crate::models::AnsiStyle::Reset)
        );
    }

    #[test]
    fn test_empty_script_compiles_to_empty_task() {
        let script = TomlScript::Simple("".to_string());
        let task = compile_script(script).expect("Compiling a simple script should succeed");
        assert_eq!(task.commands.len(), 1); // An empty command is still a command
        let exec = task
            .commands
            .first()
            .and_then(|c| c.default.as_ref())
            .expect("Task should have one default command");
        if let CommandAction::Execute(tpl) = &exec.action {
            assert!(tpl.is_empty());
        } else {
            panic!("Expected Execute action");
        }
    }

    #[test]
    fn test_toml_deserialization_error_for_unknown_field_in_script() {
        let toml_str = r#"
            desc = "A script with a typo"
            runs = "echo 'hello'" # Typo: should be `run`
        "#;
        // FIX: We are testing the `TomlScriptExtended` struct directly.
        let result: Result<TomlScriptExtended, _> = toml::from_str(toml_str);
        assert!(result.is_err(), "Should fail due to unknown field 'runs'");
        let error_msg = result
            .expect_err("Deserialization should fail due to unknown field")
            .to_string();
        assert!(
            error_msg.contains("unknown field `runs`"),
            "Error message was: {}",
            error_msg
        );
    }

    #[test]
    fn test_toml_deserialization_error_for_unknown_field_in_var() {
        let toml_str = r#"
            desc = "A var with a typo"
            val = "my-value" # Typo: should be `value`
        "#;
        // FIX: We are testing the `TomlVarExtended` struct directly.
        let result: Result<TomlVarExtended, _> = toml::from_str(toml_str);
        assert!(result.is_err(), "Should fail due to unknown field 'val'");
        let error_msg = result
            .expect_err("Deserialization should fail due to unknown field")
            .to_string();
        assert!(
            error_msg.contains("unknown field `val`"),
            "Error message was: {}",
            error_msg
        );
    }
}

===== core\config_loader.rs =====
//! # Config Loader
//!
//! This module provides the `ConfigLoader` struct, which is responsible for orchestrating the loading
//! of configuration layers for a project hierarchy. It handles both registered and ephemeral projects,
//! leveraging parallel processing and caching to ensure high performance.
use crate::{
    core::{compiler, index_manager, paths}, dev_utils, models::{GlobalIndex, IndexEntry, LayerPromise, ResolvedConfig}
};
use anyhow::{Result, anyhow};
use log;
use rayon::prelude::*;
use std::{
    collections::HashMap,
    path::{Path, PathBuf},
    sync::{Arc, Mutex, OnceLock},
};
use uuid::Uuid;

/// Orchestrates the loading of configuration layers for a project hierarchy.
#[derive(Debug)]
pub struct ConfigLoader<'a> {
    index: &'a mut GlobalIndex,
}

impl<'a> ConfigLoader<'a> {
    /// Creates a new `ConfigLoader`.
    ///
    /// # Arguments
    ///
    /// * `index` - A mutable reference to the `GlobalIndex`.
    pub fn new(index: &'a mut GlobalIndex) -> Self {
        Self { index }
    }

    /// The main entry point for configuration resolution for a registered project.
    ///
    /// This function orchestrates a complex, multi-stage process designed for maximum
    /// performance and correctness:
    ///
    /// 1. **Hierarchy Discovery:** It traverses the `GlobalIndex` to determine the full
    ///    inheritance chain for the requested project UUID.
    ///
    /// 2. **Parallel Loading & Compilation:** It spawns a parallel task via `rayon` for
    ///    each project in the hierarchy. Each task (`compiler::load_layer_task`) is
    ///    responsible for:
    ///    a. Checking if a valid binary cache exists for its `axes.toml` file.
    ///    b. If a `Cache Miss` occurs, it compiles the `axes.toml` into a `CachedProjectConfig` (AST)
    ///    and writes it to a new binary cache file.
    ///
    /// 3. **State Synchronization:**
    ///    a. **Hashes:** If any layers were recompiled, their new content hashes are collected
    ///    and updated in the in-memory `GlobalIndex`.
    ///    b. **Cache Path:** After all layers are loaded, it constructs the `ResolvedConfig` facade.
    ///    It then uses this facade to determine the *final, inherited `cache_dir` path*.
    ///    If this final path differs from what's stored in the index, the index is updated.
    ///    This ensures the next run will find the cache in the correct, inherited location.
    ///
    /// 4. **Cache File Migration:** If a re-compilation occurred *and* the final `cache_dir`
    ///    path changed, this function will atomically move the newly created cache file from
    ///    the old path to the new, correct path.
    ///
    /// 5. **Facade Construction:** Finally, it returns a `ResolvedConfig` instance, a lazy
    ///    facade that provides on-demand access to the fully merged configuration without
    ///    further blocking or I/O.
    ///
    /// # Arguments
    ///
    /// * `uuid` - The UUID of the project to resolve.
    ///
    /// # Returns
    ///
    /// A `Result` containing the `ResolvedConfig` on success, or an error if resolution fails.
    pub fn resolve(&mut self, uuid: Uuid) -> Result<ResolvedConfig> {
        let _timer = dev_utils::BlockTimer::new("    --> ConfigLoader::resolve");
        log::debug!("ConfigLoader resolving UUID: {}", uuid);

        // --- 1. Hierarchy Discovery ---
        let mut hierarchy = Vec::new();
        let _timer_h = dev_utils::BlockTimer::new("      ---> Hierarchy Discovery");
        let mut current_uuid = Some(uuid);
        while let Some(id) = current_uuid {
            hierarchy.push(id);
            let entry = self.index.projects.get(&id).ok_or_else(|| {
                let child_uuid = hierarchy.get(hierarchy.len().saturating_sub(2)).unwrap_or(&uuid);
                anyhow!(
                    "Data Integrity Error: Project UUID '{}' lists a parent with UUID '{}', but no such project exists in the index.",
                    child_uuid,
                    id
                )
            })?;
            current_uuid = entry.parent;
        }

        // --- 2. Parallel Loading & Compilation ---
        let layer_promises: HashMap<Uuid, LayerPromise> = hierarchy
            .par_iter()
            .map(|&id| (id, Arc::new(OnceLock::new())))
            .collect();

        let hash_updates = Arc::new(Mutex::new(Vec::new()));
        let index_ref: &GlobalIndex = self.index;

        let _timer_pl = dev_utils::BlockTimer::new("      ---> Parallel Layer Loading");
        hierarchy.par_iter().for_each(|&layer_uuid| {
            let promise = layer_promises
                .get(&layer_uuid)
                .expect("Layer UUID must be in the promises map");
            log::trace!("Executing load task for UUID: {}", layer_uuid);

            let task_result = compiler::load_layer_task(layer_uuid, index_ref);

            let layer_result_for_promise = match task_result {
                Ok((layer_arc, Some(update))) => {
                    // On a cache miss, we get a hash update.
                    hash_updates
                        .lock()
                        .expect("Mutex should not be poisoned")
                        .push(update);
                    Ok(layer_arc)
                }
                Ok((layer_arc, None)) => Ok(layer_arc), // Cache hit
                Err(e) => Err(e),
            };

            if promise.set(layer_result_for_promise).is_err() {
                log::error!("CRITICAL: LayerPromise for {} was set twice.", layer_uuid);
            }
        });

        // --- 3. State Synchronization ---
        let primary_entry = self
            .index
            .projects
            .get(&uuid)
            .expect("Primary project UUID must exist in the index");
        let qualified_name = crate::core::index_manager::build_qualified_name(uuid, self.index)
            .unwrap_or_else(|| primary_entry.name.clone());

        // Step 3a: Construct the facade *before* final index updates.
        let resolved_config = ResolvedConfig::new(
            uuid,
            qualified_name,
            primary_entry.path.clone(),
            hierarchy,
            layer_promises,
        );

        // Step 3b: Determine the final, inherited cache path (as a String).
        let final_options = resolved_config.get_options()?;
        let final_cache_path_str = final_options.cache_dir.ok_or_else(|| {
            anyhow!("Internal logic error: ResolvedConfig failed to produce a cache_dir.")
        })?;

        let final_cache_path = PathBuf::from(&final_cache_path_str);

        // Step 3c: Collect hash updates from the parallel tasks.
        let updates_to_apply = Arc::try_unwrap(hash_updates)
            .expect("Mutex should not be locked elsewhere")
            .into_inner()
            .expect("Mutex should not be poisoned");

        // Step 3d: Apply updates to the in-memory index.
        let entry = self
            .index
            .projects
            .get_mut(&uuid)
            .expect("Primary project UUID must exist in the index");
        let mut cache_path_changed = false;

        if entry.cache_dir.as_ref() != Some(&final_cache_path) {
            log::debug!(
                "Updating stale cache_dir for project {} in index. Old: {:?}, New: {}",
                uuid,
                entry.cache_dir,
                final_cache_path.display() // .display() works on PathBuf. Correct.
            );
            entry.cache_dir = Some(final_cache_path.clone()); // .clone() on PathBuf. Correct.
            cache_path_changed = true;
        }

        let mut new_hash = None;
        if let Some(update) = updates_to_apply.iter().find(|u| u.uuid == uuid) {
            entry.config_hash = Some(update.new_hash.clone());
            new_hash = Some(update.new_hash.clone());
        }

        // --- 4. Cache File Migration ---
        // If the toml was recompiled AND the final cache path has changed, we must move the file.
        if let (true, Some(hash)) = (cache_path_changed, new_hash) {
            // The `load_layer_task` wrote the cache file to the *old* indexed path. We need to move it.
            let old_cache_dir = resolved_config
                .get_layer(uuid)?
                .options
                .cache_dir
                .as_ref()
                .map(PathBuf::from)
                .unwrap_or_else(|| {
                    paths::get_default_cache_dir_for_project(uuid)
                        .expect("Default cache dir should always be resolvable")
                });

            let old_path = old_cache_dir.join(&hash);
            let new_path = final_cache_path.join(&hash);

            if old_path != new_path && old_path.exists() {
                log::info!(
                    "Cache directory for project '{}' has changed. Migrating cache file from {} to {}",
                    resolved_config.qualified_name,
                    old_path.display(),
                    new_path.display()
                );
                // Ensure parent directory of the new path exists.
                if let Some(parent) = new_path.parent() {
                    std::fs::create_dir_all(parent)?;
                }
                if let Err(e) = std::fs::rename(&old_path, &new_path) {
                    log::error!(
                        "Failed to migrate cache file: {}. A new cache will be generated on the next run.",
                        e
                    );
                    // Attempt to clean up the old file if rename fails, but don't panic.
                    let _ = std::fs::remove_file(old_path);
                }
            }
        }

        // --- 5. Return Facade ---
        Ok(resolved_config)
    }

    /// Resolves a project configuration ephemerally from the filesystem.
    /// It reads the local `project_ref.bin` to find its identity and parent,
    /// then uses the global index ONLY to resolve the inheritance chain of its parents.
    /// It does not perform any cache checks or index updates for the ephemeral project itself.
    ///
    /// # Arguments
    ///
    /// * `path` - The path to the ephemeral project.
    ///
    /// # Returns
    ///
    /// A `Result` containing the `ResolvedConfig` on success, or an error if resolution fails.
    pub fn resolve_ephemeral(&mut self, path: &Path) -> Result<ResolvedConfig> {
        log::debug!(
            "ConfigLoader resolving ephemerally from path: {}",
            path.display()
        );

        let canonical_path = dunce::canonicalize(path)?;

        // 1. Read local identity. If this fails, we can't proceed.
        let project_ref = index_manager::read_project_ref(&canonical_path)
            .map_err(|_| anyhow!("No '.axes/project_ref.bin' found at '{}'. An ephemeral project must have a local identity file.", canonical_path.display()))?;

        // 2. Build the hierarchy: self (from project_ref) + parents (from index).
        let mut hierarchy = vec![project_ref.self_uuid];
        let mut current_uuid_opt = project_ref.parent_uuid;
        while let Some(id) = current_uuid_opt {
            let entry = self.index.projects.get(&id)
                .ok_or_else(|| anyhow!("Ephemeral project at '{}' depends on parent UUID '{}', which is not registered in the global index.", canonical_path.display(), id))?;
            hierarchy.push(id);
            current_uuid_opt = entry.parent;
        }

        // 3. Prepare promises for parallel loading.
        let layer_promises: HashMap<_, _> = hierarchy
            .iter()
            .map(|&id| (id, Arc::new(OnceLock::new())))
            .collect();
        let index_ref = &*self.index;

        // Create a temporary, in-memory IndexEntry for the ephemeral project.
        let ephemeral_entry = IndexEntry {
            name: project_ref.name.clone(),
            path: canonical_path.clone(),
            parent: project_ref.parent_uuid,
            ..Default::default()
        };

        let ephemeral_entry_arc = Arc::new(ephemeral_entry);

        rayon::scope(|s| {
            for &layer_uuid in &hierarchy {
                let promise = layer_promises
                    .get(&layer_uuid)
                    .expect("Layer UUID from hierarchy must be in promises map")
                    .clone();

                let ephemeral_entry_clone = ephemeral_entry_arc.clone();

                s.spawn(move |_| {
                    let task_result = if layer_uuid == project_ref.self_uuid {
                        // For the ephemeral project, COMPILE a fresh layer. NO CACHING.
                        log::trace!("Compiling ephemeral layer for UUID: {}", layer_uuid);
                        // The thread now uses its cloned Arc.
                        compiler::load_and_compile_layer(&ephemeral_entry_clone)
                            .map(|layer| (Arc::new(layer), None))
                    } else {
                        // For registered parents, use the NORMAL cached loading task.
                        log::trace!("Loading parent layer from index for UUID: {}", layer_uuid);
                        compiler::load_layer_task(layer_uuid, index_ref)
                    };

                    let layer_result_for_promise = match task_result {
                        Ok((layer_arc, _)) => Ok(layer_arc),
                        Err(e) => Err(e),
                    };

                    promise
                        .set(layer_result_for_promise)
                        .expect("Promise should only be set once");
                });
            }
        });

        // 5. Construct and return the lazy facade.
        // Use a special qualified name to indicate its ephemeral nature in logs/UI.
        let qualified_name = format!("_{}", project_ref.name);

        Ok(ResolvedConfig::new(
            project_ref.self_uuid,
            qualified_name,
            canonical_path,
            hierarchy,
            layer_promises,
        ))
    }
}

===== core\context_resolver.rs =====
//! # Context Resolver
//!
//! This module provides the `resolve_context` function, which is responsible for resolving a project
//! context string to its canonical UUID and fully qualified name. The resolution follows a strict,
//! multi-layered priority order to ensure predictable behavior both inside and outside of project
//! sessions.

use crate::{
    core::index_manager::{self, GLOBAL_PROJECT_UUID},
    models::{GlobalIndex, IndexEntry},
    state::AppStateGuard,
};
use dialoguer::{Error as DialoguerError, Select, theme::ColorfulTheme};
use std::{env, path::Path};
use thiserror::Error;
use uuid::Uuid;

/// Represents errors that can occur during the resolution of a context string (e.g., `my-app/backend`).
#[derive(Error, Debug)]
pub enum ContextError {
    // --- Wrapped Errors ---
    /// A filesystem error occurred during path resolution.
    #[error("Filesystem Error: {0}")]
    Io(#[from] std::io::Error),
    /// An error occurred while accessing the global index.
    #[error("Index Error: {0}")]
    Index(#[from] crate::core::index_manager::IndexError),
    /// An error occurred while decoding a binary file (e.g., `project_ref.bin`).
    #[error("Error decoding cache: {0}")]
    BincodeDecode(#[from] bincode::error::DecodeError),
    /// An error occurred while encoding a binary file.
    #[error("Error encoding cache: {0}")]
    BincodeEncode(#[from] bincode::error::EncodeError),
    /// An error occurred during an interactive prompt (e.g., user pressed Ctrl+C).
    #[error("User Interface Error: {0}")]
    Dialoguer(#[from] DialoguerError),

    // --- Semantic Errors ---
    /// An empty context string was provided where one was required.
    #[error("Empty context not provided.")]
    EmptyContext,
    /// The `**` token was used in a position other than the start of the context string.
    #[error("Context '**' can only be used at the beginning of the path.")]
    GlobalRecentNotAtStart,
    /// The `_` token was used in a position other than the start of the context string.
    #[error("Context '_' can only be used at the beginning of a path when outside a session.")]
    StrictLocalPathNotAtStart,
    /// A `..` token was used on a project that has no parent.
    #[error("Cannot go further up the hierarchy. Already at a root project.")]
    AlreadyAtRoot,
    /// The `**` token was used but no projects have been accessed recently.
    #[error("No projects have been used recently. Cannot resolve '**'.")]
    NoLastUsedProject,
    /// The `*` token was used on a parent that has no last-used child.
    #[error(
        "Parent project '{parent_name}' has not used any children recently. Cannot resolve '*'."
    )]
    NoLastUsedChild {
        /// The name of the parent project.
        parent_name: String,
    },
    /// A project context was inferred from the current path (`.`), but no project was found.
    #[error("No axes project found in current directory or any parent directories.")]
    ProjectNotFoundFromPath,
    /// A project context was specified as the current directory (`_`), but no project is registered there.
    #[error("No axes project found in current directory.")]
    ProjectNotFoundInCwd,
    /// The first part of a context path did not match any known root project.
    #[error("Root project with name '{name}' not found.")]
    RootProjectNotFound {
        /// The name of the root project that was not found.
        name: String,
    },
    /// A part of a context path did not match any child of the preceding project.
    #[error("Child project '{child_name}' not found for parent '{parent_name}'.")]
    ChildProjectNotFound {
        /// The name of the child that was not found.
        child_name: String,
        /// The name of the parent that was being searched.
        parent_name: String,
    },
    /// An alias (e.g., `my-alias!`) was used that is not defined.
    #[error("Alias '{name}!' not found.")]
    AliasNotFound {
        /// The name of the alias that was not found.
        name: String,
    },
    /// The qualified name for a project could not be constructed, likely due to a broken parent link.
    #[error("Could not resolve project name for alias (possible broken parent link).")]
    AliasResolutionError,
    /// The user cancelled an interactive operation.
    #[error("Operation cancelled by user.")]
    Cancelled,
}

type ContextResult<T> = Result<T, ContextError>;

/// Resolves a project context string to its canonical UUID and fully qualified name.
/// The resolution follows a strict, multi-layered priority order to ensure
/// predictable behavior both inside and outside of project sessions.
///
/// # Arguments
///
/// * `context` - The context string to resolve.
/// * `state_guard` - A mutable reference to the `AppStateGuard`.
///
/// # Returns
///
/// A `Result` containing a tuple of the resolved UUID and the fully qualified name on success,
/// or a `ContextError` if resolution fails.
pub fn resolve_context(
    context: &str,
    state_guard: &mut AppStateGuard<'_>,
) -> ContextResult<(Uuid, String)> {
    let context = context.trim();

    let parts: Vec<&str> = context.split('/').collect();

    let first_part = parts
        .first()
        .map_or(".", |p| if p.trim().is_empty() { "." } else { p });
    let global_project_entry = state_guard
        .index()
        .projects
        .get(&GLOBAL_PROJECT_UUID)
        .expect("Global project UUID must exist in the index");

    // --- 1. DETERMINE THE STARTING POINT AND TRAVERSAL PARTS ---
    // This logic implements the full precedence hierarchy.
    let session_uuid_opt = env::var("AXES_PROJECT_UUID")
        .ok()
        .and_then(|s| Uuid::parse_str(&s).ok());

    let (mut current_uuid, traversal_parts) = {
        match first_part {
            // --- PRIORITY 1: ABSOLUTE OVERRIDES (SESSION-IGNORANT) ---
            "." => {
                // Relative to CWD
                let uuid = find_project_from_path(&env::current_dir()?, true, state_guard.index())?;
                (
                    uuid,
                    parts
                        .get(1..)
                        .expect("Split always produces at least one part"),
                )
            }
            "_" => {
                // Strictly relative to CWD
                let uuid =
                    find_project_from_path(&env::current_dir()?, false, state_guard.index())?;
                (
                    uuid,
                    parts
                        .get(1..)
                        .expect("Split always produces at least one part"),
                )
            }
            "**" => {
                // Global last used
                let uuid = state_guard
                    .index()
                    .last_used
                    .ok_or(ContextError::NoLastUsedProject)?;
                (
                    uuid,
                    parts
                        .get(1..)
                        .expect("Split always produces at least one part"),
                )
            }
            _ if first_part.ends_with('!') => {
                // Aliases
                let alias_name = first_part
                    .strip_suffix('!')
                    .expect("Alias must end with '!' at this point");
                let uuid = *state_guard.index().aliases.get(alias_name).ok_or_else(|| {
                    ContextError::AliasNotFound {
                        name: alias_name.to_string(),
                    }
                })?;
                (
                    uuid,
                    parts
                        .get(1..)
                        .expect("Split always produces at least one part"),
                )
            }
            _ if first_part == global_project_entry.name => {
                // Global project name
                (
                    GLOBAL_PROJECT_UUID,
                    parts
                        .get(1..)
                        .expect("Split always produces at least one part"),
                )
            }

            // --- PRIORITY 2: `axes` FOCUS-RELATIVE NAVIGATION (SESSION-AWARE `..`) ---
            ".." => {
                let focus_uuid = if let Some(session_uuid) = session_uuid_opt {
                    // In a session, `..` refers to the session project's parent.
                    session_uuid
                } else {
                    // Outside a session, `..` refers to the CWD project's parent.
                    find_project_from_path(&env::current_dir()?, true, state_guard.index())?
                };
                let focus_entry = state_guard
                    .index()
                    .projects
                    .get(&focus_uuid)
                    .expect("Focus UUID must exist in the index");
                let parent_uuid = focus_entry.parent.ok_or(ContextError::AlreadyAtRoot)?;
                (
                    parent_uuid,
                    parts
                        .get(1..)
                        .expect("Split always produces at least one part"),
                )
            }

            // --- PRIORITY 3: `axes` FOCUS-RELATIVE CHILD LOOKUP (SESSION-AWARE) ---
            _ => {
                // `first_part` is a simple name like "backend"
                let start_node = if let Some(session_uuid) = session_uuid_opt {
                    // In a session, resolve relative to the session project.
                    session_uuid
                } else {
                    // Outside a session, resolve relative to the global project.
                    GLOBAL_PROJECT_UUID
                };
                (start_node, &parts[..]) // Do not consume the part, it's the first child to find.
            }
        }
    };

    // --- 2. TRAVERSE THE PATH ---
    for part in traversal_parts {
        let current_entry = state_guard
            .index()
            .projects
            .get(&current_uuid)
            .expect("Current UUID in traversal must exist in the index");

        let next_uuid = match *part {
            "." | "_" | "**" => return Err(ContextError::GlobalRecentNotAtStart),
            ".." => current_entry.parent.ok_or(ContextError::AlreadyAtRoot)?,
            "*" => resolve_last_used_child(current_uuid, current_entry, state_guard.index())?,
            name => find_child_by_name(current_uuid, current_entry, name, state_guard.index())?,
        };
        current_uuid = next_uuid;
    }

    // --- 3. Finalize and Return ---
    state_guard.update_last_used_caches(current_uuid);
    let final_qualified_name =
        index_manager::build_qualified_name(current_uuid, state_guard.index())
            .ok_or(ContextError::AliasResolutionError)?;

    Ok((current_uuid, final_qualified_name))
}

/// Resolves '*' for a child, with interactive fallback.
///
/// # Arguments
///
/// * `parent_uuid` - The UUID of the parent project.
/// * `parent_entry` - A reference to the `IndexEntry` of the parent project.
/// * `index` - A reference to the `GlobalIndex`.
///
/// # Returns
///
/// A `Result` containing the UUID of the resolved child on success, or a `ContextError` if
/// resolution fails.
fn resolve_last_used_child(
    parent_uuid: Uuid,
    parent_entry: &IndexEntry,
    index: &GlobalIndex,
) -> ContextResult<Uuid> {
    // 1. Check cached `last_used_child` and VALIDATE that it still exists and is a child.
    if let Some(uuid) = parent_entry.last_used_child {
        if let Some(child_entry) = index.projects.get(&uuid)
            && child_entry.parent == Some(parent_uuid)
        {
            log::debug!(
                "Validated last used child '{}' for parent '{}'.",
                uuid,
                parent_entry.name
            );
            return Ok(uuid);
        }

        // If the check fails, the cache is stale. Proceed to fallback.
        log::warn!(
            "Stale 'last_used_child' cache for parent '{}'. Re-evaluating.",
            parent_entry.name
        );
    }

    // 2. Fallback: No valid cache. Find children and ask user if interactive.
    let mut children: Vec<(Uuid, &str)> = index
        .projects
        .iter()
        .filter(|(_, e)| e.parent == Some(parent_uuid))
        .map(|(uuid, e)| (*uuid, e.name.as_str()))
        .collect();

    if children.is_empty() {
        return Err(ContextError::NoLastUsedChild {
            parent_name: parent_entry.name.clone(),
        });
    }

    // Sort for deterministic selection in tests and UI.
    children.sort_by_key(|(_, name)| *name);

    println!(
        "Project '{}' has no recently used child.",
        parent_entry.name
    );
    let child_names: Vec<_> = children.iter().map(|(_, name)| *name).collect();

    let selection = Select::with_theme(&ColorfulTheme::default())
        .with_prompt("Please select a child to continue:")
        .items(&child_names)
        .default(0)
        .interact_opt()?
        .ok_or(ContextError::Cancelled)?;

    Ok(children
        .get(selection)
        .expect("Dialoguer selection should be a valid index")
        .0) // Return the UUID directly from the collected tuple.
}

/// Finds a project's UUID by searching from a file system path.
///
/// # Arguments
///
/// * `path` - The path to search from.
/// * `search_up` - Whether to search up the directory tree.
/// * `index` - A reference to the `GlobalIndex`.
///
/// # Returns
///
/// A `Result` containing the UUID of the found project on success, or a `ContextError` if
/// no project is found.
fn find_project_from_path(
    path: &Path,
    search_up: bool,
    index: &GlobalIndex,
) -> ContextResult<Uuid> {
    let current_path = dunce::canonicalize(path)?;

    if search_up {
        // Mode '.' (ascending search)
        let mut candidates: Vec<(Uuid, &IndexEntry)> = index
            .projects
            .iter()
            .filter(|(_, entry)| current_path.starts_with(&entry.path))
            .map(|(uuid, entry)| (*uuid, entry))
            .collect();

        if candidates.is_empty() {
            return Err(ContextError::ProjectNotFoundFromPath);
        }

        // Sort by path length, from longest to shortest.
        candidates.sort_by_key(|(_, entry)| std::cmp::Reverse(entry.path.as_os_str().len()));

        // The first candidate is the most specific (the closest "ancestor").
        Ok(candidates
            .first()
            .expect("Candidates list should not be empty here")
            .0)
    } else {
        // Mode '_' (strict search in current directory)
        index
            .projects
            .iter()
            .find(|(_, entry)| entry.path == current_path)
            .map(|(uuid, _)| *uuid)
            .ok_or(ContextError::ProjectNotFoundInCwd)
    }
}

/// Finds the UUID of a child by its name (logic moved from `config_resolver`).
///
/// # Arguments
///
/// * `parent_uuid` - The UUID of the parent project.
/// * `parent_entry` - A reference to the `IndexEntry` of the parent project.
/// * `child_name` - The name of the child to find.
/// * `index` - A reference to the `GlobalIndex`.
///
/// # Returns
///
/// A `Result` containing the UUID of the found child on success, or a `ContextError` if
/// the child is not found.
fn find_child_by_name(
    parent_uuid: Uuid,
    parent_entry: &IndexEntry,
    child_name: &str,
    index: &GlobalIndex,
) -> ContextResult<Uuid> {
    index
        .projects
        .iter()
        .find(|(_, e)| e.parent == Some(parent_uuid) && e.name == child_name)
        .map(|(uuid, _)| *uuid)
        .ok_or_else(|| ContextError::ChildProjectNotFound {
            child_name: child_name.to_string(),
            parent_name: parent_entry.name.clone(),
        })
}

===== core\graph_display.rs =====
use crate::{
    core::index_manager,
    models::{GlobalIndex, IndexEntry},
};
use colored::*;
use std::collections::HashMap;
use uuid::Uuid;

/// Options to control the appearance of the rendered project tree.
#[derive(Default, Debug)]
pub struct DisplayOptions {
    /// If true, display the absolute filesystem path for each project.
    pub show_paths: bool,
    /// If true, display the UUID for each project.
    pub show_uuids: bool,
    /// An optional limit on the depth of the tree to display.
    pub max_depth: Option<usize>,
    /// If true, check if each project's path exists on the filesystem and show a warning if not.
    pub show_health: bool,
}

/// A context struct to hold all data needed for rendering the tree.
struct TreeRenderer<'a> {
    index: &'a GlobalIndex,
    options: &'a DisplayOptions,
    children_map: HashMap<Option<Uuid>, Vec<(Uuid, &'a IndexEntry)>>,
    alias_map: HashMap<Uuid, Vec<&'a str>>,
}

impl<'a> TreeRenderer<'a> {
    /// Creates a new renderer and pre-computes necessary lookup maps.
    fn new(index: &'a GlobalIndex, options: &'a DisplayOptions) -> Self {
        let mut children_map: HashMap<Option<Uuid>, Vec<(Uuid, &'a IndexEntry)>> = HashMap::new();
        for (uuid, entry) in &index.projects {
            children_map
                .entry(entry.parent)
                .or_default()
                .push((*uuid, entry));
        }
        for children in children_map.values_mut() {
            children.sort_by_key(|(_, entry)| &entry.name);
        }

        let mut alias_map: HashMap<Uuid, Vec<&'a str>> = HashMap::new();
        for (alias_name, uuid) in &index.aliases {
            alias_map.entry(*uuid).or_default().push(alias_name);
        }
        // Sort alias names for deterministic output.
        for aliases in alias_map.values_mut() {
            aliases.sort_unstable();
        }

        Self {
            index,
            options,
            children_map,
            alias_map,
        }
    }

    /// Renders the tree starting from a given node (or the root if `None`).
    fn render_tree(&self, start_node_uuid_opt: Option<Uuid>) {
        // Logic for finding the start node.
        let (start_uuid, is_subtree) = match start_node_uuid_opt {
            Some(uuid) => (uuid, true), // Rendering a specific subtree
            None => (index_manager::GLOBAL_PROJECT_UUID, false), // Rendering the full tree
        };

        if let Some(start_entry) = self.index.projects.get(&start_uuid) {
            // If it's a subtree, we don't print the root node itself as part of the tree lines.
            // The header already announced it.
            if !is_subtree {
                self.print_node_info(start_uuid, start_entry);
                println!();
            }
            self.render_children_of(start_uuid, "", 1);
        } else {
            let error_message = if is_subtree {
                t!("tree.error.project_not_found").red()
            } else {
                t!("tree.error.root_project_missing").yellow()
            };
            println!("\n{}", error_message);
        }

        self.print_legend();
    }

    /// Renders all direct children of a given node recursively.
    fn render_children_of(&self, parent_uuid: Uuid, prefix: &str, depth: usize) {
        if let Some(max_depth) = self.options.max_depth
            && depth > max_depth
        {
            return;
        }

        if let Some(children) = self.children_map.get(&Some(parent_uuid)) {
            for (i, (child_uuid, child_entry)) in children.iter().enumerate() {
                let is_last_child = i == children.len() - 1;
                let connector = if is_last_child { "└─" } else { "├─" };
                let child_prefix =
                    format!("{}{}", prefix, if is_last_child { "   " } else { "│  " });

                print!("{}{}", prefix, connector);
                self.print_node_info(*child_uuid, child_entry);
                println!();

                self.render_children_of(*child_uuid, &child_prefix, depth + 1);
            }
        }
    }

    /// Prints the formatted information for a single node.
    fn print_node_info(&self, uuid: Uuid, entry: &IndexEntry) {
        print!("{}", entry.name.cyan());
        let mut info_parts = Vec::new();

        if self.options.show_health && !entry.path.exists() {
            info_parts.push(t!("tree.label.broken_path").yellow().to_string());
        }
        if self.index.last_used == Some(uuid) {
            info_parts.push(t!("tree.label.last_used").yellow().to_string());
        }
        if let Some(aliases) = self.alias_map.get(&uuid) {
            let formatted_aliases = aliases
                .iter()
                .map(|name| format!("{}!", name))
                .collect::<Vec<_>>()
                .join(", ");
            info_parts.push(formatted_aliases.bright_blue().to_string());
        }
        if self.options.show_paths {
            info_parts.push(format!("[{}]", entry.path.display()).dimmed().to_string());
        }
        if self.options.show_uuids {
            info_parts.push(format!("({})", uuid).dimmed().to_string());
        }

        if !info_parts.is_empty() {
            print!(" {}", info_parts.join(" "));
        }
    }

    /// Prints a helpful legend.
    fn print_legend(&self) {
        let mut legend_items = Vec::new();

        // Build the legend dynamically based on active options.
        legend_items.push(format!(
            "{} = {}",
            "alias!".bright_blue(),
            t!("tree.legend.alias")
        ));
        legend_items.push(format!(
            "{} = {}",
            t!("tree.label.last_used").yellow(),
            t!("tree.legend.last_used")
        ));

        if self.options.show_health {
            legend_items.push(format!(
                "{} = {}",
                t!("tree.label.broken_path").yellow(),
                t!("tree.legend.broken_path")
            ));
        }

        if !legend_items.is_empty() {
            println!("\nLegend: {}", legend_items.join(", ").dimmed());
        }
    }
}

/// The public entry point for displaying the project tree.
pub fn display_project_tree(
    index: &GlobalIndex,
    start_node_uuid: Option<Uuid>,
    options: &DisplayOptions,
) {
    if index.projects.is_empty() {
        println!("\n{}", t!("tree.info.no_projects"));
        return;
    }

    let renderer = TreeRenderer::new(index, options);
    renderer.render_tree(start_node_uuid);
}

===== core\index_manager.rs =====
use crate::constants::PROJECT_REF_FILENAME;
use crate::core::paths;
use crate::models::{GlobalIndex, IndexEntry, ProjectRef};

use std::collections::HashSet;
use std::error::Error;
use std::io::ErrorKind;
use std::{fs, path::Path, path::PathBuf};
use thiserror::Error;
use uuid::Uuid;

use crate::constants::GLOBAL_INDEX_FILENAME;

/// The special, well-known UUID for the virtual "global" project.
pub const GLOBAL_PROJECT_UUID: Uuid = Uuid::nil();

/// Represents errors that can occur during operations on the `GlobalIndex`.
#[derive(Error, Debug)]
pub enum IndexError {
    /// A filesystem I/O error occurred.
    #[error("Filesystem Error: {0}")]
    Io(#[from] std::io::Error),
    /// An error occurred related to filesystem paths (e.g., config directory not found).
    #[error("Path error: {0}")]
    Path(#[from] crate::core::paths::PathError),
    /// An error occurred while serializing data to TOML format.
    #[error("Failed to serialize to TOML: {0}")]
    TomlSerialize(#[from] toml::ser::Error),
    /// An attempt was made to create or rename a project with a name that is already
    /// used by a sibling under the same parent.
    #[error("Project name '{name}' is already in use by another child of the same parent.")]
    NameAlreadyExists {
        /// The conflicting name.
        name: String,
    },
    /// An error occurred while deserializing data from `bincode` binary format.
    #[error("Failed to decode from binary format: {0}")]
    BincodeDecode(#[from] bincode::error::DecodeError),
    /// An error occurred while serializing data to `bincode` binary format.
    #[error("Failed to encode to binary format: {0}")]
    BincodeEncode(#[from] bincode::error::EncodeError),
    /// A project in the index references a parent UUID that does not exist.
    #[error(
        "Broken parent link: project '{child_uuid}' points to a non-existent parent '{missing_parent_uuid}'."
    )]
    BrokenParentLink {
        /// The UUID of the child project with the broken link.
        child_uuid: Uuid,
        /// The UUID of the parent that could not be found.
        missing_parent_uuid: Uuid,
    },
    /// A specified UUID could not be found in the index.
    #[error("Project with UUID '{uuid}' not found in global index.")]
    ProjectNotFoundInIndex {
        /// The UUID that was not found.
        uuid: Uuid,
    },
    /// A `link` operation was attempted that would create a circular dependency
    /// (e.g., making a project a child of one of its own descendants).
    #[error(
        "Circular dependency detected: cannot link project '{cycle_node_uuid}' as it would create a cycle."
    )]
    CircularDependency {
        /// The UUID of the project that would cause the cycle.
        cycle_node_uuid: Uuid,
    },
}

type IndexResult<T> = Result<T, IndexError>;

/// Loads the global index and ensures that the entry for the 'global' project exists.
pub fn load_and_ensure_global_project() -> IndexResult<GlobalIndex> {
    let mut index = load_global_index_internal()?;
    if let std::collections::hash_map::Entry::Vacant(e) = index.projects.entry(GLOBAL_PROJECT_UUID)
    {
        log::warn!("'global' project not found in index. Creating it now.");
        let config_dir = paths::get_axes_config_dir()?;

        let global_entry = IndexEntry {
            name: "global".to_string(),
            path: config_dir.clone(),
            parent: None,
            config_hash: None,
            cache_dir: None,
            last_used_child: None,
        };
        e.insert(global_entry.clone());

        index.projects.insert(GLOBAL_PROJECT_UUID, global_entry);

        // If alias `g` does not exist, create it.
        if !index.aliases.contains_key("g") {
            log::debug!("Creando alias por defecto 'g' para el proyecto global.");
            index.aliases.insert("g".to_string(), GLOBAL_PROJECT_UUID);
        }

        // 1. Create the default `axes.toml`.
        let axes_dir = config_dir.join(crate::constants::AXES_DIR);
        fs::create_dir_all(&axes_dir)?;
        let config_path = axes_dir.join(crate::constants::PROJECT_CONFIG_FILENAME);
        if !config_path.exists() {
            let default_config = crate::models::ProjectConfig::new();
            // Add default configuration for 'open'
            let toml_string = toml::to_string_pretty(&default_config)?;
            fs::write(config_path, toml_string)?;
        }

        // 2. Create its `project_ref.bin`.
        let project_ref = crate::models::ProjectRef {
            self_uuid: GLOBAL_PROJECT_UUID,
            parent_uuid: None,
            name: "global".to_string(),
        };
        write_project_ref(&config_dir, &project_ref)?;

        // Save the updated index.
        save_global_index(&index)?;
    }
    Ok(index)
}

/// Adds a new project entry to the index.
///
/// # Arguments
/// * `index` - A mutable reference to the `GlobalIndex`.
/// * `name` - The simple name for the new project.
/// * `path` - The absolute path to the new project's root directory.
/// * `parent_uuid` - An optional UUID of the parent project. Defaults to the global project.
///
/// # Errors
/// Returns `IndexError::NameAlreadyExists` if a sibling with the same name already exists.
pub fn add_project_to_index(
    index: &mut GlobalIndex,
    name: String,
    path: PathBuf,
    parent_uuid: Option<Uuid>,
) -> IndexResult<(Uuid, IndexEntry)> {
    let final_parent_uuid = parent_uuid.unwrap_or(GLOBAL_PROJECT_UUID);

    let name_exists = index
        .projects
        .values()
        .any(|entry| entry.parent == Some(final_parent_uuid) && entry.name == name);

    if name_exists {
        return Err(IndexError::NameAlreadyExists { name });
    }

    let new_uuid = Uuid::new_v4();
    let new_entry = IndexEntry {
        name,
        path,
        parent: Some(final_parent_uuid),
        config_hash: None,
        cache_dir: None,
        last_used_child: None,
    };

    index.projects.insert(new_uuid, new_entry.clone());
    Ok((new_uuid, new_entry))
}

fn load_global_index_internal() -> IndexResult<GlobalIndex> {
    let path = paths::get_axes_config_dir()?.join(GLOBAL_INDEX_FILENAME);
    if !path.exists() {
        return Ok(GlobalIndex::default());
    }
    let bytes = fs::read(&path)?;
    // Use bincode to deserialize from bytes
    let (index, _): (GlobalIndex, usize) =
        bincode::serde::decode_from_slice(&bytes, bincode::config::standard())?;
    Ok(index)
}

/// Saves the global index to disk.
pub fn save_global_index(index: &GlobalIndex) -> IndexResult<()> {
    let path = paths::get_axes_config_dir()?.join(GLOBAL_INDEX_FILENAME);
    // Use bincode to serialize to bytes
    let bytes = bincode::serde::encode_to_vec(index, bincode::config::standard())?;
    fs::write(path, bytes)?;
    Ok(())
}

/// Reads and deserializes a project's local identity from its `.axes/project_ref.bin` file.
///
/// # Arguments
/// * `project_root` - The absolute path to the project's root directory.
pub fn read_project_ref(project_root: &Path) -> IndexResult<ProjectRef> {
    let ref_path = project_root
        .join(crate::constants::AXES_DIR)
        .join(PROJECT_REF_FILENAME);
    let bytes = fs::read(&ref_path)?;
    let (project_ref, _): (ProjectRef, usize) =
        bincode::serde::decode_from_slice(&bytes, bincode::config::standard())?;
    Ok(project_ref)
}

/// Serializes and writes a project's local identity to its `.axes/project_ref.bin` file.
///
/// # Arguments
/// * `project_root` - The absolute path to the project's root directory.
/// * `project_ref` - The `ProjectRef` struct to write.
pub fn write_project_ref(project_root: &Path, project_ref: &ProjectRef) -> IndexResult<()> {
    let axes_dir = project_root.join(crate::constants::AXES_DIR);
    if !axes_dir.exists() {
        fs::create_dir_all(&axes_dir)?;
    }
    let ref_path = axes_dir.join(PROJECT_REF_FILENAME);
    // **CORRECTION**: Use `?` directly, as `IndexError` can now be converted from `bincode::error::EncodeError`.
    let bytes = bincode::serde::encode_to_vec(project_ref, bincode::config::standard())?;
    fs::write(ref_path, bytes)?;
    Ok(())
}

/// Traverses up the parent chain from a starting node to detect a circular dependency.
///
/// # Arguments
/// * `start_node_uuid` - The UUID of the project from which to start traversing upwards.
/// * `index` - An immutable reference to the `GlobalIndex`.
///
/// # Returns
/// `Ok(Some(Uuid))` containing the UUID of the repeated node if a cycle is found.
/// `Ok(None)` if no cycle is detected.
pub fn find_cycle_from_node(
    start_node_uuid: Uuid,
    index: &GlobalIndex,
) -> Result<Option<Uuid>, IndexError> {
    let mut current_uuid_opt = Some(start_node_uuid);
    let mut visited_nodes = HashSet::new();

    while let Some(current_uuid) = current_uuid_opt {
        // If we cannot insert the node, it's because it was already there. Cycle detected!
        if !visited_nodes.insert(current_uuid) {
            return Ok(Some(current_uuid));
        }

        // Move to parent
        match index.projects.get(&current_uuid) {
            Some(current_entry) => {
                current_uuid_opt = current_entry.parent;
            }
            None => {
                // The current node does not exist in the index, meaning `parent_uuid`
                // from a previous node points to a non-existent entry (broken link).
                // Or we have safely reached the root (parent: None).
                if current_uuid != GLOBAL_PROJECT_UUID {
                    // If it's not the global project and has no parent, it's a broken link
                    // (since all should point to global or another project).
                    // This should be `current_entry.parent` of the previous node.
                    // This is a bit more complex to report accurately at this point.
                    // For now, we assume `index.projects.get(&current_uuid)` would already detect it.
                    // The error would propagate earlier.
                }
                return Ok(None); // We reached a root or an endpoint without a cycle.
            }
        }
    }

    Ok(None) // The loop never executed (start_node_uuid was None) or no cycle was found.
}

/// Atomically links a project to a new parent within the index.
///
/// This operation is "transactional" in nature and performs several critical steps:
/// 1.  **Safety Checks:** It validates that the link operation is valid by checking for:
///     -   Attempts to link a project to itself.
///     -   Circular dependencies (e.g., attempting to make a parent a child of its own descendant).
///     -   Name collisions under the new parent.
/// 2.  **In-Memory Index Update:** If all checks pass, it modifies the `parent` UUID of the
///     project's `IndexEntry` within the `GlobalIndex`.
/// 3.  **Local State Synchronization:** It immediately updates the `.axes/project_ref.bin` file
///     of the moved project to reflect the new parentage.
///
/// If updating the local `project_ref.bin` fails, an error is logged, but the in-memory
/// change is *not* rolled back. This maintains consistency with the principle that the in-memory
/// index is the source of truth for the current session, and discrepancies can be fixed
/// with the `axes repair` command.
///
/// # Arguments
/// * `index` - A mutable reference to the `GlobalIndex`.
/// * `project_to_move_uuid` - The `Uuid` of the project being moved.
/// * `new_parent_uuid` - The `Uuid` of the new parent project.
///
/// # Errors
/// Returns an `IndexError` if any safety check fails.
pub fn link_project(
    index: &mut GlobalIndex,
    project_to_move_uuid: Uuid,
    new_parent_uuid: Uuid,
) -> IndexResult<()> {
    // --- 1. Pre-flight Safety Checks ---

    // A project cannot be its own parent.
    if project_to_move_uuid == new_parent_uuid {
        return Err(IndexError::CircularDependency {
            cycle_node_uuid: project_to_move_uuid,
        });
    }

    // Anti-Cycle Validation: A cycle is created if the new parent is already a
    // descendant of the project we are trying to move.
    let descendants = get_all_descendants(index, project_to_move_uuid);
    if descendants.contains(&new_parent_uuid) {
        log::error!(
            "Link operation aborted: circular dependency detected. Cannot make project {} a child of its own descendant {}.",
            project_to_move_uuid,
            new_parent_uuid
        );
        return Err(IndexError::CircularDependency {
            cycle_node_uuid: new_parent_uuid,
        });
    }

    // Sibling Name Collision Validation: Check if another child with the same name
    // already exists under the new parent.
    let project_to_move_entry =
        index
            .projects
            .get(&project_to_move_uuid)
            .ok_or(IndexError::ProjectNotFoundInIndex {
                uuid: project_to_move_uuid,
            })?;

    let project_name_to_move = project_to_move_entry.name.clone();
    let project_root = project_to_move_entry.path.clone();

    if is_sibling_name_taken(
        index,
        new_parent_uuid,
        &project_name_to_move,
        Some(project_to_move_uuid),
    ) {
        return Err(IndexError::NameAlreadyExists {
            name: project_name_to_move,
        });
    }

    // --- 2. Execute Transactional Update ---

    // Step 2a: Modify the in-memory index. This is the primary state change.
    // We can safely unwrap here because we've already fetched the entry above.
    let entry_to_modify = index
        .projects
        .get_mut(&project_to_move_uuid)
        .expect("Project to move should exist in index as it was checked before");
    entry_to_modify.parent = Some(new_parent_uuid);
    log::debug!(
        "Updated parent of project {} to {} in memory.",
        project_to_move_uuid,
        new_parent_uuid
    );

    // Step 2b: Synchronize the change to the local `.axes/project_ref.bin`.
    log::debug!(
        "Updating local project_ref.bin for linked project {}",
        project_to_move_uuid
    );
    match get_or_create_project_ref(&project_root, project_to_move_uuid, index) {
        Ok(mut project_ref) => {
            project_ref.parent_uuid = Some(new_parent_uuid);
            if let Err(e) = write_project_ref(&project_root, &project_ref) {
                // This is a non-fatal error for the operation itself, but critical to log.
                // It indicates a desynchronization between the global index and the local state.
                log::error!(
                    "Failed to update project_ref.bin for '{}' at '{}': {}. The global index is now ahead of the local ref. Run 'axes repair' to fix.",
                    project_name_to_move,
                    project_root.display(),
                    e
                );
            }
        }
        Err(e) => {
            log::error!(
                "Could not read or create project_ref.bin for '{}' at '{}': {}. Local ref is out of sync.",
                project_name_to_move,
                project_root.display(),
                e
            );
        }
    }

    Ok(())
}

/// Reads a project's local `.axes/project_ref.bin` file.
/// If the file does not exist, it regenerates it using data from the `GlobalIndex`
/// and writes it to disk, ensuring the local state is synchronized.
///
/// # Arguments
/// * `project_root` - The path to the project's root directory.
/// * `uuid` - The UUID of the project.
/// * `index` - An immutable reference to the `GlobalIndex`.
pub fn get_or_create_project_ref(
    project_root: &Path,
    uuid: Uuid,
    index: &GlobalIndex,
) -> IndexResult<ProjectRef> {
    match read_project_ref(project_root) {
        Ok(project_ref) => Ok(project_ref), // The file exists and is valid.
        Err(e) => {
            // Check if the error is specifically "File not found".
            if let Some(io_err) = e.source().and_then(|s| s.downcast_ref::<std::io::Error>())
                && io_err.kind() == ErrorKind::NotFound
            {
                log::warn!(
                    "Local reference file (project_ref.bin) does not exist for project at '{}'. A new one will be created.",
                    project_root.display()
                );

                // Reconstruct information from the index.
                let entry = index
                    .projects
                    .get(&uuid)
                    .ok_or(IndexError::ProjectNotFoundInIndex { uuid })?;

                let new_ref = ProjectRef {
                    self_uuid: uuid,
                    parent_uuid: entry.parent,
                    name: entry.name.clone(),
                };

                // Write the newly created file for future operations.
                write_project_ref(project_root, &new_ref)?;

                return Ok(new_ref);
            }
            // If the error is anything else, we propagate it.
            Err(e)
        }
    }
}

/// Traverses the project graph downwards to find all descendants of a given project.
///
/// # Arguments
/// * `index` - An immutable reference to the `GlobalIndex`.
/// * `start_uuid` - The UUID of the project from which to start the search.
pub fn get_all_descendants(index: &GlobalIndex, start_uuid: Uuid) -> Vec<Uuid> {
    let mut descendants = Vec::new();
    let mut to_visit = vec![start_uuid];

    while let Some(current_uuid) = to_visit.pop() {
        let children: Vec<Uuid> = index
            .projects
            .iter()
            .filter(|(_, entry)| entry.parent == Some(current_uuid))
            .map(|(uuid, _)| *uuid)
            .collect();

        descendants.extend(&children);
        to_visit.extend(children);
    }
    descendants
}

/// Removes a list of projects from the index by their UUIDs.
///
/// # Arguments
/// * `index` - A mutable reference to the `GlobalIndex`.
/// * `uuids_to_remove` - A slice of UUIDs to remove from the index.
///
/// # Returns
/// The number of projects that were successfully removed.
pub fn remove_from_index(index: &mut GlobalIndex, uuids_to_remove: &[Uuid]) -> usize {
    let mut removed_count = 0;
    let remove_set: std::collections::HashSet<Uuid> = uuids_to_remove.iter().cloned().collect();

    index.projects.retain(|uuid, _| {
        if remove_set.contains(uuid) {
            removed_count += 1;
            false
        } else {
            true
        }
    });

    removed_count
}

/// Reparents the direct children of a project, handling name collisions automatically.
/// Returns a list of warnings for any automatic renames that occurred.
pub fn reparent_children(
    index: &mut GlobalIndex,
    old_parent_uuid: Uuid,
    new_parent_uuid: Uuid,
) -> Result<Vec<String>, IndexError> {
    // Handle case where a project is reparented to itself (no-op).
    if old_parent_uuid == new_parent_uuid {
        return Ok(Vec::new());
    }

    let mut warnings = Vec::new();
    let old_parent_name = index
        .projects
        .get(&old_parent_uuid)
        .ok_or(IndexError::ProjectNotFoundInIndex {
            uuid: old_parent_uuid,
        })?
        .name
        .clone();

    // Collect (uuid, name) tuples directly to avoid repeated lookups.
    let children_to_move: Vec<(Uuid, String)> = index
        .projects
        .iter()
        .filter(|(_, entry)| entry.parent == Some(old_parent_uuid))
        .map(|(uuid, entry)| (*uuid, entry.name.clone()))
        .collect();

    if children_to_move.is_empty() {
        return Ok(warnings);
    }

    // Pre-calculate sibling names at the destination once.
    let new_sibling_names: HashSet<String> = index
        .projects
        .values()
        .filter(|e| e.parent == Some(new_parent_uuid))
        .map(|e| e.name.clone())
        .collect();

    for (child_uuid, original_child_name) in children_to_move {
        let mut final_child_name = original_child_name.clone();

        if new_sibling_names.contains(&final_child_name) {
            // Collision detected, try automatic rename
            let suggested_name = format!("{}_{}", old_parent_name, final_child_name);
            // Also check against other children being moved in the same batch
            if new_sibling_names.contains(&suggested_name) || {
                index
                    .projects
                    .get(&child_uuid)
                    .expect("Child UUID must exist in the index")
                    .name
                    != final_child_name
            } {
                return Err(IndexError::NameAlreadyExists {
                    name: suggested_name,
                });
            }

            warnings.push(format!(
                "Child '{}' was automatically renamed to '{}' to avoid collision.",
                final_child_name, suggested_name
            ));
            final_child_name = suggested_name;
        }

        // Apply changes
        let child_entry = index
            .projects
            .get_mut(&child_uuid)
            .expect("Child UUID must exist in the index");
        child_entry.name = final_child_name;
        child_entry.parent = Some(new_parent_uuid);
    }

    Ok(warnings)
}

/// Reconstructs a project's human-readable, slash-separated qualified name (e.g., `app/api/db`)
/// by traversing up the parent tree from a starting UUID.
///
/// # Arguments
/// * `start_uuid` - The UUID of the project whose name to build.
/// * `index` - An immutable reference to the `GlobalIndex`.
///
/// # Returns
/// `Some(String)` containing the qualified name, or `None` if a broken parent link is found.
pub fn build_qualified_name(start_uuid: Uuid, index: &GlobalIndex) -> Option<String> {
    // --- SPECIAL CASE: Handle the global project itself ---
    if start_uuid == GLOBAL_PROJECT_UUID {
        // The qualified name of the global project is just its name.
        return index
            .projects
            .get(&GLOBAL_PROJECT_UUID)
            .map(|e| e.name.clone());
    }

    let mut parts = Vec::with_capacity(8);
    let mut current_uuid_opt = Some(start_uuid);

    while let Some(current_uuid) = current_uuid_opt {
        if let Some(entry) = index.projects.get(&current_uuid) {
            // Stop traversing upwards when we reach a direct child of 'global'.
            // We add its name, but then we stop, to avoid the "global/" prefix.
            parts.push(entry.name.as_str());
            if entry.parent == Some(GLOBAL_PROJECT_UUID) {
                break;
            }
            current_uuid_opt = entry.parent;
        } else {
            // Broken parent link in the hierarchy.
            log::warn!(
                "Broken parent link detected while building qualified name for UUID: {}",
                start_uuid
            );
            return None;
        }
    }

    parts.reverse();
    Some(parts.join("/"))
}

// Alias Handlers

/// Sets or updates an alias in the index to point to a target UUID.
///
/// # Arguments
/// * `index` - A mutable reference to the `GlobalIndex`.
/// * `name` - The name of the alias.
/// * `target_uuid` - The UUID of the project the alias should point to.
pub fn set_alias(index: &mut GlobalIndex, name: String, target_uuid: Uuid) {
    index.aliases.insert(name, target_uuid);
}

/// Deletes an alias from the index.
///
/// # Arguments
/// * `index` - A mutable reference to the `GlobalIndex`.
/// * `name` - The name of the alias to remove.
///
/// # Returns
/// `true` if the alias existed and was removed, `false` otherwise.
pub fn remove_alias(index: &mut GlobalIndex, name: &str) -> bool {
    index.aliases.remove(name).is_some()
}

/// Checks if a sibling name is already taken under a specific parent.
/// If `self_uuid` is provided, it excludes that project from the check (used during rename).
pub fn is_sibling_name_taken(
    index: &GlobalIndex,
    parent_uuid: Uuid,
    name: &str,
    self_uuid: Option<Uuid>,
) -> bool {
    index.projects.iter().any(|(uuid, entry)| {
        entry.parent == Some(parent_uuid) && entry.name == name && (self_uuid != Some(*uuid))
    })
}

/// Atomically renames a project in the index and synchronizes its local `project_ref.bin`.
///
/// This function ensures that both the in-memory global index and the on-disk local
/// project identity are updated as a single logical operation.
///
/// # Arguments
/// * `index` - A mutable reference to the `GlobalIndex`.
/// * `target_uuid` - The `Uuid` of the project to rename.
/// * `new_name` - The new simple name for the project.
///
/// # Errors
/// Returns an `IndexError` if the project is not found or if the new name
/// collides with an existing sibling project.
pub fn rename_project(
    index: &mut GlobalIndex,
    target_uuid: Uuid,
    new_name: &str,
) -> IndexResult<()> {
    // 1. Get the entry and check for name collisions.
    let target_entry = index
        .projects
        .get(&target_uuid)
        .ok_or(IndexError::ProjectNotFoundInIndex { uuid: target_uuid })?;

    if is_sibling_name_taken(
        index,
        target_entry.parent.unwrap_or(GLOBAL_PROJECT_UUID),
        new_name,
        Some(target_uuid),
    ) {
        return Err(IndexError::NameAlreadyExists {
            name: new_name.to_string(),
        });
    }

    let project_root = target_entry.path.clone();

    // 2. Modify the in-memory index.
    // We can unwrap here because we've already confirmed the entry exists.
    let entry_to_modify = index
        .projects
        .get_mut(&target_uuid)
        .expect("Target UUID must exist in index as it was just checked");
    entry_to_modify.name = new_name.to_string();
    log::debug!(
        "Renamed project {} to '{}' in memory.",
        target_uuid,
        new_name
    );

    // 3. Synchronize the change to the local `project_ref.bin`.
    log::debug!(
        "Updating local project_ref.bin for renamed project {}",
        target_uuid
    );
    match get_or_create_project_ref(&project_root, target_uuid, index) {
        Ok(mut project_ref) => {
            project_ref.name = new_name.to_string();
            if let Err(e) = write_project_ref(&project_root, &project_ref) {
                log::error!(
                    "Failed to update project_ref.bin for '{}' at '{}': {}. Run 'axes repair' to fix.",
                    new_name,
                    project_root.display(),
                    e
                );
            }
        }
        Err(e) => {
            log::error!(
                "Could not read/create project_ref.bin for '{}' at '{}': {}. Local ref is out of sync.",
                new_name,
                project_root.display(),
                e
            );
        }
    }

    Ok(())
}

===== core\mod.rs =====
//! # Core
//!
//! This module contains the main logic of the application, including caching, color management,
//! commons, compiler, config loader, context resolver, graph display, index manager,
//! onboarding manager, parameters, paths, and task executor.

/// The cache module, responsible for caching configurations and other data.
pub mod cache;

/// The color module, which provides utilities for colorizing output.
pub mod color;

/// The commons module, which contains common utilities and data structures.
pub mod commons;

/// The compiler module, responsible for compiling `axes.toml` files into a serializable format.
pub mod compiler;

/// The config_loader module, which loads and resolves configurations.
pub mod config_loader;

/// The context_resolver module, which resolves the current context of the application.
pub mod context_resolver;

/// The `graph_display` module, which provides utilities for displaying graphs.
pub mod graph_display;

/// The `index_manager` module, which manages the global index of projects.
pub mod index_manager;

/// The `onboarding_manager` module, which manages the onboarding process for new users.
pub mod onboarding_manager;

/// The parameters module, which handles the parsing and resolution of parameters.
pub mod parameters;

/// The paths module, which provides utilities for working with file paths.
pub mod paths;

/// The task_executor module, which executes tasks defined in the configuration.
pub mod task_executor;

===== core\onboarding_manager.rs =====
use crate::{
    cli::handlers::commons,
    core::index_manager::{self, GLOBAL_PROJECT_UUID},
    models::{GlobalIndex, IndexEntry, ProjectRef},
    state::AppStateGuard,
};
use anyhow;
use colored::*;
use dialoguer::{Confirm, Input, theme::ColorfulTheme};
use std::{
    collections::HashSet,
    fs,
    path::{Path, PathBuf},
};
use thiserror::Error;
use uuid::Uuid;

// --- Error Handling ---

/// Represents errors that can occur during the project registration (`onboarding`) process.
#[derive(Error, Debug)]
pub enum OnboardingError {
    /// A filesystem I/O error occurred.
    #[error("Filesystem Error: {0}")]
    Io(#[from] std::io::Error),
    /// An error occurred while interacting with the global index.
    #[error("Index Error: {0}")]
    Index(#[from] crate::core::index_manager::IndexError),
    /// An error occurred during an interactive prompt.
    #[error("User Interface Error: {0}")]
    Dialoguer(#[from] dialoguer::Error),
    /// A generic, non-specific error.
    #[error("{0}")]
    Anyhow(#[from] anyhow::Error),
    /// The target directory for registration does not contain an `.axes/axes.toml` file.
    #[error(
        "The directory '{0}' does not appear to be an axes project (missing '.axes/axes.toml')."
    )]
    NotAnAxesProject(String),
    /// The user cancelled the registration process.
    #[error("Operation cancelled by user.")]
    Cancelled,
    /// In non-interactive mode (`--autosolve`), a project without a local `project_ref.bin` was found and skipped.
    #[error(
        "Cannot register a project without identity in --autosolve mode. Project at '{0}' was skipped."
    )]
    IdentitylessInAutosolve(String),
    /// A project with the resolved name already exists under the chosen parent.
    #[error("A project with the same name '{0}' already exists under the chosen parent.")]
    NameCollision(String),
    /// A project with the same UUID is already registered, but at a different filesystem path.
    #[error("A project with UUID '{0}' is already registered at a different path: '{1}'.")]
    UuidCollision(Uuid, String),
}

type OnboardingResult<T> = Result<T, OnboardingError>;

// --- Core Data Structures ---

/// Describes the source of a project's identity during the discovery phase.
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum IdentitySource {
    /// The project has a valid `.axes/project_ref.bin` file.
    ProjectRef(ProjectRef),
    /// The project has an `axes.toml` file but no `project_ref.bin`.
    TomlOnly,
    /// The directory is not a valid axes project (missing `axes.toml`).
    NotFound,
}

/// Represents a potential project found on the filesystem that could be registered.
#[derive(Debug, Clone)]
pub struct OnboardingCandidate {
    /// The absolute, canonical path to the project's root directory.
    pub path: PathBuf,
    /// How the project's identity was determined.
    pub identity_source: IdentitySource,
    /// The final, resolved simple name for the project after handling conflicts or user input.
    pub resolved_name: Option<String>,
    /// The final, resolved UUID of the project's parent.
    pub resolved_parent_uuid: Option<Uuid>,
    /// The final, resolved UUID for the project itself.
    pub resolved_uuid: Option<Uuid>,
    /// A flag indicating if this candidate should be registered. Can be set to `false` to skip it.
    pub should_register: bool,
}

impl OnboardingCandidate {
    /// Creates a new candidate by inspecting a given path for `axes.toml` and `project_ref.bin`.
    pub fn new(path: &Path) -> OnboardingResult<Self> {
        let canonical_path = dunce::canonicalize(path)?;
        if !canonical_path.join(".axes/axes.toml").exists() {
            return Ok(Self::invalid(canonical_path, IdentitySource::NotFound));
        }
        let identity_source = match index_manager::read_project_ref(&canonical_path) {
            Ok(pref) => IdentitySource::ProjectRef(pref),
            Err(_) => IdentitySource::TomlOnly,
        };
        Ok(Self {
            path: canonical_path,
            identity_source,
            resolved_name: None,
            resolved_parent_uuid: None,
            resolved_uuid: None,
            should_register: true,
        })
    }
    fn invalid(path: PathBuf, source: IdentitySource) -> Self {
        Self {
            path,
            identity_source: source,
            resolved_name: None,
            resolved_parent_uuid: None,
            resolved_uuid: None,
            should_register: false,
        }
    }
}

/// Configuration options for the `register_project` process.
#[derive(Debug)]
pub struct OnboardingOptions {
    /// If true, the process will be non-interactive and fail on any ambiguity or conflict.
    pub autosolve: bool,
    /// An optional parent UUID suggested via CLI arguments (e.g., `--parent`).
    pub suggested_parent_uuid: Option<Uuid>,
}

// --- Main Entry Point ---

/// The main entry point of the project registration process.
///
/// This function orchestrates a multi-phase process:
/// 1.  **Discovery**: Recursively scans the filesystem from a starting path to find all
///     unregistered axes projects.
/// 2.  **Resolution**: For each found project (`OnboardingCandidate`), it resolves its final name,
///     UUID, and parent, handling conflicts, missing identities, and user interaction.
/// 3.  **Confirmation**: If in interactive mode, it presents a plan of all projects to be
///     registered and asks for user confirmation.
/// 4.  **Action**: If confirmed, it modifies the `GlobalIndex` to register the new projects
///     and creates/updates their local `project_ref.bin` files.
///
/// # Arguments
/// * `path` - The starting path for the discovery scan.
/// * `state_guard` - A mutable guard to the application's global state.
/// * `options` - Configuration for the registration process (e.g., interactive or not).
pub fn register_project(
    path: &Path,
    state_guard: &mut AppStateGuard<'_>,
    options: &OnboardingOptions,
) -> OnboardingResult<()> {
    println!(
        "\n{}",
        format!(t!("register.info.starting_scan"), path = path.display()).bold()
    );

    // 1. DISCOVERY: Find all potential projects recursively.
    let mut candidates = discover_candidates(path, state_guard.index())?;
    if candidates.is_empty() {
        return Err(OnboardingError::NotAnAxesProject(
            path.display().to_string(),
        ));
    }

    // 2. Determine final names, parents, and UUIDs for each candidate.
    resolve_candidates(&mut candidates, state_guard, options)?;

    // Filter out candidates that were invalidated during resolution.
    candidates.retain(|c| c.should_register);

    if candidates.is_empty() {
        println!(
            "{}",
            t!("register.info.no_new_projects_to_register").yellow()
        );
        return Ok(());
    }

    // 3. CONFIRMATION (if interactive): Show the plan and get user approval.
    if !options.autosolve {
        present_plan_and_confirm(&candidates, state_guard.index())?;
    }

    // 4. ACTION: Perform the actual registration in the index.
    let mut registered_count = 0;
    for candidate in candidates {
        let (uuid, name, parent_uuid) = (
            candidate
                .resolved_uuid
                .expect("Candidate should have a resolved UUID at this stage"),
            candidate
                .resolved_name
                .expect("Candidate should have a resolved name at this stage"),
            candidate
                .resolved_parent_uuid
                .expect("Candidate should have a resolved parent UUID at this stage"),
        );

        let new_entry = IndexEntry {
            name: name.clone(),
            path: candidate.path.clone(),
            parent: Some(parent_uuid),
            ..Default::default()
        };
        state_guard.index_mut().projects.insert(uuid, new_entry);

        let new_ref = ProjectRef {
            self_uuid: uuid,
            parent_uuid: Some(parent_uuid),
            name,
        };
        index_manager::write_project_ref(&candidate.path, &new_ref)?;

        registered_count += 1;
    }

    println!(
        "{}",
        format!(t!("register.success.header"), count = registered_count).green()
    );
    Ok(())
}

// --- Phase 1: Discovery ---

/// Recursively scans for `axes.toml` files and creates candidates.
fn discover_candidates(
    start_path: &Path,
    index: &GlobalIndex,
) -> OnboardingResult<Vec<OnboardingCandidate>> {
    let mut candidates = Vec::new();
    let main_candidate = OnboardingCandidate::new(start_path)?;
    if !main_candidate.should_register {
        return Ok(vec![]);
    }

    // Pre-calculate a HashSet of existing paths for O(1) lookups.
    let existing_paths: HashSet<_> = index.projects.values().map(|p| &p.path).collect();

    let mut to_scan = vec![main_candidate.path.clone()];
    let mut seen_paths = HashSet::new();
    seen_paths.insert(main_candidate.path.clone());
    candidates.push(main_candidate);

    while let Some(path) = to_scan.pop() {
        // Use `read_dir` in a way that gracefully skips directories it can't access.
        if let Ok(entries) = fs::read_dir(path) {
            for entry in entries.filter_map(Result::ok) {
                let child_path = entry.path();
                // Check if it's a directory, not already seen, and not already in the index.
                if child_path.is_dir()
                    && !existing_paths.contains(&child_path)
                    && seen_paths.insert(child_path.clone())
                {
                    match OnboardingCandidate::new(&child_path) {
                        Ok(candidate) if candidate.should_register => {
                            to_scan.push(child_path);
                            candidates.push(candidate);
                        }
                        Ok(_) => {} // Not a valid candidate, just ignore.
                        Err(e) => log::warn!(
                            "Could not process potential project at '{}': {}",
                            child_path.display(),
                            e
                        ),
                    }
                }
            }
        }
    }
    Ok(candidates)
}

// --- Phase 2: Resolution ---

/// Iterates through candidates to resolve names, parents, and handle conflicts.
fn resolve_candidates(
    candidates: &mut [OnboardingCandidate],
    state_guard: &mut AppStateGuard<'_>,
    options: &OnboardingOptions,
) -> OnboardingResult<()> {
    // This set tracks (parent_uuid, name) tuples for projects being added in this batch
    // to prevent internal collisions.
    let mut pending_names: HashSet<(Uuid, String)> = HashSet::new();

    // --- Phase 1: Resolve all identities first ---
    // We do this in a separate loop to ensure all `resolved_uuid` fields are populated
    // before we try to validate parent links in the next phase.
    for candidate in candidates.iter_mut() {
        if candidate.should_register {
            resolve_candidate_identity(candidate, state_guard.index(), options)?;
        }
    }

    // --- Pre-computation Step ---
    // Collect all UUIDs of candidates that are still valid for registration.
    // This avoids the mutable/immutable borrow conflict in the main loop.
    let valid_candidate_uuids: HashSet<Uuid> = candidates
        .iter()
        .filter_map(|c| {
            if c.should_register {
                c.resolved_uuid
            } else {
                None
            }
        })
        .collect();

    // --- Phase 2: Resolve parents and check for collisions ---
    for candidate in candidates.iter_mut() {
        if !candidate.should_register {
            continue;
        }

        // Resolve the parent, now passing the pre-computed set of valid UUIDs.
        let parent_uuid =
            resolve_candidate_parent(candidate, &valid_candidate_uuids, state_guard, options)?;
        candidate.resolved_parent_uuid = Some(parent_uuid);

        // --- Final Collision Check ---
        let name = candidate
            .resolved_name
            .as_ref()
            .expect("Candidate name should be resolved at this stage");

        // Check for collision with projects already in the global index.
        if index_manager::is_sibling_name_taken(state_guard.index(), parent_uuid, name, None) {
            return Err(OnboardingError::NameCollision(name.clone()));
        }

        // Check for collision with other projects being onboarded in this same batch.
        if !pending_names.insert((parent_uuid, name.clone())) {
            return Err(OnboardingError::NameCollision(name.clone()));
        }
    }

    Ok(())
}

/// Helper function to resolve the identity (UUID and name) of a single candidate.
/// Modifies the candidate in place.
fn resolve_candidate_identity(
    candidate: &mut OnboardingCandidate,
    index: &GlobalIndex,
    options: &OnboardingOptions,
) -> OnboardingResult<()> {
    match &candidate.identity_source {
        IdentitySource::ProjectRef(pref) => {
            if let Some(existing) = index.projects.get(&pref.self_uuid) {
                if existing.path != candidate.path {
                    return Err(OnboardingError::UuidCollision(
                        pref.self_uuid,
                        existing.path.display().to_string(),
                    ));
                }
                // Project is already registered at the correct path. Mark to skip.
                candidate.should_register = false;
                return Ok(());
            }
            candidate.resolved_uuid = Some(pref.self_uuid);
            candidate.resolved_name = Some(pref.name.clone());
        }
        IdentitySource::TomlOnly => {
            if options.autosolve {
                candidate.should_register = false;
                println!("{}", format!("Warning: Project at '{}' has no identity and was skipped in --autosolve mode.", candidate.path.display()).yellow());
                return Ok(());
            }

            println!(
                "{}",
                format!(
                    "\nProject at '{}' has no identity.",
                    candidate.path.display()
                )
                .yellow()
            );
            let name_prompt = t!("register.prompt.name_for_identityless");
            let default_name = candidate
                .path
                .file_name()
                .expect("Path should have a filename")
                .to_string_lossy()
                .to_string();

            // Loop to validate the name interactively
            loop {
                let input_name = Input::with_theme(&ColorfulTheme::default())
                    .with_prompt(name_prompt)
                    .default(default_name.clone())
                    .interact_text()?;

                match commons::validate_project_name(&input_name) {
                    Ok(name) => {
                        candidate.resolved_name = Some(name);
                        break;
                    }
                    Err(e) => println!("{}", format!("  Error: {}", e).red()),
                }
            }
            candidate.resolved_uuid = Some(Uuid::new_v4());
        }
        IdentitySource::NotFound => {
            candidate.should_register = false;
        }
    }
    Ok(())
}

/// Helper function to determine the parent UUID for a single candidate.
/// This function is now read-only with respect to the `candidate` itself.
fn resolve_candidate_parent(
    candidate: &OnboardingCandidate, // <-- Ahora es una referencia inmutable
    valid_candidate_uuids: &HashSet<Uuid>, // <-- Recibe el set pre-calculado
    state_guard: &mut AppStateGuard<'_>,
    options: &OnboardingOptions,
) -> OnboardingResult<Uuid> {
    // Check for a parent suggested via command-line flag first.
    if let Some(suggested_parent) = options.suggested_parent_uuid {
        return Ok(suggested_parent);
    }

    // Check if the parent from its `project_ref.bin` is valid.
    if let Some(pref_parent_uuid) = candidate
        .identity_source
        .as_project_ref()
        .and_then(|p| p.parent_uuid)
    {
        // A parent is valid if it's already in the index OR it's in our pre-computed set.
        let is_valid = state_guard.index().projects.contains_key(&pref_parent_uuid)
            || valid_candidate_uuids.contains(&pref_parent_uuid);

        if is_valid {
            return Ok(pref_parent_uuid);
        }

        // If the parent from the ref file is invalid, warn the user if interactive.
        if !options.autosolve {
            println!(
                "{}",
                format!(
                    t!("register.warning.invalid_parent"),
                    path = candidate.path.display()
                )
                .yellow()
            );
        }
    }

    // Fallback: Use autosolve default or launch interactive selection.
    if options.autosolve {
        Ok(GLOBAL_PROJECT_UUID)
    } else {
        Ok(commons::choose_parent_interactive(state_guard)?)
    }
}

// We can add a small helper on IdentitySource to make the code cleaner.
impl IdentitySource {
    fn as_project_ref(&self) -> Option<&ProjectRef> {
        if let Self::ProjectRef(pref) = self {
            Some(pref)
        } else {
            None
        }
    }
}

// --- Phase 3: Confirmation ---

/// Shows a summary of changes and asks for final user confirmation.
fn present_plan_and_confirm(
    candidates: &[OnboardingCandidate],
    index: &GlobalIndex,
) -> OnboardingResult<()> {
    println!("\n{}", t!("register.info.plan_header").bold());
    for candidate in candidates {
        let name = candidate
            .resolved_name
            .as_ref()
            .expect("Candidate to be registered must have a name");
        let parent_uuid = candidate
            .resolved_parent_uuid
            .expect("Candidate to be registered must have a parent");
        let parent_name =
            index_manager::build_qualified_name(parent_uuid, index).unwrap_or_default();
        println!(
            "  - {} '{}' {} '{}'",
            t!("register.info.plan_line_project"),
            name.cyan(),
            t!("register.info.plan_line_as_child_of"),
            parent_name.yellow()
        );
    }

    if !Confirm::with_theme(&ColorfulTheme::default())
        .with_prompt(t!("common.prompt.continue"))
        .default(true)
        .interact()?
    {
        return Err(OnboardingError::Cancelled);
    }
    Ok(())
}

===== core\parameters.rs =====
//! # Script Parameter Parsing and Resolution
//!
//! This module is responsible for the entire lifecycle of script parameter handling, from
//! parsing definitions in `axes.toml` to resolving them against user-provided CLI arguments.
//! It is divided into two main phases:
//!
//! 1.  **Definition Parsing (`ParameterDef`)**: Functions like `parse_parameter_token` are used
//!     by the compiler (`compiler.rs`) to transform parameter tokens (e.g., `<params::0(required)>`)
//!     into a structured `ParameterDef`. This captures the contract of the script.
//!
//! 2.  **Argument Resolution (`ArgResolver`)**: At runtime, the `ArgResolver` is instantiated.
//!     It takes the script's `ParameterDef`s and the user's CLI arguments. It then parses the
//!     CLI input, matches arguments to definitions, validates requirements, applies defaults,
//!     and prepares the final string values for substitution into the command.
//!
//! The system is designed for high performance, operating on string slices and avoiding
//! allocations wherever possible.

use crate::{
    core::commons::wrap_value,
    models::{ParameterDef, ParameterKind, ParameterModifiers},
};
use anyhow::{Context, Result, anyhow};
use colored::*;
use lazy_static::lazy_static;
use regex::Regex;
use std::{borrow::Cow, collections::HashMap};

lazy_static! {
    static ref PARAMETER_TOKEN_CONTENT_RE: Regex =
        Regex::new(r"^\s*([^(\s]+)\s*(?:\((.*)\))?\s*$").expect("Parameter regex should be valid");
}

lazy_static! {
    static ref MODIFIERS_RE: Regex =
        Regex::new(r#"\s*([^=,\s]+)(?:\s*=\s*(?:'([^']*)'|"([^"]*)"|([^,]*)))?\s*"#)
            .expect("Modifiers regex should be valid");
}

// --- DATA STRUCTS ---

/// A preliminary, intermediate representation of a token found during the initial parsing pass.
///
/// This enum is used internally by the compiler to distinguish between different token types
/// before the full, recursive expansion and compilation into `TemplateComponent`s begins.
/// It operates on borrowed string slices (`&'a str`) for maximum performance during the initial
/// tokenization phase.
#[derive(Debug)]
pub enum PreComponent<'a> {
    /// A static, literal part of the command string.
    Literal(&'a str),
    /// A reference to a variable, e.g., `<vars::my_var>`. The value is the variable name.
    Var(&'a str),
    /// A reference to another script, e.g., `<scripts::build>`. The value is the script name.
    Script(&'a str),
    /// A command to be executed whose output is substituted, e.g., `<run('...')>`.
    RunLiteral(&'a str),
    /// A user-defined parameter token, e.g., `<params::0(required)>`.
    Param {
        /// The full original token match, e.g., `<params::0(required)>`.
        full_match: &'a str,
        /// The inner content of the token, e.g., `0(required)`.
        spec: &'a str,
    },
    /// The generic parameters token, `<params>`.
    GenericParams,
}

/// Represents a single CLI argument and its consumption state.
#[derive(Debug, Clone, Copy)]
pub struct CliArgument<'a> {
    /// The string value of the argument, if it has one (e.g., for `--key value`).
    pub value: Option<&'a str>,
    /// A flag indicating whether this argument has been claimed by a `ParameterDef`.
    pub consumed: bool,
}

/// Contains and manages the state of all arguments passed via the CLI for a given script.
/// This struct is mutable and is consumed during the parameter resolution process.
#[derive(Debug, Clone)]
pub struct CliInputState<'a> {
    /// A vector of positional arguments in the order they appeared.
    positional: Vec<CliArgument<'a>>,
    /// A map of named arguments (flags), where the key is the flag itself (e.g., `"--verbose"`).
    named: HashMap<&'a str, CliArgument<'a>>,
}

/// An orchestrator that validates CLI arguments against parameter definitions and resolves their final values.
///
/// An instance of `ArgResolver` is created for each script execution. Its constructor performs all
/// the validation and resolution logic upfront. The rest of the application can then query it for
/// the final string values to be substituted into commands, without needing to know the details
/// of the resolution process.
#[derive(Debug)]
pub struct ArgResolver<'a> {
    /// A map from the original parameter token (e.g., `<params::0>`) to its final, resolved string value.
    resolved_values: HashMap<String, String>,
    /// A vector of all arguments that were not claimed by any specific `ParameterDef`. These are
    /// intended for the generic `<params>` token.
    unclaimed_args: Vec<&'a str>,
}

// --- PARSER DE DEFINICIONES (DE FASE 1) ---

/// Parses the content of a parameter token, e.g., "0(required)" or "target(alias='-t')".
/// This is called by the main expansion engine in `config_resolver`.
pub fn parse_parameter_token(original_token: &str, content: &str) -> Result<ParameterDef> {
    // [ADD] Handle the special case of `<params(...)>` which has no specifier.
    if content.starts_with('(') || content.is_empty() {
        let modifiers_str = if content.starts_with('(') {
            content
                .strip_prefix('(')
                .and_then(|s| s.strip_suffix(')'))
                .unwrap_or("")
        } else {
            content
        };

        let modifiers = parse_parameter_modifiers_from_str(modifiers_str)
            .with_context(|| format!("Failed to parse modifiers in token: {}", original_token))?;

        // We use a placeholder kind, as `<params>` doesn't have a name or index.
        return Ok(ParameterDef {
            kind: ParameterKind::Positional { index: usize::MAX }, // Special index
            modifiers,
            original_token: original_token.to_string(),
        });
    }

    let caps = PARAMETER_TOKEN_CONTENT_RE
        .captures(content)
        .ok_or_else(|| anyhow!("Invalid parameter format in token: {}", original_token))?;

    let specifier = caps
        .get(1)
        .expect("Regex specifier group must exist")
        .as_str();
    let modifiers_str = caps.get(2).map(|m| m.as_str());

    let kind = if let Ok(index) = specifier.parse::<usize>() {
        ParameterKind::Positional { index }
    } else {
        ParameterKind::Named {
            name: specifier.to_string(),
        }
    };

    let modifiers = match modifiers_str {
        Some(s) => parse_parameter_modifiers_from_str(s)
            .with_context(|| format!("Failed to parse modifiers in token: {}", original_token))?,
        None => ParameterModifiers::default(),
    };

    Ok(ParameterDef {
        kind,
        modifiers,
        original_token: original_token.to_string(),
    })
}

/// Parses a modifier string, e.g., "required, default='staging', literal".
pub fn parse_parameter_modifiers_from_str(s: &str) -> Result<ParameterModifiers> {
    log::debug!("Parsing modifiers string: '{}'", s);
    let mut modifiers = ParameterModifiers::default();
    if s.trim().is_empty() {
        return Ok(modifiers);
    }

    for caps in MODIFIERS_RE.captures_iter(s) {
        let key = caps.get(1).map_or("", |m| m.as_str()).trim();
        if key.is_empty() {
            continue;
        }

        let value = caps
            .get(2)
            .or(caps.get(3))
            .or(caps.get(4))
            .map(|m| m.as_str());

        if let Some(val) = value {
            match key {
                "default" => modifiers.default_value = Some(val.to_string()),
                "alias" => modifiers.alias = Some(val.to_string()),
                "map" => modifiers.map = Some(val.to_string()),
                _ => return Err(anyhow!("Unknown modifier key: '{}'", key)),
            }
        } else {
            match key {
                "required" => modifiers.required = true,
                "literal" => modifiers.literal = true,
                _ => {
                    return Err(anyhow!(
                        "Unknown boolean modifier: '{}' (or missing value)",
                        key
                    ));
                }
            }
        }
    }

    log::debug!("Parsed modifiers: {:?}", modifiers);
    Ok(modifiers)
}

// --- IMPLEMENTACIÓN DEL ESTADO DE LA CLI (FASE 2) ---

impl<'a> CliInputState<'a> {
    /// Parses CLI arguments into a structured, mutable state for consumption.
    ///
    /// This function handles basic parsing of positional arguments and named flags (both with and
    /// without values). It is highly optimized to work with string slices (`&str`) and performs
    /// zero heap allocations.
    ///
    /// # Arguments
    /// * `cli_params` - A slice of strings representing the arguments passed by the user for the script.
    pub fn new(cli_params: &'a [String]) -> Result<Self> {
        let mut positional = Vec::new();
        let mut named = HashMap::new();
        let mut params_iter = cli_params.iter().map(String::as_str).peekable();

        while let Some(param) = params_iter.next() {
            if param.starts_with('-') {
                let value = if let Some(next) = params_iter.peek() {
                    if !next.starts_with('-') {
                        params_iter.next()
                    } else {
                        None
                    }
                } else {
                    None
                };
                named.insert(
                    param,
                    CliArgument {
                        value,
                        consumed: false,
                    },
                );
            } else {
                positional.push(CliArgument {
                    value: Some(param),
                    consumed: false,
                });
            }
        }
        Ok(Self { positional, named })
    }

    /// Consumes the next available positional argument.
    ///
    /// # Arguments
    /// * `index` - The zero-based index of the positional argument to consume (e.g., `0` for the first one).
    ///
    /// # Returns
    /// `Some(&str)` containing the argument's value if found, or `None` otherwise.
    pub fn consume_positional(&mut self, index: usize) -> Option<&'a str> {
        // Find the n-th positional (unconsumed) argument.
        self.positional
            .iter_mut()
            .filter(|arg| !arg.consumed)
            .nth(index)
            .and_then(|arg| {
                arg.consumed = true;
                arg.value
            })
    }

    /// Consumes a named argument (flag), checking both its long name and its alias.
    ///
    /// # Arguments
    /// * `name` - The long name of the flag (e.g., "verbose" for `--verbose`).
    /// * `alias` - An optional short name for the flag (e.g., "-v").
    ///
    /// # Returns
    /// - `Ok(Some(Some(value)))` if the flag was present and had a value.
    /// - `Ok(Some(None))` if the flag was present but had no value.
    /// - `Ok(None)` if the flag was not present.
    /// - `Err` if both the name and its alias were provided.
    pub fn consume_named(
        &mut self,
        name: &str,          // e.g., "verbose"
        alias: Option<&str>, // e.g., "-v"
    ) -> Result<Option<Option<&'a str>>> {
        let long_flag = format!("--{}", name);

        // --- Step 1: Find the keys that are present (immutable borrows) ---
        let is_long_present = self.named.contains_key(long_flag.as_str());
        let is_alias_present = alias.is_some_and(|a| self.named.contains_key(a));

        // --- Step 2: Check for conflicts ---
        if is_long_present && is_alias_present {
            return Err(anyhow!(
                "Conflict: Both flag '{}' and its alias '{}' were provided.",
                long_flag.cyan(),
                alias
                    .expect("Alias should exist here due to is_alias_present check")
                    .cyan()
            ));
        }

        // --- Step 3: Determine which key to use (if any) ---
        // We create an owned String here to hold the key, breaking the borrow chain.
        let key_to_use: Option<String> = if is_long_present {
            Some(long_flag)
        } else if is_alias_present {
            alias.map(|s| s.to_string())
        } else {
            None
        };

        // --- Step 4: Perform the mutable borrow ---
        // At this point, there are no active immutable borrows of `self.named`.
        if let Some(key) = key_to_use {
            let key_str: &str = key.as_str();
            if let Some(arg) = self.named.get_mut(key_str)
                && !arg.consumed
            {
                arg.consumed = true;
                return Ok(Some(arg.value));
            }
        }

        Ok(None)
    }

    /// Collects all arguments that were not consumed by `consume_positional` or `consume_named`.
    ///
    /// # Returns
    /// A tuple containing a vector of the unconsumed argument strings and a boolean indicating
    /// if there were any.
    pub fn get_unconsumed_values(&self) -> (Vec<&'a str>, bool) {
        let mut parts = Vec::new();
        let mut had_unconsumed = false;

        for arg in self.positional.iter().filter(|a| !a.consumed) {
            parts.push(arg.value.expect("Positional argument must have a value"));
            had_unconsumed = true;
        }

        let mut sorted_named_keys: Vec<_> = self.named.keys().copied().collect();
        sorted_named_keys.sort_unstable();

        for key in sorted_named_keys {
            if let Some(arg) = self.named.get(key).filter(|a| !a.consumed) {
                parts.push(key);
                if let Some(val) = arg.value {
                    parts.push(val);
                }
                had_unconsumed = true;
            }
        }
        (parts, had_unconsumed)
    }
}

impl<'a> ArgResolver<'a> {
    /// Creates a new `ArgResolver` by validating CLI arguments against script definitions.
    ///
    /// This constructor is the main entry point for the resolution phase. It orchestrates the
    /// entire process of parsing CLI input, matching it against the script's contract
    /// (`definitions`), checking for required parameters, applying defaults, and preparing
    /// the final substitution values.
    ///
    /// # Arguments
    /// * `definitions` - A slice of `ParameterDef`s that define the script's expected arguments.
    /// * `cli_params` - The raw string arguments provided by the user for the script.
    /// * `has_generic_params` - A flag indicating if the script contains a generic `<params>` token.
    pub fn new(
        definitions: &[ParameterDef],
        cli_params: &'a [String],
        has_generic_params: bool,
    ) -> Result<Self> {
        // CliInputState now operates on slices, performing zero allocations.
        let mut cli_state = CliInputState::new(cli_params)?;
        let mut resolved_values = HashMap::with_capacity(definitions.len());

        // --- 1. Upfront Validation for Conflicting Flags ---
        // This check prevents logic errors later on.
        for def in definitions {
            if let ParameterKind::Named { name } = &def.kind
                && let Some(alias) = &def.modifiers.alias
                && cli_state.named.contains_key(name.as_str())
                && cli_state.named.contains_key(alias.as_str())
            {
                return Err(anyhow!(
                    "Conflict: Both flag '--{}' and its alias '{}' were provided.",
                    name.cyan(),
                    alias.cyan()
                ));
            }
        }

        // --- 2. Resolution Loop for Each Parameter Definition ---
        for def in definitions {
            if (matches!(def.kind, ParameterKind::Positional { index } if index == usize::MAX))
                || resolved_values.contains_key(&def.original_token)
            {
                continue;
            }

            let final_string: String = match &def.kind {
                ParameterKind::Positional { index } => {
                    // Positional logic is correct and remains unchanged.
                    let cli_value = cli_state.consume_positional(*index);
                    if def.modifiers.required && cli_value.is_none() {
                        return Err(anyhow!(
                            "Positional argument at index {} is required but was not provided.",
                            index
                        ));
                    }
                    let final_value: Option<Cow<'a, str>> =
                        cli_value.map(Cow::Borrowed).or_else(|| {
                            def.modifiers
                                .default_value
                                .as_ref()
                                .map(|s| Cow::Owned(s.clone()))
                        });
                    final_value.map_or(String::new(), |val| {
                        if def.modifiers.literal {
                            wrap_value(&val)
                        } else {
                            val.into_owned()
                        }
                    })
                }
                ParameterKind::Named { name } => {
                    // --- FINAL, SIMPLE, AND CORRECT LOGIC FOR NAMED PARAMETERS ---
                    let alias = def.modifiers.alias.as_deref();
                    let cli_presence = cli_state.consume_named(name, alias)?;

                    // Rule 1: Handle absent flag.
                    if cli_presence.is_none() {
                        if def.modifiers.required {
                            return Err(anyhow!(
                                "Flag '--{}' is required but was not provided.",
                                name
                            ));
                        }
                        // Not required and not present -> expands to nothing.
                        String::new()
                    } else {
                        // At this point, we know the flag was provided.

                        // Rule 2: Determine the final value.
                        // `cli_presence` is `Some(Option<&'a str>)`.
                        // `.flatten()` converts it to `Option<&'a str>`.
                        let final_value = cli_presence.flatten().map(Cow::Borrowed).or_else(|| {
                            def.modifiers
                                .default_value
                                .as_ref()
                                .map(|s| Cow::Owned(s.clone()))
                        });

                        let value_maybe_wrapped = if def.modifiers.literal {
                            final_value.as_ref().map(|v| Cow::Owned(wrap_value(v)))
                        } else {
                            final_value
                        };

                        // Rule 3 & 4: Format output based on `map`.
                        if let Some(map_str) = &def.modifiers.map {
                            // `map` is defined.
                            if let Some(val) = value_maybe_wrapped {
                                if map_str.is_empty() {
                                    val.into_owned()
                                } else {
                                    format!("{}{}", map_str, val)
                                }
                            } else {
                                // Flag was present without value and has no default.
                                // A `map` without a value results in an empty string.
                                String::new()
                            }
                        } else {
                            // `map` is NOT defined (pass-through mode).
                            let flag_name = format!("--{}", name);
                            match value_maybe_wrapped {
                                Some(val) => format!("{} {}", flag_name, val),
                                None => flag_name,
                            }
                        }
                    }
                }
            };
            resolved_values.insert(def.original_token.clone(), final_string);
        }

        // --- 3. Handle Unconsumed Arguments for the generic `<params>` token ---
        let (unclaimed_args, had_unconsumed) = cli_state.get_unconsumed_values();
        if had_unconsumed && !has_generic_params {
            return Err(anyhow!(
                "{} The script does not define a generic `<params>` token to accept them.\nProvided unhandled arguments: {}",
                "Error: Unexpected arguments were provided.".red(),
                unclaimed_args.join(" ").yellow()
            ));
        }

        Ok(ArgResolver {
            resolved_values,
            unclaimed_args,
        })
    }

    /// Retrieves the final, resolved string for a specific parameter token (e.g., `<params::0>`).
    pub fn get_specific_value(&self, original_token: &str) -> Option<&str> {
        self.resolved_values.get(original_token).map(String::as_str)
    }

    /// Retrieves a slice of all unconsumed arguments, to be used by the generic `<params>` token.
    /// This is a zero-copy operation.
    pub fn get_generic_values(&self) -> &[&'a str] {
        &self.unclaimed_args
    }
}

// MARK: --- UNIT TESTS ---

#[cfg(test)]
mod tests {
    use super::*;

    // --- Helper to create a Vec<String> from &str slices ---
    fn to_cli_params(params: &[&str]) -> Vec<String> {
        params.iter().map(|s| s.to_string()).collect()
    }

    // --- `parse_parameter_modifiers_from_str` Tests ---
    #[test]
    fn test_parse_modifiers() {
        let modifiers = parse_parameter_modifiers_from_str("required, default='latest', literal")
            .expect("Parsing static modifier string should succeed");
        assert!(modifiers.required);
        assert!(modifiers.literal);
        assert_eq!(modifiers.default_value.as_deref(), Some("latest"));
        assert!(modifiers.alias.is_none());
    }

    #[test]
    fn test_parse_modifiers_with_alias_and_map() {
        let modifiers = parse_parameter_modifiers_from_str("alias = '-t', map='--tag='")
            .expect("Parsing static string should succeed");
        assert!(!modifiers.required);
        assert_eq!(modifiers.alias.as_deref(), Some("-t"));
        assert_eq!(modifiers.map.as_deref(), Some("--tag="));
    }

    // --- `CliInputState` Tests ---
    #[test]
    fn test_cli_input_state_parsing() {
        let params = to_cli_params(&[
            "pos0",
            "--named1",
            "val1",
            "-s",
            "--bool-flag",
            "val2",
            "pos1",
        ]);
        let state = CliInputState::new(&params).expect("Parsing params should succeed in test");

        assert_eq!(state.positional.len(), 2);
        assert_eq!(state.positional.first().and_then(|a| a.value), Some("pos0"));

        assert_eq!(state.positional.get(1).and_then(|a| a.value), Some("pos1"));

        assert_eq!(state.named.len(), 3);
        assert_eq!(
            state.named.get("--named1").and_then(|a| a.value),
            Some("val1")
        );
        assert_eq!(
            state
                .named
                .get("-s")
                .expect("Flag should exist in test state")
                .value,
            None
        );
        assert_eq!(
            state
                .named
                .get("--bool-flag")
                .expect("Flag should exist in test state")
                .value,
            Some("val2".to_string()).as_deref()
        );
    }

    // --- `ArgResolver` Full Logic Tests ---

    // Test Positional Parameters
    #[test]
    fn test_resolver_positional_basic() {
        let defs =
            [parse_parameter_token("<p::0>", "0").expect("Parsing static token should succeed")];
        let params = to_cli_params(&["hello"]);
        let resolver = ArgResolver::new(&defs, &params, false)
            .expect("Resolver creation should succeed with valid inputs");
        assert_eq!(resolver.get_specific_value("<p::0>"), Some("hello"));
    }

    #[test]
    fn test_resolver_positional_required_fail() {
        let defs = [parse_parameter_token("<p::0(required)>", "0(required)")
            .expect("Parsing static token should succeed")];
        let params = to_cli_params(&[]);
        let result = ArgResolver::new(&defs, &params, false);
        assert!(result.is_err());
        assert!(
            result
                .expect_err("Resolution should fail for missing required param")
                .to_string()
                .contains("is required")
        );
    }

    #[test]
    fn test_resolver_positional_default() {
        let defs = [
            parse_parameter_token("<p::0(default='world')>", "0(default='world')")
                .expect("Parsing static token should succeed"),
        ];
        let params = to_cli_params(&[]);
        let resolver = ArgResolver::new(&defs, &params, false)
            .expect("Resolver creation should succeed with valid inputs");
        assert_eq!(
            resolver.get_specific_value("<p::0(default='world')>"),
            Some("world")
        );
    }

    // Test Named Parameters (Flags)
    #[test]
    fn test_resolver_named_simple_pass_through() {
        let defs = [parse_parameter_token("<p::verbose>", "verbose")
            .expect("Parsing static token should succeed")];
        let params = to_cli_params(&["--verbose"]);
        let resolver = ArgResolver::new(&defs, &params, false)
            .expect("Resolver creation should succeed with valid inputs");
        assert_eq!(
            resolver.get_specific_value("<p::verbose>"),
            Some("--verbose")
        );
    }

    #[test]
    fn test_resolver_named_with_value_pass_through() {
        let defs =
            [parse_parameter_token("<p::env>", "env")
                .expect("Parsing static token should succeed")];
        let params = to_cli_params(&["--env", "staging"]);
        let resolver = ArgResolver::new(&defs, &params, false)
            .expect("Resolver creation should succeed with valid inputs");
        assert_eq!(
            resolver.get_specific_value("<p::env>"),
            Some("--env staging")
        );
    }

    #[test]
    fn test_resolver_named_required_success() {
        let defs = [parse_parameter_token("<p::env(required)>", "env(required)")
            .expect("Parsing static token should succeed")];
        let params = to_cli_params(&["--env", "staging"]);
        let resolver = ArgResolver::new(&defs, &params, false)
            .expect("Resolver creation should succeed with valid inputs");
        assert_eq!(
            resolver.get_specific_value("<p::env(required)>"),
            Some("--env staging")
        );
    }

    #[test]
    fn test_resolver_named_required_fail() {
        let defs = [parse_parameter_token("<p::env(required)>", "env(required)")
            .expect("Parsing static token should succeed")];
        let params = to_cli_params(&[]);
        let result = ArgResolver::new(&defs, &params, false);
        assert!(result.is_err());
        assert!(
            result
                .expect_err("Resolution should fail but it succeeded")
                .to_string()
                .contains("Flag '--env' is required")
        );
    }

    #[test]
    fn test_resolver_named_flag_absent_uses_default() {
        let defs = [
            parse_parameter_token("<p::tag(default='latest')>", "tag(default='latest')")
                .expect("Parsing static token should succeed"),
        ];
        let params = to_cli_params(&[]);
        let resolver = ArgResolver::new(&defs, &params, false)
            .expect("Resolver creation should succeed with valid inputs");
        // With `map` undefined, and flag absent, the token resolves to nothing. This is correct.
        assert_eq!(
            resolver.get_specific_value("<p::tag(default='latest')>"),
            Some("")
        );
    }

    #[test]
    fn test_resolver_named_flag_present_no_value_uses_default() {
        let defs = [
            parse_parameter_token("<p::tag(default='latest')>", "tag(default='latest')")
                .expect("Parsing static token should succeed"),
        ];
        let params = to_cli_params(&["--tag"]);
        let resolver = ArgResolver::new(&defs, &params, false)
            .expect("Resolver creation should succeed with valid inputs");
        assert_eq!(
            resolver.get_specific_value("<p::tag(default='latest')>"),
            Some("--tag latest")
        );
    }

    #[test]
    fn test_resolver_named_required_and_default() {
        // This confirms the logic we discussed: `required` checks for presence,
        // `default` provides a value if present without one.
        let defs = [parse_parameter_token(
            "<p::region(required, default='us-east-1')>",
            "region(required, default='us-east-1')",
        )
        .expect("Parsing static token should succeed")];

        // Case 1: Fails because flag is not present.
        let params_fail = to_cli_params(&[]);
        let result_fail = ArgResolver::new(&defs, &params_fail, false);
        assert!(result_fail.is_err());

        // Case 2: Succeeds and uses the default value.
        let params_succeed = to_cli_params(&["--region"]);
        let resolver = ArgResolver::new(&defs, &params_succeed, false)
            .expect("Resolver creation should succeed with valid inputs");
        assert_eq!(
            resolver.get_specific_value("<p::region(required, default='us-east-1')>"),
            Some("--region us-east-1")
        );
    }

    #[test]
    fn test_resolver_map_empty_extracts_value() {
        let defs = [parse_parameter_token(
            "<p::tag(map='', default='latest')>",
            "tag(map='', default='latest')",
        )
        .expect("Parsing static token should succeed")];

        // Case 1: Flag absent, uses default.
        let params1 = to_cli_params(&[]);
        let resolver1 = ArgResolver::new(&defs, &params1, false)
            .expect("Resolver creation should succeed in test");
        assert_eq!(
            resolver1.get_specific_value("<p::tag(map='', default='latest')>"),
            Some("")
        );

        // Case 2: Flag present with value.
        let params2 = to_cli_params(&["--tag", "v1.2.0"]);
        let resolver2 = ArgResolver::new(&defs, &params2, false)
            .expect("Resolver creation should succeed in test");
        assert_eq!(
            resolver2.get_specific_value("<p::tag(map='', default='latest')>"),
            Some("v1.2.0")
        );
    }

    // Test Generic <params> Collector
    #[test]
    fn test_resolver_unclaimed_args() {
        let defs =
            [parse_parameter_token("<p::0>", "0").expect("Parsing static token should succeed")];
        let params = to_cli_params(&["pos0", "pos1", "--flag", "val"]);
        let resolver = ArgResolver::new(&defs, &params, true)
            .expect("Resolver creation should succeed with valid inputs");

        assert_eq!(resolver.get_specific_value("<p::0>"), Some("pos0"));
        assert_eq!(resolver.unclaimed_args, vec!["pos1", "--flag", "val"]);
    }

    #[test]
    fn test_resolver_unclaimed_args_error_when_no_generic_token() {
        let defs =
            [parse_parameter_token("<p::0>", "0").expect("Parsing static token should succeed")];
        let params = to_cli_params(&["pos0", "pos1"]);
        let result = ArgResolver::new(&defs, &params, false);
        assert!(result.is_err());
        assert!(
            result
                .expect_err("Resolution should fail but it succeeded")
                .to_string()
                .contains("Unexpected arguments")
        );
    }
}

===== core\paths.rs =====
//! # Filesystem Path Management
//!
//! This module provides centralized, robust, and platform-aware functions for handling
//! filesystem paths used by `axes`. It ensures that configuration files, caches, and
//! other assets are stored in predictable and conventional locations across different
//! operating systems.
//!
//! ## Key Functions
//!
//! - `get_axes_config_dir`: The single source of truth for the main `axes` config directory
//!   (e.g., `~/.config/axes`). It's memoized for performance.
//! - `get_default_cache_root`: Determines the default base directory for all caches, respecting
//!   OS conventions (e.g., `~/.cache/axes` on Linux, `%LOCALAPPDATA%\axes\cache` on Windows).
//! - `expand_path_template`: Safely expands shell-like path strings (e.g., `~/some/path`).

use crate::constants::GLOBAL_INDEX_FILENAME;
use anyhow::{Result, anyhow};
use lazy_static::lazy_static;
use std::fs;
use std::path::PathBuf;
use std::sync::Mutex;
use thiserror::Error;
use uuid::Uuid;

lazy_static! {
    static ref AXES_CONFIG_DIR: Mutex<Option<PathBuf>> = Mutex::new(None);
}

/// Represents errors that can occur during path resolution.
#[derive(Error, Debug)]
pub enum PathError {
    /// The system's standard configuration directory (e.g., `~/.config`) could not be determined.
    #[error("Could not find system config directory.")]
    ConfigDirNotFound,
    /// An I/O error occurred while attempting to create the `axes` configuration directory.
    #[error("Could not create config directory at '{path}': {source}")]
    ConfigDirCreation {
        /// The path that could not be created.
        path: String,
        /// The underlying I/O error.
        #[source]
        source: std::io::Error,
    },
}

/// Returns the path to the global index file (e.g., `~/.config/axes/index.bin`).
/// This is the main persistence file for the application's state.
pub fn get_axes_config_dir() -> Result<PathBuf, PathError> {
    let mut cached_path_guard = AXES_CONFIG_DIR
        .lock()
        .expect("Config dir mutex should not be poisoned");
    if let Some(path) = &*cached_path_guard {
        return Ok(path.clone());
    }

    let config_path = dirs::config_dir()
        .ok_or(PathError::ConfigDirNotFound)?
        .join("axes");

    if !config_path.exists() {
        log::info!(
            "First run detected: creating config directory at '{}'.",
            config_path.display()
        );
        fs::create_dir_all(&config_path).map_err(|e| PathError::ConfigDirCreation {
            path: config_path.display().to_string(),
            source: e,
        })?;
    }

    *cached_path_guard = Some(config_path.clone());
    Ok(config_path)
}

/// Returns the path to the global `index.toml` file.
/// This is the main file in the axes configuration directory.
pub fn get_global_index_path() -> Result<PathBuf, PathError> {
    get_axes_config_dir().map(|dir| dir.join(GLOBAL_INDEX_FILENAME))
}

/// Expands a path template string, resolving home directory (`~`) and environment variables.
///
/// This function is used to resolve user-configured paths, such as the `cache_dir` option.
/// It explicitly forbids `axes`-specific dynamic tokens (like `<uuid>`) to ensure that
/// the configured path is a stable root directory.
///
/// # Arguments
/// * `template` - The path string to expand (e.g., `~/.my-caches/axes`).
///
/// # Errors
/// Returns an error if the expansion fails or if the template contains forbidden tokens.
pub fn expand_path_template(template: &str) -> Result<PathBuf> {
    // We remove the project-specific tokens here as the root path should be generic.
    if template.contains("<") {
        return Err(anyhow!(
            "The 'cache_dir' path template should only define a root directory and must not contain dynamic axes tokens like <uuid>. Invalid template: '{}'",
            template
        ));
    }
    let expanded_path_str = shellexpand::full(template)
        .map_err(|e| anyhow!("Failed to expand cache path template '{}': {}", template, e))?;
    Ok(PathBuf::from(expanded_path_str.into_owned()))
}

/// Returns the platform-specific default root directory for all axes caches.
/// This is the single source of truth for the default cache location.
/// - Windows: `%LOCALAPPDATA%\axes\cache`
/// - Linux/macOS: `~/.cache/axes`
pub fn get_default_cache_root() -> Result<PathBuf> {
    if cfg!(windows) {
        let local_app_data = std::env::var("LOCALAPPDATA")
            .map(PathBuf::from)
            // Fallback to a subdir in the config dir if LOCALAPPDATA is not set
            .unwrap_or_else(|_| {
                get_axes_config_dir()
                    .expect("Axes config dir should be resolvable")
                    .join("cache_fallback")
            });
        Ok(local_app_data.join("axes").join("cache"))
    } else {
        let home_dir = dirs::home_dir().ok_or_else(|| anyhow!("Could not find home directory"))?;
        Ok(home_dir.join(".cache").join("axes"))
    }
}

/// Returns the platform-specific default absolute path for a single project's cache directory.
/// The path is constructed as `<default_cache_root>/projects/<uuid>`.
///
/// # Arguments
/// * `uuid` - The UUID of the project.
pub fn get_default_cache_dir_for_project(uuid: Uuid) -> Result<PathBuf> {
    // All projects, including 'global', will now have their cache in a subdirectory
    // named after their UUID inside `.../cache/projects`. This is consistent.
    let cache_root = get_default_cache_root()?;
    Ok(cache_root.join("projects").join(uuid.to_string()))
}

===== core\task_executor.rs =====
//! # Task Execution Engine
//!
//! This module is the heart of `axes`'s script execution capabilities. It is responsible for
//! taking a pre-compiled, platform-specialized task and running its commands.
//!
//! ## Design and Performance
//!
//! The executor is designed for high performance and operates on the "hot path" of script execution.
//! Key design principles include:
//!
//! - **Pre-Specialization**: It expects a `PlatformSpecializedTask`, meaning all platform-specific
//!   logic and script compositions have already been resolved. This keeps the execution loop
//!   simple and fast, with no conditional branching for OS types.
//! - **Batching for Parallelism**: It groups consecutive commands marked for parallel execution (`>`)
//!   into batches and runs them concurrently using `rayon`.
//! - **Recursive Command Assembly**: The `assemble_final_command` function acts as a powerful
//!   "renderer" that recursively resolves all tokens (`<..._>`) in a command string into their
//!   final values just before execution.
//! - **Graceful Handling**: It interacts with the `system::executor` to handle shell commands,
//!   including graceful termination on signals like Ctrl+C.

use crate::{
    core::{color, commons::wrap_value, parameters::ArgResolver},
    models::{CommandAction, PlatformSpecializedTask, ResolvedConfig, RunSpec, TemplateComponent},
    system::executor,
};
use anyhow::{Context, Result, anyhow};
use colored::*;
use rayon::prelude::*;
use std::fmt::Write;

// --- Main Public Function ---

/// Executes a platform-specialized task. This is the hot path for script execution.
pub fn execute_task(
    specialized_task: &PlatformSpecializedTask,
    config: &ResolvedConfig,
    resolver: &ArgResolver<'_>,
) -> Result<()> {
    execute_task_inner(specialized_task, config, resolver, 0)
}

// --- Internal Recursive Executor ---

/// The internal executor for a platform-specialized task, with recursion depth tracking.
///
/// This function iterates over a flat list of `CommandExecution`s, renders their templates,
/// and dispatches them sequentially or in parallel batches. The `depth` parameter is used to
/// prevent infinite recursion caused by self-referential `<run(...)>` tokens.
///
/// # Arguments
/// * `specialized_task` - A task that has been pre-processed for the current platform.
/// * `config` - The fully resolved project configuration facade.
/// * `resolver` - The argument resolver containing values for parameter tokens.
/// * `depth` - The current recursion depth.
fn execute_task_inner(
    specialized_task: &PlatformSpecializedTask,
    config: &ResolvedConfig,
    resolver: &ArgResolver<'_>,
    depth: u32,
) -> Result<()> {
    // A batch of commands to be executed in parallel.
    // Storing `String` is necessary as `assemble_final_command` returns an owned string.
    let mut parallel_batch: Vec<(String, bool, bool)> = Vec::new();

    // --- OPTIMIZED HOT LOOP ---
    // This loop iterates over a simple, flat `Vec<CommandExecution>`.
    // There are no branches for platform selection, making it extremely fast.
    for command_exec in &specialized_task.commands {
        // If the current command is sequential, execute any pending parallel batch first.
        if !command_exec.run_in_parallel && !parallel_batch.is_empty() {
            execute_parallel_batch(&parallel_batch, config)?;
            parallel_batch.clear();
        }

        match &command_exec.action {
            CommandAction::Execute(template) => {
                // Render the final command string from the template components.
                let rendered_string = assemble_final_command(template, config, resolver, depth)?;

                // Skip execution if the rendered command is empty after trimming whitespace.
                if !rendered_string.trim().is_empty() {
                    if command_exec.run_in_parallel {
                        // Add the owned string and its modifiers to the parallel batch.
                        parallel_batch.push((
                            rendered_string, // Move the owned string
                            command_exec.ignore_errors,
                            command_exec.silent_mode,
                        ));
                    } else {
                        // Execute sequentially. We can pass a `&str` slice to avoid allocations.
                        execute_single_command(
                            rendered_string.trim(),
                            command_exec.ignore_errors,
                            command_exec.silent_mode,
                            config,
                        )?;
                    }
                }
            }
            CommandAction::Print(template) => {
                let rendered_string = assemble_final_command(template, config, resolver, depth)?;
                println!("{}", rendered_string);
            }
        }
    }

    // Execute any remaining commands in the final parallel batch.
    if !parallel_batch.is_empty() {
        execute_parallel_batch(&parallel_batch, config)?;
    }

    Ok(())
}

// --- Command Assembly (Recursive String Renderer) ---

/// "Renders" a template of `TemplateComponent`s into a final, executable string.
///
/// This function is the core of the dynamic token expansion system. It iterates through the
/// components of a command's AST and substitutes each token with its runtime value. It handles
/// everything from simple variable substitution to executing sub-commands for output (`<run(...)>`).
///
/// # Arguments
/// * `template` - A slice of `TemplateComponent`s representing the command's AST.
/// * `config` - The fully resolved project configuration for context.
/// * `resolver` - The argument resolver for `<params::...>` tokens.
/// * `depth` - The current recursion depth, used to prevent infinite loops with `<run(...)>`.
///
/// # Errors
/// Returns an error if recursion depth is exceeded or if an un-flattened `<scripts::...>` or
/// `<vars::...>` token is found, which indicates an internal compiler error.
pub fn assemble_final_command(
    template: &[TemplateComponent],
    config: &ResolvedConfig,
    resolver: &ArgResolver<'_>,
    _depth: u32,
) -> Result<String> {
    let mut final_command = String::with_capacity(template.len() * 50);
    for component in template {
        match component {
            TemplateComponent::Literal(s) => final_command.push_str(s),
            TemplateComponent::Parameter(def) => {
                let value = resolver
                    .get_specific_value(&def.original_token)
                    .unwrap_or_default();
                final_command.push_str(value);
            }
            TemplateComponent::GenericParams { literal } => {
                let values = resolver.get_generic_values();
                let joined = if *literal {
                    values
                        .iter()
                        .map(|arg| wrap_value(arg))
                        .collect::<Vec<_>>()
                        .join(" ")
                } else {
                    values.join(" ")
                };
                final_command.push_str(&joined);
            }
            TemplateComponent::Color(c) => final_command.push_str(color::style_to_ansi_code(*c)),
            TemplateComponent::Path => {
                final_command.push_str(&config.project_root.to_string_lossy());
            }
            TemplateComponent::Name => final_command.push_str(&config.qualified_name),
            TemplateComponent::Uuid => final_command.push_str(&config.uuid.to_string()),
            TemplateComponent::Version => {
                final_command.push_str(config.get_version()?.as_deref().unwrap_or(""));
            }
            TemplateComponent::Run(spec) => {
                let command_to_run = match spec {
                    RunSpec::Literal(cmd) => {
                        // Create a temporary template to recursively resolve tokens within the run command itself.
                        let temp_template = crate::core::compiler::tokenize_string(cmd)?;
                        assemble_final_command(&temp_template, config, resolver, _depth + 1)?
                    }
                };
                let env = config.get_env()?;
                let output = executor::execute_and_capture_output(
                    &command_to_run,
                    &config.project_root,
                    &env,
                )?;
                final_command.push_str(output.trim());
            }

            // --- LAZY RESOLUTION OF SYMBOLIC REFERENCES ---
            TemplateComponent::Script(name) | TemplateComponent::Var(name) => {
                // This logic is now handled by the flatten_template_recursive, which runs
                // before assemble_final_command. If we encounter a Script or Var here, it's a logic error.
                return Err(anyhow!(
                    "Internal Compiler Error: Unflattened symbolic reference '<{}::{}>' found during final command assembly.",
                    if matches!(component, TemplateComponent::Var(_)) {
                        "vars"
                    } else {
                        "scripts"
                    },
                    name
                ));
            }
        }
    }
    Ok(final_command)
}

// --- Execution Helpers ---

/// Executes a single command sequentially in the foreground.
///
/// It prints the command to the console (unless in silent mode) and then blocks
/// until the command completes.
///
/// # Arguments
/// * `command_str` - The fully rendered command string to execute.
/// * `ignore_errors` - If true, a non-zero exit code will not cause an error.
/// * `silent` - If true, the command string will not be printed before execution.
/// * `config` - The resolved config, used to get the working directory and environment variables.
fn execute_single_command(
    command_str: &str,
    ignore_errors: bool,
    silent: bool,
    config: &ResolvedConfig,
) -> Result<()> {
    if !silent {
        println!("{} {}", "→".blue(), command_str.green());
    }
    let env = config.get_env()?;
    executor::execute_command(command_str, ignore_errors, &config.project_root, &env)?;
    Ok(())
}

/// Executes a batch of commands concurrently using a thread pool.
///
/// It prints a header for the batch (unless all commands are silent) and then spawns
/// each command on the `rayon` thread pool. It waits for all commands to complete and -
/// aggregates any errors.
///
/// # Arguments
/// * `batch` - A slice of tuples, where each tuple contains the command string,
///   an `ignore_errors` flag, and a `silent` flag.
/// * `config` - The resolved config, passed to each command execution.
///
/// # Errors
/// Returns a single error that aggregates the results of all failed commands in the batch.
fn execute_parallel_batch(batch: &[(String, bool, bool)], config: &ResolvedConfig) -> Result<()> {
    let is_globally_silent = batch.iter().all(|(_, _, silent)| *silent);
    if !is_globally_silent {
        let mut header_block = String::with_capacity(batch.len() * 80);
        writeln!(
            header_block,
            "{}",
            format!("┌─ Running {} commands in parallel...", batch.len()).dimmed()
        )
        .expect("Writing to a String buffer should not fail");
        let inter_arrow = ("├─>").dimmed();
        for (command_str, _, silent) in batch.iter() {
            if !*silent {
                writeln!(header_block, "{} {}", inter_arrow, command_str.green())
                    .expect("Writing to a String buffer should not fail");
            }
        }
        print!("{}", header_block);
    }

    if log::log_enabled!(log::Level::Trace) {
        log::trace!("Executing parallel batch of {} commands.", batch.len());
        for (i, (cmd, _, _)) in batch.iter().enumerate() {
            log::trace!("  - Batch[{}]: {}", i, cmd);
        }
    }

    let env = config.get_env()?;
    let results: Vec<Result<(), anyhow::Error>> = batch
        .par_iter()
        .map(|(command_str, ignore_errors, _)| {
            executor::execute_command(command_str, *ignore_errors, &config.project_root, &env)
                .map_err(anyhow::Error::from)
        })
        .collect();

    let mut errors = Vec::new();
    for (i, result) in results.into_iter().enumerate() {
        if let Err(e) = result {
            let (failed_command, _, _) = batch
                .get(i)
                .expect("Index must be valid in results enumeration");
            log::trace!(
                "Parallel command failed: '{}' with error: {}",
                failed_command,
                e
            );
            errors.push(anyhow!("Command '{}' failed: {}", failed_command.cyan(), e));
        }
    }

    if !errors.is_empty() {
        // Combine all errors into one final error.
        return Err(anyhow!(
            "{} command(s) in the parallel batch failed.",
            errors.len()
        ))
        .context(
            errors
                .into_iter()
                .map(|e| e.to_string())
                .collect::<Vec<_>>()
                .join("\n"),
        );
    }

    if !is_globally_silent {
        println!("{}", "└─ End batch.".dimmed());
    }
    Ok(())
}

===== dev_utils.rs =====
// src/dev_utils.rs
#![allow(dead_code)] // Allow unused code, as this is a temporary debug utility

use std::time::Instant;

/// A simple RAII timer for profiling blocks of code.
/// When created, it records the start time. When it goes out of scope (is dropped),
/// it calculates the elapsed time and prints it to the console.
#[derive(Debug)]
pub struct BlockTimer {
    name: String,
    start: Instant,
}

impl BlockTimer {
    /// Creates a new timer and starts it immediately.
    pub fn new(name: impl Into<String>) -> Self {
        Self {
            name: name.into(),
            start: Instant::now(),
        }
    }
}

impl Drop for BlockTimer {
    fn drop(&mut self) {
        let elapsed = self.start.elapsed();
        // Print in a structured format with microseconds for high precision.
        println!(
            "PROFILE [{}]: {} µs",
            self.name,
            elapsed.as_micros()
        );
    }
}

===== lib.rs =====
//! # Axes Language
//!
//! This crate provides the core functionality for the Axes language, including the CLI, constants, core logic, models, state management, and system interactions.

// The translations are generated by the build script and included here.
include!(concat!(env!("OUT_DIR"), "/translations.rs"));

use std::sync::Arc;
use std::sync::atomic::AtomicBool;

/// A type alias for a cancellation token, which is used to signal termination to long-running tasks.
pub type CancellationToken = Arc<AtomicBool>;

/// The command-line interface module, responsible for parsing arguments and handling user input.
pub mod cli;

/// The constants module, which contains various constants used throughout the crate.
pub mod constants;

/// The core module, which contains the main logic of the Axes language.
pub mod core;

/// The models module, which defines the data structures used in the crate.
pub mod models;

/// The state module, which manages the state of the application.
pub mod state;

/// The system module, which provides an interface to the underlying operating system.
pub mod system;

/// Only for tests
#[cfg(debug_assertions)]
pub mod dev_utils;

===== models.rs =====
//! # Data Models
//!
//! This module defines the core data structures used throughout the application, organized into four main categories:
//!
//! 1.  **User-Facing TOML Syntax Models**: These structs (`ProjectConfig`, `TomlScript`, `TomlVar`, etc.)
//!     are designed for flexibility and ergonomics, directly mapping to the syntax a user can write in an
//!     `axes.toml` file. They use enums and `#[serde(untagged)]` to allow for multiple ways of defining
//!     the same logical entity (e.g., a script can be a simple string, a sequence of commands, or a
//!     table with a description).
//!
//! 2.  **Platform-Agnostic AST & Runtime Models**: After the initial parsing, the user-facing models are
//!     compiled into a stricter, more efficient Abstract Syntax Tree (AST). Structs like `Task`, `CachedVar`,
//!     and `CommandExecution` represent the compiled, platform-agnostic logic. This is the representation
//!     that gets stored in the binary cache and is used for most of the program's internal logic.
//!
//! 3.  **Persistence & System Models**: These structs (`GlobalIndex`, `IndexEntry`, `ProjectRef`) are used for
//!     serialization to disk. They represent the application's persistent state, such as the list of all
//!     registered projects and their metadata. They are optimized for fast loading and saving via `bincode`.
//!
//! 4.  **High-Level Runtime Models**: At runtime, the application uses high-level facade models like
//!     `ResolvedConfig` to provide an intelligent, lazy-loaded view of a project's entire configuration,
//!     including inherited settings. These models handle the on-demand loading and caching of configuration
//!     layers to ensure high performance.
//!
use anyhow::{Result, anyhow};
use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet};
use std::path::PathBuf;
use std::sync::{Arc, Mutex, OnceLock};
use uuid::Uuid;

// --- Core Concurrency & State Types ---

/// The result of loading and compiling a single configuration layer.
pub type LayerResult = Result<Arc<CachedProjectConfig>>;

/// A thread-safe, one-time settable container for a future `LayerResult`.
/// This acts as a "promise" that consumers can wait on until the layer is loaded by a worker thread.
pub type LayerPromise = Arc<OnceLock<LayerResult>>;

/// A data structure to securely pass updates for the `GlobalIndex` from worker threads
/// back to the main thread for sequential application. This is created on a cache miss.
#[derive(Debug, Clone)]
pub struct IndexUpdate {
    /// The UUID of the project whose cache information needs updating.
    pub uuid: Uuid,
    /// The new BLAKE3 content hash of the project's `axes.toml` file.
    pub new_hash: String,
    /// The newly resolved cache directory path for the project.
    pub new_cache_dir: PathBuf,
}

// =========================================================================
// === 1. USER-FACING TOML SYNTAX MODELS (V0.3 Architecture)
// =========================================================================
// These structs are designed for maximum flexibility, defining the ergonomic
// syntax a user can write in an `axes.toml` file.

/// Represents a platform-specific dictionary for a command or a variable's value.
/// `deny_unknown_fields` ensures that typos in keys (e.g., `defalt = "..."`) are caught as errors.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
#[serde(deny_unknown_fields)]
pub struct PlatformCommand {
    /// The default command, used if no platform-specific version is available.
    #[serde(default)]
    pub default: Option<String>,
    /// The command to run specifically on Windows.
    #[serde(default)]
    pub windows: Option<String>,
    /// The command to run specifically on Linux.
    #[serde(default)]
    pub linux: Option<String>,
    /// The command to run specifically on macOS.
    #[serde(default)]
    pub macos: Option<String>,
}

/// Represents a single command line within a script's sequence.
/// It can be a simple string (which may include `axes` prefixes) or a platform-specific block.
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(untagged)]
pub enum TomlCommand {
    /// A single command string, e.g., `"echo 'hello'"`
    Simple(String),
    /// A platform-specific block, e.g., `{ windows = "dir", default = "ls" }`
    Platform(PlatformCommand),
}

/// Represents an extended script definition with a description.
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(deny_unknown_fields)]
pub struct TomlScriptExtended {
    /// A user-facing description of what the script does.
    pub desc: Option<String>,
    /// The command(s) to run, which can be any `TomlScript` variant.
    pub run: Box<TomlScript>,
}

/// Represents a direct platform-specific script definition with a description.
/// This allows syntax like `[scripts.build] desc = "..." windows = "..."`.
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(deny_unknown_fields)]
pub struct TomlScriptPlatformDirect {
    /// A user-facing description of what the script does.
    pub desc: Option<String>,
    /// The platform-specific commands.
    #[serde(flatten)]
    pub platform: PlatformCommand,
}

/// Represents the flexible syntax for a script in `axes.toml`.
/// This enum allows a script to be defined as a single command, a sequence, or an extended table.
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(untagged)]
pub enum TomlScript {
    /// A single command string: `script = "..."`
    Simple(String),
    /// A sequence of commands: `script = [ "...", { ... } ]`
    Sequence(Vec<TomlCommand>),
    /// A platform-specific block: `script = { windows = "...", ... }`
    Platform(PlatformCommand),
    /// A table with description and platform keys: `[scripts.my_script]`
    PlatformDirect(TomlScriptPlatformDirect),
    /// A table with description and a nested `run` key: `[scripts.my_script]`
    Extended(TomlScriptExtended),
}

/// Represents the value part of a variable definition in `axes.toml`.
/// A variable's value can be a simple string or a platform-specific block, but not a sequence.
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(untagged)]
pub enum TomlVarValue {
    /// A single var string: var = "..."
    Simple(String),
    /// A platform-specific block: `var = { windows = "...", ... }`
    Platform(PlatformCommand),
}

/// Represents an extended variable definition with a description and value.
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(deny_unknown_fields)]
pub struct TomlVarExtended {
    /// A user-facing description of the variable.
    pub desc: Option<String>,
    /// The value of the variable.
    pub value: TomlVarValue,
}

/// Represents the flexible syntax for a variable in `axes.toml`.
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(untagged)]
pub enum TomlVar {
    /// A simple string value: `my_var = "..."`
    Simple(String),
    /// An extended table with description and value: `[vars.my_var]`
    Extended(TomlVarExtended),
}

/// Represents the user-configurable `[options.open_with]` table in `axes.toml`.
#[derive(Deserialize, Serialize, Debug, Clone, Default)]
pub struct TomlOpenWithConfig {
    /// The key of the default command to use for `axes open`.
    #[serde(default)]
    pub default: Option<String>,
    /// A map of custom commands, where keys are identifiers (e.g., "editor") and values are scripts.
    #[serde(flatten)]
    pub commands: HashMap<String, TomlScript>,
}

/// Represents the `[options]` section in `axes.toml`.
#[derive(Deserialize, Serialize, Debug, Clone, Default)]
#[serde(deny_unknown_fields)]
pub struct OptionsConfig {
    /// A script to run automatically when entering a project session via `axes start`.
    #[serde(default)]
    pub at_start: Option<TomlScript>,
    /// A script to run automatically when exiting a project session.
    #[serde(default)]
    pub at_exit: Option<TomlScript>,
    /// The name of the shell (from `shells.toml`) to use for `axes start`.
    #[serde(default)]
    pub shell: Option<String>,
    /// Configuration for the `axes open` command.
    #[serde(default)]
    pub open_with: TomlOpenWithConfig,
    /// A template for the root directory where project caches are stored.
    #[serde(default)]
    pub cache_dir: Option<String>,
    /// A template for the shell prompt used inside an `axes start` session.
    #[serde(default)]
    pub prompt: Option<String>,
}

/// Represents the direct, top-level structure of an `axes.toml` file.
/// This is the entry point for deserialization by the compiler.
#[derive(Deserialize, Serialize, Debug, Clone, Default)]
#[serde(deny_unknown_fields)]
pub struct ProjectConfig {
    /// The simple name of the project. Primarily for informational purposes.
    #[serde(default)]
    pub name: Option<String>,
    /// The version of the project. Can be interpolated via the `<version>` token.
    #[serde(default)]
    pub version: Option<String>,
    /// A short description of the project.
    #[serde(default)]
    pub description: Option<String>,
    /// A map of named scripts the user can run.
    #[serde(default)]
    pub scripts: HashMap<String, TomlScript>,
    /// Global options for the project's behavior.
    #[serde(default)]
    pub options: OptionsConfig,
    /// A map of user-defined variables for interpolation.
    #[serde(default)]
    pub vars: HashMap<String, TomlVar>,
    /// A map of environment variables to set during script execution or sessions.
    #[serde(default)]
    pub env: HashMap<String, String>,
}

// =========================================================================
// === 2. PLATFORM-AGNOSTIC AST & RUNTIME MODELS (V0.3 Architecture)
// =========================================================================
// These are the primary internal structs used by the program logic after
// the `axes.toml` has been compiled. They are optimized for performance
// and binary serialization.

// --- Parameter & Token Models ---

/// Defines the contract for a parameter token (`<params::...>`) found in a script.
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParameterDef {
    /// The kind of parameter (positional or named).
    pub kind: ParameterKind,
    /// Modifiers that control the parameter's behavior (e.g., required, default value).
    pub modifiers: ParameterModifiers,
    /// The original, full token string as it appeared in the config (e.g., `<params::0(required)>`).
    pub original_token: String,
}

/// Distinguishes between positional (`<params::0>`) and named (`<params::name>`) parameters.
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq, Hash)]
pub enum ParameterKind {
    /// A parameter identified by its zero-based position in the argument list.
    Positional {
        /// The index of the positional argument.
        index: usize,
    },
    /// A parameter identified by a name, usually corresponding to a CLI flag (e.g., `--name`).
    Named {
        /// The long name of the flag (without the `--` prefix).
        name: String,
    },
}

/// Defines the modifiers for a parameter (e.g., `required`, `default`, `alias`).
#[derive(Serialize, Deserialize, Debug, Clone, Default, PartialEq, Eq, Hash)]
pub struct ParameterModifiers {
    /// If true, the parameter must be provided by the user.
    pub required: bool,
    /// A default value to use if the parameter is not provided.
    pub default_value: Option<String>,
    /// An alternative name for a named parameter (e.g., `-n` as an alias for `--name`).
    pub alias: Option<String>,
    /// A string to prepend to the parameter's value, used for formatting flags.
    pub map: Option<String>,
    /// If true, the parameter's value will be wrapped in quotes and escaped.
    pub literal: bool,
}

/// Represents a dynamic execution token (`<run(...)>`).
#[derive(Serialize, Deserialize, Debug, Clone)]
pub enum RunSpec {
    /// A literal shell command to execute, e.g., `<run('git rev-parse --short HEAD')>`.
    Literal(String),
}

/// An enum representing all possible token types that can appear in a command string.
/// This is a fundamental part of the compiled AST.
#[derive(Serialize, Deserialize, Debug, Clone)]
pub enum TemplateComponent {
    /// A static, literal part of the command string.
    Literal(String),
    /// A user-defined parameter from the CLI, e.g., `<params::0>`.
    Parameter(ParameterDef),
    /// A token that expands to all unconsumed CLI arguments, e.g., `<params>`.
    GenericParams {
        /// If true, each argument is individually quoted.
        literal: bool,
    },
    /// A command to execute whose output is substituted in place, e.g., `<run('...')>`.
    Run(RunSpec),
    /// A token that expands to the project's root filesystem path.
    Path,
    /// A token that expands to the project's simple name.
    Name,
    /// A token that expands to the project's UUID.
    Uuid,
    /// A token that expands to the project's version string.
    Version,
    /// An ANSI color/style code, e.g., `<#red>`.
    Color(AnsiStyle),
    /// A reference to another script, e.g., `<scripts::build>`.
    Script(String),
    /// A reference to a variable, e.g., `<vars::my_var>`.
    Var(String),
}

/// Represents the specific action for a single line in a script (execute vs. print).
#[derive(Serialize, Deserialize, Debug, Clone)]
pub enum CommandAction {
    /// Execute a shell command composed of token components.
    Execute(Vec<TemplateComponent>),
    /// Print a string composed of token components directly to the console.
    Print(Vec<TemplateComponent>),
}

/// Represents a single, fully compiled command line, including its action and execution modifiers.
#[derive(Serialize, Deserialize, Debug, Clone)]
#[non_exhaustive]
pub struct CommandExecution {
    /// The action to perform (execute a command or print text).
    pub action: CommandAction,
    /// If true, the command's failure will not halt script execution.
    pub ignore_errors: bool,
    /// If true, this command can be run in parallel with subsequent parallel commands.
    pub run_in_parallel: bool,
    /// If true, the command itself will not be printed to the console before execution.
    pub silent_mode: bool,
}

// --- New Platform-Agnostic AST Models ---

/// The core building block of the AST. It holds a fully compiled `CommandExecution`
/// for each potential platform, ready for fast runtime selection.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct PlatformExecution {
    /// The default execution, used as a fallback.
    pub default: Option<CommandExecution>,
    /// The Windows-specific execution.
    pub windows: Option<CommandExecution>,
    /// The Linux-specific execution.
    pub linux: Option<CommandExecution>,
    /// The macOS-specific execution.
    pub macos: Option<CommandExecution>,
}

/// The platform-agnostic AST representation of a script.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct Task {
    /// The user-facing description of the script.
    pub desc: Option<String>,
    /// A sequence of platform-aware commands that compose the script.
    pub commands: Vec<PlatformExecution>,
}

/// Represents a `Task` that has been "specialized" for the current platform.
/// It contains a simple, flat list of commands to be executed, removing the need
/// for runtime platform selection in the hot loop of the executor.
#[derive(Debug, Clone, Default)]
pub struct PlatformSpecializedTask {
    /// The user-facing description, inherited from the original `Task`.
    pub desc: Option<String>,
    /// The flattened, platform-specific list of commands to execute.
    pub commands: Vec<CommandExecution>,
}

/// The platform-agnostic AST representation of a variable.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct CachedVar {
    /// The user-facing description of the variable.
    pub desc: Option<String>,
    /// The platform-aware value of the variable.
    pub value: PlatformExecution,
}

// --- Cache & Resolved Config Models ---

/// Bincode-compatible representation of `[options.open_with]` in the binary cache.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct CachedOpenWithConfig {
    /// The key of the default `open` command.
    pub default: Option<String>,
    /// The compiled map of available `open` commands.
    pub commands: HashMap<String, Task>,
}

/// Bincode-compatible representation of `[options]` in the binary cache.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct CachedOptionsConfig {
    /// The compiled `at_start` hook.
    pub at_start: Option<Task>,
    /// The compiled `at_exit` hook.
    pub at_exit: Option<Task>,
    /// The name of the shell to use.
    pub shell: Option<String>,
    /// The compiled `open_with` configuration.
    #[serde(default)]
    pub open_with: CachedOpenWithConfig,
    /// The configured cache directory path template.
    #[serde(default)]
    pub cache_dir: Option<String>,
    /// The configured shell prompt template.
    #[serde(default)]
    pub prompt: Option<String>,
}

/// Represents the pre-compiled content of a single `axes.toml` file.
/// This is the unit that is stored in the binary cache file.
#[derive(Serialize, Deserialize, Debug, Clone, Default)]
pub struct CachedProjectConfig {
    /// The project's version string.
    pub version: Option<String>,
    /// The project's description.
    pub description: Option<String>,
    /// The compiled map of scripts.
    pub scripts: HashMap<String, Task>,
    /// The compiled map of variables.
    pub vars: HashMap<String, CachedVar>,
    /// The map of environment variables.
    pub env: HashMap<String, String>,
    /// The compiled options configuration.
    pub options: CachedOptionsConfig,
}

// --- High-Level Runtime Models ---

/// A runtime representation of resolved `open_with` options, using `Arc` for efficient sharing.
#[derive(Debug, Clone, Default)]
pub struct ResolvedOpenWithConfig {
    /// The final, inherited key for the default `open` command.
    pub default: Option<String>,
    /// The final, merged map of available `open` commands.
    pub commands: HashMap<String, Arc<Task>>,
}

/// A runtime representation of all resolved `[options]`, using `Arc` for efficient sharing.
#[derive(Debug, Clone, Default)]
pub struct ResolvedOptionsConfig {
    /// The final, inherited `at_start` hook.
    pub at_start: Option<Arc<Task>>,
    /// The final, inherited `at_exit` hook.
    pub at_exit: Option<Arc<Task>>,
    /// The final, inherited shell name.
    pub shell: Option<String>,
    /// The final, merged `open_with` configuration.
    pub open_with: ResolvedOpenWithConfig,
    /// The final, absolute path to this project's cache directory.
    pub cache_dir: Option<String>,
    /// The final, inherited prompt template.
    pub prompt: Option<String>,
}

/// A thread-safe, shareable container for a fully merged environment map.
type MemoizedEnv = Arc<HashMap<String, String>>;

/// A generic, thread-safe, lockable container for a memoized (lazily computed) value.
type Memoized<T> = Arc<Mutex<Option<T>>>;

/// An intelligent facade (`Facade Pattern`) that provides access to a project's full, inherited configuration.
/// It loads and merges configuration layers from the inheritance chain on-demand and caches the results in memory.
#[derive(Debug, Clone)]
pub struct ResolvedConfig {
    /// The unique identifier for this project.
    pub uuid: Uuid,
    /// The fully-qualified, slash-separated name of the project (e.g., `my-app/backend`).
    pub qualified_name: String,
    /// The absolute path to the project's root directory on the filesystem.
    pub project_root: PathBuf,
    /// An ordered list of UUIDs representing the inheritance chain, from self to the root.
    pub(crate) hierarchy: Arc<Vec<Uuid>>,
    /// A map of promises for each layer's compiled configuration, used for parallel loading.
    pub(crate) layers: Arc<HashMap<Uuid, LayerPromise>>,
    /// A memoization cache for resolved scripts.
    memoized_scripts: Memoized<HashMap<String, Option<Arc<Task>>>>,
    /// A memoization cache for resolved variables.
    memoized_vars: Memoized<HashMap<String, Option<Arc<CachedVar>>>>,
    /// A memoization cache for the merged environment.
    memoized_env: Memoized<MemoizedEnv>,
    /// A memoization cache for the resolved version string.
    memoized_version: Memoized<Option<String>>,
    /// A memoization cache for the resolved description.
    memoized_description: Memoized<Option<String>>,
    /// A memoization cache for the merged options configuration.
    memoized_options: Memoized<ResolvedOptionsConfig>,
}

impl ResolvedConfig {
    /// Creates a new lazy facade, ready to resolve data from the provided layer promises.
    /// # Arguments
    ///
    /// * `uuid` - The UUID of the project.
    /// * `qualified_name` - The fully qualified name of the project.
    /// * `project_root` - The root directory of the project.
    /// * `hierarchy` - The hierarchy of the project, from the project itself to the root.
    /// * `layers` - The layers of the project, which are promises that will be resolved to the actual
    ///   configuration.
    pub fn new(
        uuid: Uuid,
        qualified_name: String,
        project_root: PathBuf,
        hierarchy: Vec<Uuid>,
        layers: HashMap<Uuid, LayerPromise>,
    ) -> Self {
        Self {
            uuid,
            qualified_name,
            project_root,
            hierarchy: Arc::new(hierarchy),
            layers: Arc::new(layers),
            memoized_scripts: Default::default(),
            memoized_vars: Default::default(),
            memoized_env: Default::default(),
            memoized_version: Default::default(),
            memoized_description: Default::default(),
            memoized_options: Default::default(),
        }
    }

    // --- LAZY ACCESSOR METHODS (FULLY IMPLEMENTED FOR V0.3) ---

    /// Lazily finds and returns a script's AST by name, searching up the inheritance chain.
    ///
    /// It traverses from the current project upwards through its parents. The first script found
    /// with the matching name is returned. Results are memoized for subsequent calls.
    ///
    /// # Arguments
    /// * `name` - The simple name of the script to find.
    pub fn get_script(&self, name: &str) -> Result<Option<Arc<Task>>> {
        let mut guard = self
            .memoized_scripts
            .lock()
            .expect("Memoization mutex should not be poisoned");
        if let Some(cache) = &*guard
            && let Some(cached_result) = cache.get(name)
        {
            return Ok(cached_result.clone());
        }

        let mut result = None;
        for &uuid in self.hierarchy.iter() {
            let layer = self.get_layer(uuid)?;
            if let Some(task) = layer.scripts.get(name) {
                result = Some(Arc::new(task.clone()));
                break;
            }
        }
        guard
            .get_or_insert_with(Default::default)
            .insert(name.to_string(), result.clone());
        Ok(result)
    }

    /// Lazily finds and returns a variable's AST by name, searching up the inheritance chain.
    ///
    /// It traverses from the current project upwards. The first variable found with the matching
    /// name is returned. Results are memoized.
    ///
    /// # Arguments
    /// * `name` - The name of the variable to find.
    pub fn get_var(&self, name: &str) -> Result<Option<Arc<CachedVar>>> {
        let mut guard = self
            .memoized_vars
            .lock()
            .expect("Memoization mutex should not be poisoned");
        if let Some(cache) = &*guard
            && let Some(cached_result) = cache.get(name)
        {
            return Ok(cached_result.clone());
        }

        let mut result = None;
        for &uuid in self.hierarchy.iter() {
            let layer = self.get_layer(uuid)?;
            if let Some(var) = layer.vars.get(name) {
                result = Some(Arc::new(var.clone()));
                break;
            }
        }
        guard
            .get_or_insert_with(Default::default)
            .insert(name.to_string(), result.clone());
        Ok(result)
    }

    /// Lazily merges and returns all environment variables from the entire hierarchy.
    /// The result is cached in an Arc for extremely fast subsequent calls.
    pub fn get_env(&self) -> Result<MemoizedEnv> {
        let mut guard = self
            .memoized_env
            .lock()
            .expect("Memoization mutex should not be poisoned");
        if let Some(env_arc) = &*guard {
            return Ok(env_arc.clone());
        }
        let mut final_env = HashMap::new();
        // Iterate in reverse to let children override parents
        for &uuid in self.hierarchy.iter().rev() {
            let layer = self.get_layer(uuid)?;
            final_env.extend(layer.env.clone());
        }
        let result_arc = Arc::new(final_env);
        *guard = Some(result_arc.clone());
        Ok(result_arc)
    }

    /// Lazily finds and returns the project's version by searching up the hierarchy.
    /// The first non-empty `version` field found while traversing up the chain is returned.
    pub fn get_version(&self) -> Result<Option<String>> {
        let mut guard = self
            .memoized_version
            .lock()
            .expect("Memoization mutex should not be poisoned");
        if let Some(version) = &*guard {
            return Ok(version.clone());
        }
        let mut final_version = None;
        for &uuid in self.hierarchy.iter() {
            let layer = self.get_layer(uuid)?;
            if let Some(version) = &layer.version {
                final_version = Some(version.clone());
                break;
            }
        }
        *guard = Some(final_version.clone());
        Ok(final_version)
    }

    /// Lazily finds and returns the project's description by searching up the hierarchy.
    /// The first non-empty `description` field found is returned.
    pub fn get_description(&self) -> Result<Option<String>> {
        let mut guard = self
            .memoized_description
            .lock()
            .expect("Memoization mutex should not be poisoned");
        if let Some(desc) = &*guard {
            return Ok(desc.clone());
        }
        let mut final_desc = None;
        for &uuid in self.hierarchy.iter() {
            let layer = self.get_layer(uuid)?;
            if let Some(desc) = &layer.description {
                final_desc = Some(desc.clone());
                break;
            }
        }
        *guard = Some(final_desc.clone());
        Ok(final_desc)
    }

    /// Lazily merges and returns the final `ResolvedOptionsConfig` from the entire hierarchy.
    /// This method uses a two-pass approach to correctly handle inheritance:
    /// 1. A forward pass (child-to-parent) finds the *first* defined value for options
    ///    that do not merge, like hooks (`at_start`, `at_exit`). The child-most definition wins.
    /// 2. A reverse pass (parent-to-child) merges collections, allowing child definitions
    ///    to override parent definitions (e.g., `open_with` commands, `shell` value).
    pub fn get_options(&self) -> Result<ResolvedOptionsConfig> {
        let mut guard = self
            .memoized_options
            .lock()
            .expect("Memoization mutex should not be poisoned");
        if let Some(options) = &*guard {
            return Ok(options.clone());
        }

        let mut final_options = ResolvedOptionsConfig::default();
        let mut cache_dir_template: Option<String> = None;
        let mut at_start_found = false;
        let mut at_exit_found = false;

        // Iterate from child to parent (normal order) to find first-defined hooks
        for &uuid in self.hierarchy.iter() {
            let layer = self.get_layer(uuid)?;
            if cache_dir_template.is_none() && layer.options.cache_dir.is_some() {
                cache_dir_template = layer.options.cache_dir.clone();
            }
            let layer_options = &layer.options;

            if !at_start_found && layer_options.at_start.is_some() {
                final_options.at_start = layer_options.at_start.clone().map(Arc::new);
                at_start_found = true;
            }
            if !at_exit_found && layer_options.at_exit.is_some() {
                final_options.at_exit = layer_options.at_exit.clone().map(Arc::new);
                at_exit_found = true;
            }
        }

        // --- Resolve the cache_dir template ---
        let final_cache_root_string = match cache_dir_template {
            Some(template) => {
                // expand_path_template returns a PathBuf, convert it back to a string for storage.
                let path = crate::core::paths::expand_path_template(&template)?;
                path.to_string_lossy().into_owned()
            }
            None => {
                let path = crate::core::paths::get_default_cache_root()?;
                path.to_string_lossy().into_owned()
            }
        };

        // The final path for THIS project's cache, as a String.
        // We construct a PathBuf temporarily to join, then convert back.
        let final_path_for_project = PathBuf::from(&final_cache_root_string)
            .join("projects")
            .join(self.uuid.to_string());
        final_options.cache_dir = Some(final_path_for_project.to_string_lossy().into_owned());

        // --- Pass 2: Merge overriding values (parent-to-child) ---

        // Iterate in reverse (child overrides parent) for merge-able options
        for &uuid in self.hierarchy.iter().rev() {
            let layer = self.get_layer(uuid)?;
            let layer_options = &layer.options;

            if layer_options.shell.is_some() {
                final_options.shell = layer_options.shell.clone();
            }
            if layer_options.cache_dir.is_some() {
                final_options.cache_dir = layer_options.cache_dir.clone();
            }
            if layer_options.open_with.default.is_some() {
                final_options.open_with.default = layer_options.open_with.default.clone();
            }
            if layer_options.prompt.is_some() {
                final_options.prompt = layer_options.prompt.clone();
            }

            final_options.open_with.commands.extend(
                layer_options
                    .open_with
                    .commands
                    .iter()
                    .map(|(k, v)| (k.clone(), Arc::new(v.clone()))),
            );
        }

        *guard = Some(final_options.clone());
        Ok(final_options)
    }

    // --- Helpers for `info` and `run` commands ---

    /// Lazily merges and returns all scripts from the entire hierarchy.
    /// This is used by commands like `axes run` (no script) to list all available scripts.
    /// Child definitions override parent definitions.
    pub fn get_all_scripts(&self) -> Result<HashMap<String, Arc<Task>>> {
        let mut final_scripts = HashMap::new();
        for &uuid in self.hierarchy.iter().rev() {
            let layer = self.get_layer(uuid)?;
            for (name, task) in layer.scripts.iter() {
                // Child definitions override parent ones.
                final_scripts.insert(name.clone(), Arc::new(task.clone()));
            }
        }
        Ok(final_scripts)
    }

    /// Lazily merges and returns all variables from the entire hierarchy.
    /// This is used by `axes info` to display all defined variables.
    /// Child definitions override parent definitions.
    pub fn get_all_vars(&self) -> Result<HashMap<String, Arc<CachedVar>>> {
        let mut final_vars = HashMap::new();
        for &uuid in self.hierarchy.iter().rev() {
            let layer = self.get_layer(uuid)?;
            for (name, var) in layer.vars.iter() {
                final_vars.insert(name.clone(), Arc::new(var.clone()));
            }
        }
        Ok(final_vars)
    }

    /// Selects the correct `CommandExecution` for the current OS from a `PlatformExecution` block.
    /// The selection logic prefers the specific OS version and falls back to `default`.
    ///
    /// # Arguments
    /// * `plat_exec` - The platform-agnostic execution block to select from.
    pub fn select_platform_exec<'a>(
        &self,
        plat_exec: &'a PlatformExecution,
    ) -> Option<&'a CommandExecution> {
        let os = std::env::consts::OS;
        if os == "windows" {
            plat_exec.windows.as_ref().or(plat_exec.default.as_ref())
        } else if os == "linux" {
            plat_exec.linux.as_ref().or(plat_exec.default.as_ref())
        } else if os == "macos" {
            plat_exec.macos.as_ref().or(plat_exec.default.as_ref())
        } else {
            plat_exec.default.as_ref()
        }
    }

    // --- Private Core Helper ---

    /// Core helper to get a layer. It waits on the promise to be resolved by the `ConfigLoader`.
    pub(crate) fn get_layer(&self, uuid: Uuid) -> Result<Arc<CachedProjectConfig>> {
        let promise = self.layers.get(&uuid).ok_or_else(|| {
            anyhow!(
                "Internal logic error: attempt to get a layer for UUID {} not in the hierarchy.",
                uuid
            )
        })?;
        let layer_result = promise.get().ok_or_else(|| {
            anyhow!(
                "Internal logic error: LayerPromise for UUID {} was never set.",
                uuid
            )
        })?;
        match layer_result {
            Ok(layer_arc) => Ok(layer_arc.clone()),
            Err(e) => Err(anyhow!(e.to_string())),
        }
    }

    // --- TASK FLATTENING LOGIC ---

    /// This function iterates through the `PlatformExecution` blocks of a universal task
    /// and selects the appropriate `CommandExecution` for the current operating system.
    /// The result is a flat, simple list of commands, ready for the fastest possible execution,
    /// eliminating the need for platform checks in the executor's hot loop.
    pub fn specialize_task_for_platform(
        &self,
        universal_task: &Arc<Task>,
    ) -> PlatformSpecializedTask {
        let specialized_commands: Vec<CommandExecution> = universal_task
            .commands
            .iter()
            .filter_map(|plat_exec| self.select_platform_exec(plat_exec).cloned())
            .collect();

        PlatformSpecializedTask {
            desc: universal_task.desc.clone(),
            commands: specialized_commands,
        }
    }

    /// Recursively flattens a `Task` by resolving all `scripts::` compositions.
    ///
    /// This process expands script references into a single, linear sequence of commands,
    /// while also propagating execution modifiers (e.g., `@`, `-`) from the parent
    /// script to the composed child commands. It also detects circular dependencies.
    ///
    /// # Arguments
    /// * `top_level_task` - The initial task to flatten.
    pub fn flatten_task(&self, top_level_task: &Arc<Task>) -> Result<Arc<Task>> {
        let mut call_stack = HashSet::new();
        self.flatten_task_recursive(top_level_task, &mut call_stack)
    }

    fn flatten_task_recursive(
        &self,
        task: &Arc<Task>,
        call_stack: &mut HashSet<String>,
    ) -> Result<Arc<Task>> {
        let mut new_commands = Vec::new();
        for plat_exec in &task.commands {
            let maybe_composition =
                self.select_platform_exec(plat_exec)
                    .and_then(|cmd_exec| match &cmd_exec.action {
                        CommandAction::Execute(tpl) if tpl.len() == 1 => Some((
                            tpl.first().expect("Template length is checked to be 1"),
                            cmd_exec,
                        )),
                        _ => None,
                    });
            if let Some((TemplateComponent::Script(name), parent_cmd_exec)) = maybe_composition {
                let key = format!("script::{}", name);
                if !call_stack.insert(key.clone()) {
                    return Err(anyhow!(
                        "Circular dependency detected involving script: '{}'",
                        name
                    ));
                }
                let sub_task = self.get_script(name)?.ok_or_else(|| {
                    anyhow!("Broken Reference: Script '<scripts::{}>' not found.", name)
                })?;
                let flattened_sub_task = self.flatten_task_recursive(&sub_task, call_stack)?;
                let mut inherited_commands = flattened_sub_task.commands.clone();
                for sub_plat_exec in &mut inherited_commands {
                    for cmd_exec in [
                        &mut sub_plat_exec.default,
                        &mut sub_plat_exec.windows,
                        &mut sub_plat_exec.linux,
                        &mut sub_plat_exec.macos,
                    ]
                    .into_iter()
                    .flatten()
                    {
                        cmd_exec.ignore_errors |= parent_cmd_exec.ignore_errors;
                        cmd_exec.run_in_parallel |= parent_cmd_exec.run_in_parallel;
                        cmd_exec.silent_mode |= parent_cmd_exec.silent_mode;
                    }
                }
                new_commands.extend(inherited_commands);
                call_stack.remove(&key);
            } else {
                let new_plat_exec = PlatformExecution {
                    default: self
                        .flatten_command_exec_recursive(plat_exec.default.as_ref(), call_stack)?,
                    windows: self
                        .flatten_command_exec_recursive(plat_exec.windows.as_ref(), call_stack)?,
                    linux: self
                        .flatten_command_exec_recursive(plat_exec.linux.as_ref(), call_stack)?,
                    macos: self
                        .flatten_command_exec_recursive(plat_exec.macos.as_ref(), call_stack)?,
                };
                new_commands.push(new_plat_exec);
            }
        }
        Ok(Arc::new(Task {
            commands: new_commands,
            desc: task.desc.clone(),
        }))
    }

    fn flatten_command_exec_recursive(
        &self,
        cmd_exec: Option<&CommandExecution>,
        call_stack: &mut HashSet<String>,
    ) -> Result<Option<CommandExecution>> {
        if let Some(cmd) = cmd_exec {
            let mut new_cmd = cmd.clone();
            let (new_action, template) = match &cmd.action {
                CommandAction::Execute(tpl) => (CommandAction::Execute(Vec::new()), tpl),
                CommandAction::Print(tpl) => (CommandAction::Print(Vec::new()), tpl),
            };
            let flattened_template = self.flatten_template_recursive(template, call_stack)?;
            new_cmd.action = match new_action {
                CommandAction::Execute(_) => CommandAction::Execute(flattened_template),
                CommandAction::Print(_) => CommandAction::Print(flattened_template),
            };
            Ok(Some(new_cmd))
        } else {
            Ok(None)
        }
    }

    pub(crate) fn flatten_template_recursive(
        &self,
        template: &[TemplateComponent],
        call_stack: &mut HashSet<String>,
    ) -> Result<Vec<TemplateComponent>> {
        let mut final_components = Vec::new();
        for component in template {
            match component {
                TemplateComponent::Script(name) | TemplateComponent::Var(name) => {
                    let is_var = matches!(component, TemplateComponent::Var(_));
                    let (token_type, key) = if is_var {
                        ("var", format!("var::{}", name))
                    } else {
                        ("script", format!("script::{}", name))
                    };
                    if !call_stack.insert(key.clone()) {
                        return Err(anyhow!(
                            "Circular dependency detected involving {}: '{}'",
                            token_type,
                            name
                        ));
                    }
                    if is_var {
                        let var = self.get_var(name)?.ok_or_else(|| {
                            anyhow!("Broken Reference: Var '<vars::{}>' not found.", name)
                        })?;
                        if let Some(cmd_exec) = self.select_platform_exec(&var.value) {
                            let (CommandAction::Execute(tpl) | CommandAction::Print(tpl)) =
                                &cmd_exec.action;
                            final_components
                                .extend(self.flatten_template_recursive(tpl, call_stack)?);
                        } else {
                            return Err(anyhow!(
                                "Var '{}' has no value for the current platform.",
                                name
                            ));
                        }
                    } else {
                        let script = self.get_script(name)?.ok_or_else(|| {
                            anyhow!("Broken Reference: Script '<scripts::{}>' not found.", name)
                        })?;
                        if script.commands.len() > 1 {
                            return Err(anyhow!(
                                "Inline composition of multi-line script '{}' is not supported.",
                                name
                            ));
                        }
                        if let Some(plat_exec) = script.commands.first()
                            && let Some(cmd_exec) = self.select_platform_exec(plat_exec)
                        {
                            let (CommandAction::Execute(tpl) | CommandAction::Print(tpl)) =
                                &cmd_exec.action;
                            final_components
                                .extend(self.flatten_template_recursive(tpl, call_stack)?);
                        }
                    }
                    call_stack.remove(&key);
                }
                _ => {
                    final_components.push(component.clone());
                }
            }
        }
        Ok(final_components)
    }
}

// =========================================================================
// === 3. PERSISTENCE & SYSTEM MODELS
// =========================================================================

/// Represents a project's entry in the global `index.bin` file.
#[derive(Deserialize, Serialize, Debug, Clone, PartialEq, Eq, Default)]
pub struct IndexEntry {
    /// The simple, non-unique name of the project (e.g., "backend").
    pub name: String,
    /// The absolute path to the project's root directory on the filesystem.
    pub path: PathBuf,
    /// The UUID of the parent project. `None` only for the virtual "global" project.
    pub parent: Option<Uuid>,
    /// The last known content hash of the project's `axes.toml` file, used for caching.
    pub config_hash: Option<String>,
    /// The last known absolute path to the project's cache directory.
    pub cache_dir: Option<PathBuf>,
    /// The UUID of the direct child that was most recently used as a context.
    pub last_used_child: Option<Uuid>,
}

/// Represents the global index, the single source of truth for all registered projects.
#[derive(Deserialize, Serialize, Debug, Clone, PartialEq, Default)]
pub struct GlobalIndex {
    /// A map from a project's unique `Uuid` to its metadata.
    #[serde(default)]
    pub projects: HashMap<Uuid, IndexEntry>,
    /// A map from a user-defined alias (e.g., "backend") to a project's `Uuid`.
    #[serde(default)]
    pub aliases: HashMap<String, Uuid>,
    /// The `Uuid` of the project that was most recently used as a context.
    pub last_used: Option<Uuid>,
}

/// Represents a project's local identity file (`.axes/project_ref.bin`).
/// This file makes the system resilient and self-repairing by storing the project's
/// core identity independently of the global index.
#[derive(Serialize, Deserialize, Debug, PartialEq, Eq, Clone)]
pub struct ProjectRef {
    /// The project's own unique identifier.
    pub self_uuid: Uuid,
    /// The UUID of the project's parent at the time of writing.
    pub parent_uuid: Option<Uuid>,
    /// The project's simple name at the time of writing.
    pub name: String,
}

/// Represents a configured shell in `shells.toml`.
#[derive(Deserialize, Serialize, Debug, Clone)]
pub struct ShellConfig {
    /// The path to the shell executable.
    pub path: PathBuf,
    /// A list of arguments required to start the shell in interactive mode and execute an init script.
    pub interactive_args: Option<Vec<String>>,
}

/// Represents the top-level structure of `shells.toml`.
#[derive(Deserialize, Serialize, Debug, Clone, Default)]
pub struct ShellsConfig {
    /// A map from a shell's name (e.g., "bash", "cmd") to its configuration.
    #[serde(default)]
    pub shells: HashMap<String, ShellConfig>,
}

/// Enum for supported ANSI colors and styles, used by the `<#color>` token.
#[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialEq, Eq)]
pub enum AnsiStyle {
    // --- Attributes ---
    /// Resets all styles and colors.
    Reset,
    /// Bold/intense text.
    Bold,
    /// Dim/faint text.
    Dim,
    /// Italic text.
    Italic,
    /// Underlined text.
    Underline,

    // --- Standard Colors ---
    /// Black Color
    Black,
    /// Red Color
    Red,
    /// Green Color
    Green,
    /// Yellow Color
    Yellow,
    /// Blue Color
    Blue,
    /// Magenta Color
    Magenta,
    /// Cyan Color
    Cyan,
    /// White Color
    White,

    // --- Bright (Intense) Colors ---
    /// Often rendered as Gray.
    BrightBlack,
    /// Bright version of Red, often used for errors or highlights.
    BrightRed,
    /// Bright version of Green, often used for success messages.
    BrightGreen,
    /// Bright version of Yellow, often used for warnings or emphasis.
    BrightYellow,
    /// Bright version of Blue, often used for informational text.
    BrightBlue,
    /// Bright version of Magenta, often used for accents or special highlights.
    BrightMagenta,
    /// Bright version of Cyan, often used for secondary information.
    BrightCyan,
    /// Bright version of White, often rendered as pure white.
    BrightWhite,
}

// =========================================================================
// === 4. CONSTRUCTORS & IMPLEMENTATIONS
// =========================================================================

impl ProjectConfig {
    /// Creates a new, default `ProjectConfig`.
    ///
    /// This function is used to generate the initial `axes.toml` for the `global` project
    /// when it's first created. It provides a set of sensible, platform-aware defaults
    /// for common actions, making `axes` useful out-of-the-box.
    pub fn new() -> Self {
        let mut open_with_commands = HashMap::new();

        // --- Editor scripts ---
        open_with_commands.insert(
            "editor".to_string(),
            TomlScript::Simple("<vars::editor_cmd> \"<path>\"".to_string()),
        );
        open_with_commands.insert(
            "idea".to_string(),
            TomlScript::Simple("<vars::idea_cmd> \"<path>\"".to_string()),
        );

        // --- OS-Specific File Explorer scripts ---
        // We use `cfg!` to compile platform-specific defaults, providing
        // a sensible out-of-the-box experience for `axes open`.
        if cfg!(target_os = "windows") {
            open_with_commands.insert(
                "explorer".to_string(),
                TomlScript::Simple("-explorer \"<path>\"".to_string()),
            );
        } else if cfg!(target_os = "macos") {
            open_with_commands.insert(
                "finder".to_string(),
                TomlScript::Simple("open \"<path>\"".to_string()),
            );
        } else {
            // Linux and others
            open_with_commands.insert(
                "files".to_string(),
                TomlScript::Simple("xdg-open \"<path>\"".to_string()),
            );
        }

        // --- Terminal/Shell Command ---
        if cfg!(target_os = "windows") {
            open_with_commands.insert(
                "shell".to_string(),
                TomlScript::Simple("start cmd.exe /K \"cd /D <path>\"".to_string()),
            );
        } else {
            open_with_commands.insert(
                "shell".to_string(),
                TomlScript::Simple("<vars::terminal_cmd>".to_string()),
            );
        }

        let open_with_config = TomlOpenWithConfig {
            default: Some(if cfg!(target_os = "windows") {
                "explorer".to_string()
            } else if cfg!(target_os = "macos") {
                "finder".to_string()
            } else {
                "files".to_string()
            }),
            commands: open_with_commands,
        };

        // --- Default Variables ---
        let mut vars_defaults = HashMap::new();
        vars_defaults.insert(
            "editor_cmd".to_string(),
            TomlVar::Simple("code".to_string()),
        );
        vars_defaults.insert("idea_cmd".to_string(), TomlVar::Simple("idea".to_string()));
        vars_defaults.insert(
            "terminal_cmd".to_string(),
            TomlVar::Simple("gnome-terminal --working-directory=<path>".to_string()),
        );

        Self {
            name: Some("global".to_string()),
            version: Some("0.1.0".to_string()),
            description: Some("The global axes project configuration.".to_string()),
            scripts: HashMap::new(),
            options: OptionsConfig {
                open_with: open_with_config,
                prompt: Some("(axes: <#cyan><name><#reset>) $ ".to_string()),
                ..Default::default()
            },
            vars: vars_defaults,
            env: HashMap::new(),
        }
    }

    /// Creates a minimal yet structurally complete `ProjectConfig` for `axes init`.
    /// It acts as a scaffold for new projects.
    ///
    /// # Arguments
    ///
    /// * `name` - The name of the project.
    /// * `version` - The version of the project.
    /// * `description` - The description of the project.
    pub fn new_for_init(name: &str, version: &str, description: &str) -> Self {
        let mut scripts = HashMap::new();
        let mut vars = HashMap::new();

        // then wrap it in the `TomlScript::Extended` variant.
        let test_script = TomlScript::Extended(TomlScriptExtended {
            desc: Some("Run a simple test echo command.".to_string()),
            run: Box::new(TomlScript::Simple(
                "echo \"✅ Test for '<name>' successful!\"".to_string(),
            )),
        });
        scripts.insert("test".to_string(), test_script);

        vars.insert(
            "GREETING".to_string(),
            TomlVar::Simple("Hello from an axes variable!".to_string()),
        );

        let options = OptionsConfig {
            at_start: Some(TomlScript::Extended(TomlScriptExtended {
                desc: Some(
                    "Commands to run when entering a session (e.g., `source .venv/bin/activate`)"
                        .to_string(),
                ),
                run: Box::new(TomlScript::Simple(
                    "# echo 'Entering session...'".to_string(),
                )),
            })),
            at_exit: Some(TomlScript::Extended(TomlScriptExtended {
                desc: Some(
                    "Commands to run when exiting a session (e.g., `docker-compose down`)"
                        .to_string(),
                ),
                run: Box::new(TomlScript::Simple(
                    "# echo 'Exiting session...'".to_string(),
                )),
            })),
            ..Default::default()
        };

        Self {
            name: Some(name.to_string()),
            version: Some(version.to_string()),
            description: Some(description.to_string()),
            scripts,
            vars,
            options,
            env: HashMap::new(),
        }
    }
}

===== state.rs =====
//! # Application State Management
//!
//! This module provides a high-performance, journaling-based state management system for the application.
//! It is designed to minimize expensive clone and write operations by intelligently tracking changes
//! to the `GlobalIndex`.
//!
//! ## Key Components
//!
//! - `AppState`: The core struct that holds the state, transitioning from `Pristine` to `Dirty`
//!   on the first mutation.
//! - `AppStateGuard`: A custom `MutexGuard` that provides a safe and explicit API for accessing
//!   and modifying the state.
//! - `get_app_state` & `lock_app_state`: Singleton accessors to the global state, ensuring that
//!   all interactions are thread-safe.
//!
//! ## Design Philosophy
//!
//! The state is loaded once at the beginning of the application's lifecycle. A snapshot of the
//! original state is taken only when a mutable operation is requested. This "copy-on-write"
//! strategy ensures that read-only operations are extremely fast and that the application only
//! saves the state back to disk if actual changes have occurred.
//!
// src/state.rs

use crate::core::index_manager;
use crate::models::GlobalIndex;
use std::path::PathBuf;
use std::sync::{Arc, Mutex, MutexGuard, OnceLock};
use uuid::Uuid;

// --- Public Structs & Enums ---

/// Manages the application's global state using a high-performance journaling system.
///
/// This struct acts as an intelligent gatekeeper to the `GlobalIndex`. It avoids the high cost
/// of cloning the index on every run by instead keeping a snapshot of the original state *only*
/// when a mutation is first requested. At the end of the application lifecycle, it can
/// efficiently determine if a save-to-disk operation is truly necessary by comparing the final
/// state against the initial snapshot.
#[derive(Debug)]
pub struct AppState {
    state: IndexState,
}

/// A custom `MutexGuard` that provides a controlled, explicit API for state interaction.
///
/// Instead of transparently dereferencing, this guard requires consumers to explicitly
/// request read-only (`.index()`) or mutable (`.index_mut()`) access. This makes the intent
/// of the code clearer and enables fine-grained, intelligent updates that minimize performance
/// overhead.
#[derive(Debug)]
pub struct AppStateGuard<'a> {
    guard: MutexGuard<'a, AppState>,
}

// --- Private Implementation Details ---

/// An internal enum representing the two possible conditions of the `GlobalIndex`.
#[derive(Debug)]
enum IndexState {
    /// The index has not been touched. It contains the state as it was loaded from disk.
    /// This is the default state for read-only commands.
    Pristine(GlobalIndex),
    /// A mutable operation has been requested. The state now holds both a clone of the
    /// original state and the current, modified state.
    Dirty {
        original: GlobalIndex,
        current: GlobalIndex,
    },
}

// --- Implementations ---

impl AppState {
    /// Creates a new `AppState` instance, starting in a `Pristine` state.
    fn new(index: GlobalIndex) -> Self {
        Self {
            state: IndexState::Pristine(index),
        }
    }

    /// Determines if the index has changed and needs to be saved to disk.
    ///
    /// This is a highly efficient check. If the state is `Pristine`, it returns `false`
    /// instantly. If `Dirty`, it performs a deep comparison between the original snapshot
    /// and the current state.
    pub fn needs_saving(&self) -> bool {
        match &self.state {
            IndexState::Pristine(_) => false,
            IndexState::Dirty { original, current } => original != current,
        }
    }

    /// Returns a read-only reference to the current `GlobalIndex`.
    /// This is used by `main.rs` to save the final state if `needs_saving` returns true.
    pub fn index(&self) -> &GlobalIndex {
        match &self.state {
            IndexState::Pristine(index) => index,
            IndexState::Dirty { current, .. } => current,
        }
    }

    /// Transitions the state to `Dirty` if it's currently `Pristine`.
    ///
    /// This is the core of the journaling mechanism. It is called only on the first
    /// request for mutable access. It performs the single, lazy clone operation required
    /// to enable change tracking.
    fn ensure_dirty_and_get_mut(&mut self) -> &mut GlobalIndex {
        if let IndexState::Pristine(_) = self.state {
            // Atomically replace the state to move ownership of the index.
            self.state = match std::mem::replace(
                &mut self.state,
                IndexState::Pristine(GlobalIndex::default()), // Temporary placeholder
            ) {
                IndexState::Pristine(index) => IndexState::Dirty {
                    original: index.clone(), // The one and only clone operation!
                    current: index,
                },
                _ => unreachable!(), // Should never happen
            };
        }

        match &mut self.state {
            IndexState::Dirty { current, .. } => current,
            _ => unreachable!(),
        }
    }
}

impl<'a> AppStateGuard<'a> {
    /// Returns a read-only reference to the `GlobalIndex`.
    /// This operation is always cheap and never triggers a state change.
    pub fn index(&self) -> &GlobalIndex {
        self.guard.index()
    }

    /// Returns a mutable reference to the `GlobalIndex`.
    ///
    /// This is the primary entry point for structural modifications (e.g., adding/deleting
    /// projects). Calling this method will trigger the `Pristine` -> `Dirty` state
    /// transition on its first invocation.
    pub fn index_mut(&mut self) -> &mut GlobalIndex {
        self.guard.ensure_dirty_and_get_mut()
    }

    /// Intelligently updates a project's cache metadata (`config_hash`, `cache_dir`).
    ///
    /// It performs read-only checks first and only requests mutable access if the new
    /// data is different from the existing data, preventing unnecessary state clones.
    ///
    /// # Arguments
    ///
    /// * `uuid` - The UUID of the project to update.
    /// * `new_hash` - The new configuration hash to set.
    /// * `new_cache_dir` - The new cache directory to set.
    pub fn update_project_cache_info(
        &mut self,
        uuid: Uuid,
        new_hash: Option<String>,
        new_cache_dir: Option<PathBuf>,
    ) {
        let index = self.guard.index();
        let project = match index.projects.get(&uuid) {
            Some(p) => p,
            None => return,
        };

        let hash_changed = new_hash
            .as_ref()
            .is_some_and(|h| project.config_hash.as_ref() != Some(h));
        let dir_changed = new_cache_dir
            .as_ref()
            .is_some_and(|d| project.cache_dir.as_ref() != Some(d));

        if hash_changed || dir_changed {
            let mutable_project = self
                .guard
                .ensure_dirty_and_get_mut()
                .projects
                .get_mut(&uuid)
                .expect("Project UUID must exist in the index at this point");
            if hash_changed {
                mutable_project.config_hash = new_hash;
            }
            if dir_changed {
                mutable_project.cache_dir = new_cache_dir;
            }
        }
    }

    /// Intelligently updates `last_used` and `last_used_child` metadata.
    ///
    /// It first performs a series of read-only checks to determine if any updates are
    /// necessary. It only requests mutable access if a change is guaranteed to happen,
    /// avoiding unnecessary clone operations for idempotent updates.
    ///
    /// # Arguments
    ///
    /// * `final_uuid` - The UUID of the project that was last used.
    pub fn update_last_used_caches(&mut self, final_uuid: Uuid) {
        // Phase 1: Read-Only Analysis
        let mut needs_update = false;
        let index = self.guard.index();

        if index.last_used != Some(final_uuid) {
            needs_update = true;
        } else {
            let mut child_uuid = final_uuid;
            let mut parent_uuid_opt = index.projects.get(&child_uuid).and_then(|e| e.parent);

            while let Some(parent_uuid) = parent_uuid_opt {
                if let Some(parent) = index.projects.get(&parent_uuid) {
                    if parent.last_used_child != Some(child_uuid) {
                        needs_update = true;
                        break;
                    }
                    child_uuid = parent_uuid;
                    parent_uuid_opt = parent.parent;
                } else {
                    break;
                }
            }
        }

        // Phase 2: Conditional Write Operation
        if !needs_update {
            log::trace!("`last_used` metadata is already up-to-date. Skipping write.");
            return;
        }

        log::debug!("`last_used` metadata needs updating. Performing write operation.");
        let mutable_index = self.guard.ensure_dirty_and_get_mut();

        mutable_index.last_used = Some(final_uuid);

        let mut child_uuid_to_save = final_uuid;
        let mut current_uuid_opt = mutable_index
            .projects
            .get(&child_uuid_to_save)
            .and_then(|e| e.parent);

        while let Some(parent_uuid) = current_uuid_opt {
            if let Some(parent_entry) = mutable_index.projects.get_mut(&parent_uuid) {
                parent_entry.last_used_child = Some(child_uuid_to_save);
                child_uuid_to_save = parent_uuid;
                current_uuid_opt = parent_entry.parent;
            } else {
                break;
            }
        }
    }
}

// --- Static Global State ---

/// The single, global, lazily-initialized application state.
static APP_STATE: OnceLock<Arc<Mutex<AppState>>> = OnceLock::new();

/// Returns a reference to the global `AppState` singleton.
/// It handles the initial loading and creation of the state on the first call.
pub fn get_app_state() -> &'static Arc<Mutex<AppState>> {
    APP_STATE.get_or_init(|| {
        let index =
            index_manager::load_and_ensure_global_project().expect("Failed to load global index.");
        Arc::new(Mutex::new(AppState::new(index)))
    })
}

/// Acquires a lock on the global state and returns our custom `AppStateGuard`.
/// This is the primary entry point for all state interactions within the application logic.
pub fn lock_app_state() -> AppStateGuard<'static> {
    let state_arc = get_app_state();
    let guard = state_arc
        .lock()
        .expect("App state mutex should not be poisoned");
    AppStateGuard { guard }
}

===== system\executor.rs =====
//! # System Command Execution
//!
//! This module provides a robust, high-performance, and platform-aware abstraction for
//! executing external system commands. It is built on top of `tokio::process` to handle
//! asynchronous operations efficiently, while providing a simple synchronous API to the
//! rest of the application.
//!
//! ## Key Features
//!
//! - **Async Backend, Sync API**: Uses a global `tokio` runtime to manage child processes
//!   without blocking the main `axes` thread, which is crucial for features like parallel
//!   execution.
//! - **Graceful Cancellation**: `execute_command` properly handles `Ctrl+C` signals, ensuring
//!   that child processes are terminated correctly.
//! - **Platform Compatibility**: Includes a fallback for Windows to execute shell built-ins
//!   (like `echo` or `dir`) via `cmd.exe /C`, increasing compatibility.
//! - **Output Capturing**: Provides `execute_and_capture_output` for use in substitutions like
//!   `<run(...)>`, allowing dynamic command generation.
//! - **Robust Error Handling**: The `ExecutionError` enum provides clear, contextual information
//!   about why a command failed.

use dunce;
use lazy_static::lazy_static;
use std::collections::HashMap;
use std::io::ErrorKind;
use std::path::Path;
use std::process::Stdio;
use thiserror::Error;
use tokio::process::Command as TokioCommand;
use tokio::runtime::Runtime;

lazy_static! {
    /// A global multi-threaded Tokio runtime for executing commands.
    /// We use a multi-threaded runtime to allow for true parallelism
    /// if `axes` ever needs to spawn multiple blocking tasks concurrently.
    static ref TOKIO_RT: Runtime = tokio::runtime::Builder::new_multi_thread()
        .enable_all()
        .build()
        .expect("Failed to create Tokio runtime for command execution");
}

/// Represents errors that can occur during the execution of an external command.
#[derive(Error, Debug)]
pub enum ExecutionError {
    /// The command string could not be parsed into a program and arguments (e.g., due to mismatched quotes).
    #[error("Command could not be parsed: {0}")]
    CommandParse(String),
    /// The command failed to spawn, often because the executable was not found in the system's `PATH`.
    #[error("Command '{0}' could not be executed: {1}")]
    CommandFailed(String, std::io::Error),
    /// The command executed successfully but returned a non-zero exit code, indicating failure.
    #[error("Command '{0}' exited with a non-zero error code.")]
    NonZeroExitStatus(String),
    /// The command was terminated prematurely by a signal, typically `Ctrl+C`.
    #[error("Command '{command}' was interrupted by a signal (e.g., Ctrl+C).")]
    Interrupted {
        /// The command that was interrupted.
        command: String,
    },
    /// The command produced standard output that was not valid UTF-8, preventing it from being captured as a String.
    #[error("Command '{command}' produced output that was not valid UTF-8")]
    InvalidUtf8Output {
        /// The command that produced invalid output.
        command: String,
        /// The underlying UTF-8 conversion error.
        #[source]
        source: std::string::FromUtf8Error,
    },
}

/// Executes a system command, inheriting standard input, output, and error streams.
///
/// This function is the primary way to run interactive or long-running commands. It blocks
/// until the command completes but uses an asynchronous runtime internally to handle I/O
/// and process signals gracefully. It includes a `tokio::select!` block to race the
/// child process against a `Ctrl+C` signal, ensuring proper cleanup.
///
/// # Arguments
/// * `command` - The full command string to execute (e.g., `"npm install --save-dev"`).
/// * `ignore_errors` - If `true`, a non-zero exit code will not be considered an error.
/// * `cwd` - The working directory in which to execute the command.
/// * `env_vars` - A map of environment variables to set for the child process.
pub fn execute_command(
    command: &str,
    ignore_errors: bool,
    cwd: &Path,
    env_vars: &HashMap<String, String>, // Currently unused, but kept for API consistency.
) -> Result<(), ExecutionError> {
    TOKIO_RT.block_on(async {
        let trimmed_command = command.trim();
        if trimmed_command.is_empty() {
            return Ok(());
        }

        if trimmed_command.is_empty() {
            return Ok(());
        }

        let parts = shlex::split(trimmed_command)
            .ok_or_else(|| ExecutionError::CommandParse(trimmed_command.to_string()))?;

        if parts.is_empty() {
            return Ok(());
        }

        let (program, args) = parts.split_first().expect("Parts should not be empty here");
        let clean_cwd = dunce::simplified(cwd);

        // We need to create the command inside the async block.
        let mut command = TokioCommand::new(program);
        command
            .args(args)
            .current_dir(clean_cwd)
            .envs(env_vars)
            .stdin(Stdio::inherit())
            .stdout(Stdio::inherit())
            .stderr(Stdio::inherit());

        let mut child = match command.spawn() {
            Ok(child) => child,
            Err(e) if e.kind() == ErrorKind::NotFound && cfg!(target_os = "windows") => {
                TokioCommand::new("cmd")
                    .arg("/C")
                    .arg(trimmed_command)
                    .current_dir(clean_cwd)
                    .envs(env_vars)
                    .stdin(Stdio::inherit())
                    .stdout(Stdio::inherit())
                    .stderr(Stdio::inherit())
                    .spawn()
                    .map_err(|e| ExecutionError::CommandFailed(trimmed_command.to_string(), e))?
            }
            Err(e) => {
                return Err(ExecutionError::CommandFailed(
                    trimmed_command.to_string(),
                    e,
                ));
            }
        };

        // Asynchronously wait for either the child to exit or for a Ctrl+C signal.
        tokio::select! {
            // Biased select to prefer checking for cancellation first.
            biased;

            _ = tokio::signal::ctrl_c() => {
                log::debug!("Ctrl+C signal received. Attempting to kill child process...");
                if let Some(pid) = child.id() {
                    log::debug!("Child PID is {}", pid);
                }
                // Attempt to gracefully kill the process.
                child.kill().await.map_err(|e| {
                    log::warn!("Failed to kill child process: {}", e);
                    ExecutionError::CommandFailed(trimmed_command.to_string(), e)
                })?;
                log::debug!("Child process killed.");
                Err(ExecutionError::Interrupted { command: trimmed_command.to_string() })
            }

            status_result = child.wait() => {
                match status_result {
                    Ok(status) if !status.success() && !ignore_errors => {
                        Err(ExecutionError::NonZeroExitStatus(trimmed_command.to_string()))
                    }
                    Ok(_) => Ok(()),
                    Err(e) => Err(ExecutionError::CommandFailed(trimmed_command.to_string(), e)),
                }
            }
        }
    })
}

/// Executes a command and captures its standard output as a `String`.
///
/// This function is intended for short-lived commands used for dynamic substitutions, such as
/// in `<run('git rev-parse HEAD')>`. Standard error is passed through to the user's terminal,
/// but standard output is captured. This function does *not* handle `Ctrl+C`, as it's
/// expected to complete quickly.
///
/// # Arguments
/// * `command_line` - The full command string to execute.
/// * `cwd` - The working directory for the command.
/// * `env_vars` - A map of environment variables to set for the child process.
///
/// # Returns
/// A `Result` containing the captured standard output, trimmed of whitespace, on success.
pub fn execute_and_capture_output(
    command_line: &str,
    cwd: &Path,
    env_vars: &HashMap<String, String>,
) -> Result<String, ExecutionError> {
    TOKIO_RT.block_on(async {
        let trimmed_command = command_line.trim();
        if trimmed_command.is_empty() {
            return Ok(String::new());
        }

        let parts = shlex::split(trimmed_command)
            .ok_or_else(|| ExecutionError::CommandParse(trimmed_command.to_string()))?;
        if parts.is_empty() {
            return Ok(String::new());
        }

        let (program, args) = parts.split_first().expect("Parts should not be empty here");
        let clean_cwd = dunce::simplified(cwd);

        let mut command = TokioCommand::new(program);
        command
            .args(args)
            .current_dir(clean_cwd)
            .envs(env_vars)
            .stdin(Stdio::null()) // Don't inherit stdin
            .stdout(Stdio::piped()) // Capture stdout
            .stderr(Stdio::inherit()); // Pass through stderr

        let output = match command.output().await {
            Ok(out) => out,
            Err(e) if e.kind() == ErrorKind::NotFound && cfg!(target_os = "windows") => {
                TokioCommand::new("cmd")
                    .arg("/C")
                    .arg(trimmed_command)
                    .current_dir(clean_cwd)
                    .envs(env_vars)
                    .stdin(Stdio::null())
                    .stdout(Stdio::piped())
                    .stderr(Stdio::inherit())
                    .output()
                    .await
                    .map_err(|e| ExecutionError::CommandFailed(trimmed_command.to_string(), e))?
            }
            Err(e) => {
                return Err(ExecutionError::CommandFailed(
                    trimmed_command.to_string(),
                    e,
                ));
            }
        };

        if !output.status.success() {
            return Err(ExecutionError::NonZeroExitStatus(
                trimmed_command.to_string(),
            ));
        }

        String::from_utf8(output.stdout).map_err(|e| ExecutionError::InvalidUtf8Output {
            command: trimmed_command.to_string(),
            source: e,
        })
    })
}

===== system\mod.rs =====
//! # System Interaction Layer
//!
//! This module provides abstractions for interacting with the underlying operating system.
//! It serves as a boundary between the core application logic and the specifics of process
//! management, shell environments, and configuration files.
//!
//! ## Modules
//!
//! - **`executor`**: A robust, high-performance engine for spawning and managing external
//!   processes. It handles graceful cancellation (`Ctrl+C`), platform-specific command
//!   execution (e.g., `cmd.exe` on Windows), and output capturing.
//! - **`shell`**: Manages the lifecycle of an interactive project session (`axes start`). It's
//!   responsible for generating init scripts, setting up the environment, and launching the
//!   user's configured shell.
//! - **`shells_config`**: Handles the loading and parsing of the `shells.toml` file, which
//!   defines the shells available for `axes start` sessions.

pub mod executor;
pub mod shell;
pub mod shells_config;

===== system\shell.rs =====
//! # Interactive Shell Session Management
//!
//! This module is responsible for the logic behind the `axes start` command. It orchestrates
//! the entire lifecycle of a project-specific interactive shell session, including setup,

//! execution of lifecycle hooks (`at_start`, `at_exit`), and teardown.
//!
//! ## Core Logic
//!
//! 1.  **Shell Resolution**: Determines which shell to use based on the project's configuration
//!     and the central `shells.toml` file.
//! 2.  **Init Script Generation**: Dynamically creates a temporary shell script (`.bat` or `.sh`)
//!     that sets up the session environment. This script includes:
//!     - Exporting all environment variables defined in the project's hierarchy.
//!     - Executing the commands from the `at_start` hook.
//!     - Customizing the shell prompt, if configured.
//! 3.  **Process Spawning**: Spawns the chosen shell as a new child process, passing the generated
//!     init script to it for execution. The new shell inherits the project's working directory
//!     and special `AXES_*` environment variables.
//! 4.  **Cleanup**: Once the user exits the interactive shell, it executes the `at_exit` hook
//!     and ensures that the temporary init script is deleted.

use crate::{
    core::{parameters::ArgResolver, task_executor},
    models::{CommandAction, ResolvedConfig, Task},
    system::shells_config,
};
use anyhow::Result;
use colored::Colorize;
use std::fmt::Write;
use std::{fs, process::Command, sync::Arc};
use tempfile::NamedTempFile;
use thiserror::Error;

/// Represents errors specific to launching or managing a shell session.
#[derive(Error, Debug)]
pub enum ShellError {
    /// A filesystem I/O error occurred.
    #[error("Filesystem Error: {0}")]
    Io(#[from] std::io::Error),
    /// An error occurred while creating or persisting the temporary init script.
    #[error("Error with temporary file: {0}")]
    TempFile(#[from] tempfile::PersistError),
    /// The main `axes` configuration directory could not be found.
    #[error("Could not find axes config directory.")]
    ConfigDirNotFound,
    /// The shell specified in the project's options is not defined in `shells.toml`.
    #[error("Requested shell '{0}' is not defined in shells.toml.")]
    ShellNotDefined(String),
    /// A default shell for the current operating system could not be determined.
    #[error("Could not determine a default shell for this operating system.")]
    NoDefaultShell,
    /// The `shells.toml` file contains invalid TOML syntax.
    #[error("Failed to parse shells.toml: {0}")]
    TomlParse(#[from] toml::de::Error),
    /// An error occurred while serializing the default `shells.toml` file.
    #[error("Failed to serialize shells config to TOML: {0}")]
    TomlSerialize(#[from] toml::ser::Error),
    /// An error occurred while executing an `at_start` or `at_exit` task.
    #[error("Task execution failed: {0}")]
    TaskExecution(#[from] anyhow::Error),
}

/// Launches an interactive shell session for a project.
///
/// This function orchestrates the entire session lifecycle:
/// 1.  Resolves the project's configuration to determine the correct shell and environment.
/// 2.  Renders the `at_start` hook commands into a temporary initialization script.
/// 3.  Spawns a new interactive shell process, configured to run the init script upon startup.
/// 4.  After the user exits the shell, it executes the `at_exit` hook.
///
/// # Arguments
/// * `config` - The lazy `ResolvedConfig` facade for the project.
/// * `task_start` - An `Option<Arc<Task>>` for the `at_start` hook.
/// * `task_exit` - An `Option<Arc<Task>>` for the `at_exit` hook.
/// * `resolver` - The `ArgResolver` for any parameters passed to the `axes start` command.
pub fn launch_session(
    config: &ResolvedConfig,
    task_start: Option<Arc<Task>>,
    task_exit: Option<Arc<Task>>,
    resolver: &ArgResolver<'_>,
) -> Result<(), ShellError> {
    // 1. Determine which shell to use.
    let shells_config = shells_config::load_shells_config()?;
    let options = config.get_options()?;
    let shell_name: String = options
        .shell
        .clone()
        .unwrap_or_else(|| shells_config::get_default_shell_name().to_string());
    let shell_config = shells_config
        .shells
        .get(&shell_name)
        .ok_or_else(|| ShellError::ShellNotDefined(shell_name.clone()))?;

    // 2. If an `at_start` task exists, render its commands into a script.
    // Esta lógica es especial y no usa `execute_task`, por lo que se mantiene.
    let at_start_final_commands = if let Some(task) = &task_start {
        println!(
            "\n{}",
            format!(t!("start.info.preparing_hook"), hook = "at_start").dimmed()
        );

        let mut commands = Vec::new();
        for plat_exec in &task.commands {
            if let Some(cmd_exec) = config.select_platform_exec(plat_exec) {
                let rendered_command = match &cmd_exec.action {
                    CommandAction::Execute(template) => {
                        task_executor::assemble_final_command(template, config, resolver, 0)?
                    }
                    CommandAction::Print(template) => {
                        let text =
                            task_executor::assemble_final_command(template, config, resolver, 0)?;
                        format!("echo \"{}\"", text.replace('"', "\\\""))
                    }
                };
                commands.push(rendered_command);
            }
        }
        commands
    } else {
        Vec::new()
    };

    let rendered_prompt = if let Some(prompt_template) = &options.prompt {
        // We can create a temporary template to pass to our powerful assembler.
        let template = crate::core::compiler::tokenize_string(prompt_template)?;
        Some(task_executor::assemble_final_command(
            &template, config, resolver, 0,
        )?)
    } else {
        None
    };

    // 3. Create the temporary initialization script using a scope guard for robust cleanup.
    let is_windows_shell = shell_name == "cmd" || shell_name == "powershell";
    let script_extension = if is_windows_shell { "bat" } else { "sh" };

    // Create a named temp file that will persist.
    let temp_script_file = NamedTempFile::with_prefix("axes-init-")?;
    let temp_script_path = temp_script_file.path().with_extension(script_extension);
    let script_content = build_init_script(
        config,
        &at_start_final_commands,
        &shell_name,
        rendered_prompt.as_deref(),
    )?;
    fs::write(&temp_script_path, &script_content)?;

    // This guard ensures the temp file is deleted when `launch_session` returns,
    // even in case of an error or panic in the code below.
    let _guard = scopeguard::guard((), |_| {
        let _ = fs::remove_file(&temp_script_path);
        log::trace!(
            "Cleaned up temporary script file: {}",
            temp_script_path.display()
        );
    });

    //// 3. Create the temporary initialization script.
    //let is_windows_shell = shell_name == "cmd" || shell_name == "powershell";
    //let script_extension = if is_windows_shell { "bat" } else { "sh" };
    //let temp_script_file = NamedTempFile::with_prefix("axes-init-")?.into_temp_path();
    //let temp_script_path = temp_script_file.with_extension(script_extension);
    //
    //let script_content = build_init_script(config, &at_start_final_commands, is_windows_shell)?;
    //fs::write(&temp_script_path, &script_content)?;

    // 4. Spawn the interactive shell process.
    println!(
        "\n--- {} '{}' {}. ---",
        "axes session for".green(),
        config.qualified_name.yellow().bold(),
        "started".green()
    );

    let mut cmd = Command::new(&shell_config.path);
    cmd.current_dir(&config.project_root);
    cmd.env("AXES_PROJECT_ROOT", config.project_root.as_os_str());
    cmd.env("AXES_PROJECT_NAME", &config.qualified_name);
    cmd.env("AXES_PROJECT_UUID", config.uuid.to_string());

    let env_vars = config.get_env()?;
    cmd.envs(env_vars.as_ref());

    if let Some(args) = &shell_config.interactive_args {
        cmd.args(args);
        cmd.arg(&temp_script_path);
    }

    let status = cmd.status()?;
    if !status.success() {
        log::warn!("Interactive shell exited with code: {:?}", status.code());
    }

    let _ = fs::remove_file(&temp_script_path);

    // 5. Execute the `at_exit` task if it exists.
    if let Some(task_universal) = &task_exit {
        println!(
            "\n{}",
            format!(t!("start.info.executing_hook"), hook = "at_exit").dimmed()
        );

        // Specialize the `at_exit` task for the current platform before execution.
        let task_specialized = config.specialize_task_for_platform(task_universal);

        // Pass the optimized, specialized task to the executor.
        task_executor::execute_task(&task_specialized, config, resolver)?;
    }

    Ok(())
}

/// Helper function to escape a string for safe use within a `cmd.exe` `set "KEY=VALUE"` command.
/// It handles special characters that could otherwise terminate the command or be interpreted by the shell.
fn escape_for_cmd_set(value: &str) -> String {
    value
        .replace('%', "%%")
        .replace('^', "^^")
        .replace('&', "^&")
        .replace('<', "^<")
        .replace('>', "^>")
        .replace('|', "^|")
}

/// Dynamically builds the content of the temporary initialization script.
///
/// This function generates shell-specific commands to export environment variables,
/// run `at_start` hooks, and customize the shell prompt.
///
/// # Arguments
/// * `config` - The resolved project configuration.
/// * `at_start_commands` - A list of pre-rendered commands from the `at_start` hook.
/// * `shell_name` - The name of the target shell (e.g., "bash", "cmd").
/// * `prompt` - An optional pre-rendered string for the custom shell prompt.
fn build_init_script(
    config: &ResolvedConfig,
    at_start_commands: &[String],
    shell_name: &str,
    prompt: Option<&str>,
) -> Result<String> {
    // Determine the shell family for easier logic branching.
    let is_cmd = shell_name == "cmd";
    let is_posix = shell_name == "bash" || shell_name == "zsh";

    let mut script = String::with_capacity(256 + at_start_commands.len() * 128);

    if is_cmd {
        writeln!(script, "@echo off")?;
    }

    for (key, value) in &*config.get_env()? {
        if is_cmd {
            let escaped_value = escape_for_cmd_set(value);
            writeln!(script, "set \"{}={}\"", key, escaped_value)?;
        } else {
            // Assume POSIX-like escaping for PowerShell, Bash, Zsh etc.
            let escaped_value = value.replace('\'', "'\\''");
            writeln!(script, "export {}='{}'", key, escaped_value)?;
        }
    }
    writeln!(script)?;

    for command in at_start_commands {
        if !command.trim().is_empty() {
            writeln!(script, "{}", command)?;
        }
    }

    if let Some(prompt_str) = prompt {
        match shell_name {
            "bash" | "zsh" => {
                let escaped = prompt_str
                    .replace('\\', "\\\\")
                    .replace('$', "\\$")
                    .replace('`', "\\`");
                writeln!(script, "\nexport PS1='{}'", escaped)?;
            }
            "cmd" => {
                let escaped = prompt_str.replace('$', "$$");
                writeln!(script, "\nPROMPT {}", escaped)?;
            }
            "powershell" => {
                let escaped = prompt_str.replace('\'', "''");
                writeln!(
                    script,
                    "\nfunction prompt {{ Write-Host -NoNewline '{}'; return ' ' }}",
                    escaped
                )?;
            }
            _ => {
                log::warn!(
                    "Prompt customization is not supported for shell '{}'.",
                    shell_name
                );
            }
        }
    }

    let exit_message = "--- Type 'exit' to leave. ---";
    if is_cmd {
        writeln!(script, "\necho.\necho {}\necho.", exit_message)?;
    } else if is_posix {
        // POSIX shells can use echo with single quotes.
        writeln!(script, "\necho ''\necho '{}'\necho ''", exit_message)?;
    } else {
        // PowerShell handles echo differently, but simple echo works.
        writeln!(script, "\necho ''\necho '{}'\necho ''", exit_message)?;
    }
    Ok(script)
}

===== system\shells_config.rs =====
//! # Shell Configuration Management
//!
//! This module handles the loading, parsing, and default generation of the `shells.toml`
//! configuration file. This file allows users to define which shells are available for
//! `axes start` sessions and how they should be launched.
//!
//! ## Core Logic
//!
//! - **Loading**: `load_shells_config` reads `~/.config/axes/shells.toml`.
//! - **Default Generation**: If the file doesn't exist, `generate_default_shells_config`
//!   creates a sensible default configuration by detecting common shells (like `bash`, `cmd.exe`,
//!   `powershell.exe`) present in the system's `PATH`.
//! - **Platform Awareness**: The default configuration and default shell name are tailored
//!   to the host operating system.

use std::{collections::HashMap, env, fs, path::PathBuf};

use crate::{
    models::{ShellConfig, ShellsConfig},
    system::shell::ShellError,
};

/// Loads the `shells.toml` configuration from the `axes` config directory.
/// If the file does not exist, it generates a default one and saves it for future use.
pub fn load_shells_config() -> Result<ShellsConfig, ShellError> {
    let config_dir =
        crate::core::paths::get_axes_config_dir().map_err(|_| ShellError::ConfigDirNotFound)?;
    let shells_path = config_dir.join("shells.toml");
    if !shells_path.exists() {
        let default_config = generate_default_shells_config();
        let toml_string = toml::to_string_pretty(&default_config)?;
        fs::write(&shells_path, toml_string)?;
        Ok(default_config)
    } else {
        let content = fs::read_to_string(shells_path)?;
        Ok(toml::from_str(&content)?)
    }
}

/// Generates a default `ShellsConfig` by detecting common shells available on the system.
fn generate_default_shells_config() -> ShellsConfig {
    let mut shells = HashMap::new();
    if cfg!(target_os = "windows") {
        shells.insert(
            "cmd".to_string(),
            ShellConfig {
                path: PathBuf::from("cmd.exe"),
                interactive_args: Some(vec!["/K".to_string()]),
            },
        );
        if is_executable_in_path("powershell.exe") {
            shells.insert(
                "powershell".to_string(),
                ShellConfig {
                    path: PathBuf::from("powershell.exe"),
                    interactive_args: Some(vec!["-NoExit".to_string(), "-File".to_string()]),
                },
            );
        }
    }
    let bash_path_str = if cfg!(target_os = "windows") {
        "bash.exe"
    } else {
        "bash"
    };
    if is_executable_in_path(bash_path_str) {
        shells.insert(
            "bash".to_string(),
            ShellConfig {
                path: PathBuf::from(bash_path_str),
                interactive_args: Some(vec!["--rcfile".to_string()]),
            },
        );
    }
    ShellsConfig { shells }
}

/// A helper function to check if an executable exists in any of the directories listed in the `PATH` environment variable.
fn is_executable_in_path(executable_name: &str) -> bool {
    if let Ok(path_var) = env::var("PATH") {
        for path in env::split_paths(&path_var) {
            if path.join(executable_name).is_file() {
                return true;
            }
        }
    }
    false
}

/// Returns the name of the default shell for the current operating system.
/// This is used as a fallback if a project does not specify a `shell` in its options.
pub fn get_default_shell_name() -> &'static str {
    if cfg!(target_os = "windows") {
        "cmd"
    } else {
        "bash"
    }
}
