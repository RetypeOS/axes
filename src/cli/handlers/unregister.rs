//! # Handler for the `unregister` command
//!
//! This module provides the logic for the `axes unregister` command. This is a non-destructive
//! operation that removes one or more projects from the `GlobalIndex` but leaves all their
//! files on the filesystem untouched. It's the inverse of `axes register`.
//!
//! ## Core Logic
//!
//! 1.  **Argument Parsing & Resolution**: It parses arguments like `--recursive` and `--reparent-to`
//!     and resolves the target project context.
//! 2.  **Planning**: It uses the shared `commons::prepare_operation_plan` utility to perform a
//!     "dry run" of the unregister operation. Crucially, it passes `is_destructive: false` to
//!     ensure the plan does not include any filesystem paths to be purged.
//! 3.  **Confirmation**: The `confirm_unregister_operation` function presents the detailed plan to the
//!     user, listing exactly which projects will be removed from the index, and requires explicit
//!     confirmation to proceed.
//! 4.  **Execution**: The `execute_unregister_plan` function performs the necessary mutations on the
//!     `GlobalIndex`:
//!     - If the operation is not recursive, it first reparents the direct children of the
//!       target project to a new parent (or to the "global" project by default).
//!     - It then removes all targeted project UUIDs from the index.

use anyhow::{Result, anyhow};
use clap::Parser;
use colored::*;
use dialoguer::{Confirm, theme::ColorfulTheme};

use crate::{
    cli::handlers::commons,
    core::{context_resolver, index_manager},
    models::{GlobalIndex, ResolvedConfig},
    state::AppStateGuard,
};

// --- Command Argument Parsing ---

#[derive(Parser, Debug, Default)]
#[command(
    no_binary_name = true,
    about = "Removes a project and its descendants from the axes index without deleting files."
)]
struct UnregisterArgs {
    /// The context of the project to unregister.
    context: Option<String>,

    /// Unregisters the project and ALL its descendants recursively.
    #[arg(long)]
    recursive: bool,

    /// Instead of unregistering direct children, reparents them to a new project.
    #[arg(long, conflicts_with = "recursive")]
    reparent_to: Option<String>,
}

// --- Main Handler ---

/// The main handler for the `unregister` command.
///
/// It orchestrates the four main phases: parsing arguments, planning the operation,
/// confirming with the user, and executing the changes in the index.
///
/// # Arguments
/// * `context` - The context of the project to unregister, provided by the dispatcher.
/// * `args` - Command-specific arguments (e.g., `--recursive`).
/// * `state_guard` - A mutable guard to the application state.
pub fn handle(
    context: Option<String>,
    args: Vec<String>,
    state_guard: &mut AppStateGuard<'_>,
) -> Result<()> {
    // 1. Parse & Resolve
    let unregister_args = UnregisterArgs::try_parse_from(&args)?;
    let final_context = unregister_args
        .context
        .or(context)
        .ok_or_else(|| anyhow!(t!("error.context_required"), command = "unregister"))?;
    let config = commons::resolve_config_for_context(Some(final_context), state_guard)?;

    if config.uuid == index_manager::GLOBAL_PROJECT_UUID {
        return Err(anyhow!(t!("unregister.error.cannot_unregister_global")));
    }

    // 2. Plan
    let plan = commons::prepare_operation_plan(
        state_guard,
        &config,
        unregister_args.recursive,
        unregister_args.reparent_to.clone(),
        false, // is_destructive
    )?;

    // 3. Confirm
    if !confirm_unregister_operation(state_guard.index(), &plan)? {
        return Ok(());
    }

    // 4. Execute
    execute_unregister_plan(
        state_guard,
        &config,
        &plan,
        unregister_args.recursive,
        &unregister_args.reparent_to,
    )?;

    Ok(())
}

/// Displays the operational plan to the user and asks for explicit confirmation before proceeding.
///
/// # Arguments
/// * `index` - An immutable reference to the `GlobalIndex` for reading project details.
/// * `plan` - The `OperationPlan` generated by `prepare_operation_plan`.
///
/// # Returns
/// `Ok(true)` if the user confirms, `Ok(false)` if they cancel.
fn confirm_unregister_operation(
    index: &GlobalIndex,
    plan: &commons::OperationPlan,
) -> Result<bool> {
    println!("\n{}", t!("unregister.info.header").yellow().bold());
    for line in &plan.summary_lines {
        println!("  - {}", line);
    }

    println!("\n{}", t!("unregister.info.projects_to_remove").dimmed());
    for uuid in &plan.uuids_to_remove {
        if let Some(entry) = index.projects.get(uuid) {
            let qualified_name = index_manager::build_qualified_name(*uuid, index)
                .unwrap_or_else(|| entry.name.clone());
            println!("    â€¢ {} ({})", qualified_name.cyan(), entry.path.display());
        }
    }

    if !Confirm::with_theme(&ColorfulTheme::default())
        .with_prompt(t!("common.prompt.continue"))
        .default(false)
        .interact()?
    {
        println!("\n{}", t!("common.info.operation_cancelled"));
        return Ok(false);
    }
    Ok(true)
}

/// Encapsulates the state-mutating logic that is executed after the user has confirmed the plan.
///
/// It handles the reparenting of children (if applicable) and the final removal of project
/// entries from the `GlobalIndex`.
///
/// # Arguments
/// * `state_guard` - A mutable guard to the application state.
/// * `config` - The resolved configuration of the primary target project.
/// * `plan` - The confirmed `OperationPlan` to be executed.
/// * `is_recursive` - A boolean indicating if the operation is recursive.
/// * `reparent_to` - An optional context string for the new parent.
fn execute_unregister_plan(
    state_guard: &mut AppStateGuard<'_>,
    config: &ResolvedConfig,
    plan: &commons::OperationPlan,
    is_recursive: bool,
    reparent_to: &Option<String>,
) -> Result<()> {
    log::info!(
        "Executing unregister plan for project '{}' ({})",
        config.qualified_name,
        config.uuid
    );

    let mut all_warnings = plan.reparent_warnings.clone();

    if !is_recursive {
        let new_parent_uuid = reparent_to
            .as_ref()
            .map(|ctx| context_resolver::resolve_context(ctx, state_guard).map(|(uuid, _)| uuid))
            .transpose()?
            .unwrap_or(index_manager::GLOBAL_PROJECT_UUID);

        log::debug!(
            "Reparenting children of '{}' to '{}'",
            config.uuid,
            new_parent_uuid
        );
        let reparent_op_warnings = index_manager::reparent_children(
            state_guard.index_mut(),
            config.uuid,
            new_parent_uuid,
        )?;
        all_warnings.extend(reparent_op_warnings);
    }

    log::debug!(
        "Removing {} UUID(s) from the index.",
        plan.uuids_to_remove.len()
    );
    let removed_count =
        index_manager::remove_from_index(state_guard.index_mut(), &plan.uuids_to_remove);

    println!(
        "\n{} {}",
        t!("common.success").green().bold(),
        format_args!(t!("unregister.success.header"), count = removed_count)
    );
    for warning in all_warnings {
        println!("  - {}", warning.yellow());
    }
    Ok(())
}
